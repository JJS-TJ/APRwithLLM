{
    "berry-2": {
     "buggy":"static void code_not(bfuncinfo *finfo, bexpdesc *e)\n{\n    switch (e->type) {\n    case ETINT: e->v.i = e->v.i == 0; break;\n    case ETREAL: e->v.i = e->v.r == cast(breal, 0); break;\n    case ETNIL: e->v.i = 1; break;\n    case ETBOOL: e->v.i = !e->v.i; break;\n    case ETSTRING: e->v.i = 0; break;\n    default: {\n        int temp = e->t;\n        e->t = e->f;\n        e->f = temp;\n        e->not = NOT_EXPR | (e->not ^ NOT_MASK);\n        return;\n    }\n    }\n    e->type = ETBOOL;\n}",
     "start": 572,
      "end": 589
    },
    "berry-3": {
        "buggy":"static void class_inherit(bparser *parser, bexpdesc *e)\n{\n    if (next_type(parser) == OptColon) { /* ':' */\n        bexpdesc e1;\n        scan_next_token(parser); /* skip ':' */\n        expr(parser, &e1);\n        check_var(parser, &e1);\n        be_code_setsuper(parser->finfo, e, &e1);\n    }\n}",
        "start": 1420,
         "end": 1429
       },
    "berry-4": {
        "buggy":"static int str_format(bvm *vm)\n{\n    int top = be_top(vm);\n    if (top > 0 && be_isstring(vm, 1)) {\n        int index = 2;\n        const char *format = be_tostring(vm, 1);\n        pushstr(vm, \"\", 0);\n        for (;;) {\n            char mode[MAX_FORMAT_MODE];\n            char buf[128];\n            const char *p = strchr(format, '%');\n            if (p == NULL) {\n                break;\n            }\n            pushstr(vm, format, p - format);\n            concat2(vm);\n            p = get_mode(p + 1, mode);\n            buf[0] = '\\0';\n            if (index > top) {\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"bad argument #%d to 'format': no value\", index));\n            }\n            switch (*p) {\n            case 'd': case 'i': case 'o':\n            case 'u': case 'x': case 'X':\n                if (be_isint(vm, index)) {\n                    mode_fixlen(mode, BE_INT_FMTLEN);\n                    sprintf(buf, mode, be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'e': case 'E':\n            case 'f': case 'g': case 'G':\n                if (be_isnumber(vm, index)) {\n                    sprintf(buf, mode, be_toreal(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 'c':\n                if (be_isint(vm, index)) {\n                    sprintf(buf, \"%c\", (int)be_toint(vm, index));\n                }\n                be_pushstring(vm, buf);\n                break;\n            case 's': {\n                const char *s = be_tostring(vm, index);\n                int len = be_strlen(vm, 2);\n                if (len > 100 && strlen(mode) == 2) {\n                    be_pushvalue(vm, index);\n                } else {\n                    sprintf(buf, mode, s);\n                    be_pushstring(vm, buf);\n                }\n                break;\n            }\n            default: /* error */\n                be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                    \"invalid option '%%%c' to 'format'\", *p));\n                break;\n            }\n            concat2(vm);\n            format = p + 1;\n            ++index;\n        }\n        pushstr(vm, format, strlen(format));\n        concat2(vm);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "start": 497,
         "end": 566
       },
    "berry-5": {
        "buggy":"static void free_suffix(bfuncinfo *finfo, bexpdesc *e)\n{\n    int idx = e->v.ss.idx;\n    int nlocal = be_list_count(finfo->local);\n    /* release suffix register */\n    if (!isK(idx) && idx >= nlocal) {\n        be_code_freeregs(finfo, 1);\n    }\n    /* release object register */\n    if (e->v.ss.tt == ETREG && (int)e->v.ss.obj >= nlocal) {\n        be_code_freeregs(finfo, 1);\n    }\n}",
        "start": 311,
         "end": 323
       },
    "coreutils-1": {
        "buggy":"static void\nbytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,\n                     size_t initial_read, off_t file_size)\n{\n  off_t start;\n  off_t end;\n\n  assert (k && n && k <= n && n <= file_size);\n\n  start = (k - 1) * (file_size / n);\n  end = (k == n) ? file_size : k * (file_size / n);\n\n  if (initial_read != SIZE_MAX || start < initial_read)\n    {\n      memmove (buf, buf + start, initial_read - start);\n      initial_read -= start;\n    }\n  else\n    {\n      if (lseek (STDIN_FILENO, start, SEEK_CUR) < 0)\n        die (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n      initial_read = SIZE_MAX;\n    }\n\n  while (start < end)\n    {\n      size_t n_read;\n      if (initial_read != SIZE_MAX)\n        {\n          n_read = initial_read;\n          initial_read = SIZE_MAX;\n        }\n      else\n        {\n          n_read = safe_read (STDIN_FILENO, buf, bufsize);\n          if (n_read == SAFE_READ_ERROR)\n            die (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n        }\n      if (n_read == 0)\n        break; /* eof.  */\n      n_read = MIN (n_read, end - start);\n      if (full_write (STDOUT_FILENO, buf, n_read) != n_read\n          && ! ignorable (errno))\n        die (EXIT_FAILURE, errno, \"%s\", quotef (\"-\"));\n      start += n_read;\n    }\n}",
        "start": 973,
         "end": 1019
       },
    "coreutils-2": {
        "buggy":"static void\ninit_parameters (int number_of_files)\n{\n  int chars_used_by_number = 0;\n\n  lines_per_body = lines_per_page - lines_per_header - lines_per_footer;\n  if (lines_per_body <= 0)\n    {\n      extremities = false;\n      keep_FF = true;\n    }\n  if (extremities == false)\n    lines_per_body = lines_per_page;\n\n  if (double_space)\n    lines_per_body = lines_per_body / 2;\n\n  /* If input is stdin, cannot print parallel files.  BSD dumps core\n     on this. */\n  if (number_of_files == 0)\n    parallel_files = false;\n\n  if (parallel_files)\n    columns = number_of_files;\n\n  /* One file, multi columns down: -b option is set to get a consistent\n     formulation with \"FF set by hand\" in input files. */\n  if (storing_columns)\n    balance_columns = true;\n\n  /* Tabification is assumed for multiple columns. */\n  if (columns > 1)\n    {\n      if (!use_col_separator)\n        {\n          /* Use default separator */\n          if (join_lines)\n            col_sep_string = line_separator;\n          else\n            col_sep_string = column_separator;\n\n          col_sep_length = 1;\n          use_col_separator = true;\n        }\n      /* It's rather pointless to define a TAB separator with column\n         alignment */\n      else if (!join_lines && *col_sep_string == '\\t')\n        col_sep_string = column_separator;\n\n      truncate_lines = true;\n      tabify_output = true;\n    }\n  else\n    storing_columns = false;\n\n  /* -J dominates -w in any case */\n  if (join_lines)\n    truncate_lines = false;\n\n  if (numbered_lines)\n    {\n      int chars_per_default_tab = 8;\n\n      line_count = start_line_num;\n\n      /* To allow input tab-expansion (-e sensitive) use:\n         if (number_separator == input_tab_char)\n           number_width = chars_per_number\n             + TAB_WIDTH (chars_per_input_tab, chars_per_number);   */\n\n      /* Estimate chars_per_text without any margin and keep it constant. */\n      if (number_separator == '\\t')\n        number_width = (chars_per_number\n                        + TAB_WIDTH (chars_per_default_tab, chars_per_number));\n      else\n        number_width = chars_per_number + 1;\n\n      /* The number is part of the column width unless we are\n         printing files in parallel. */\n      if (parallel_files)\n        chars_used_by_number = number_width;\n    }\n\n  int sep_chars, useful_chars;\n  if (INT_MULTIPLY_WRAPV (columns - 1, col_sep_length, &sep_chars))\n    sep_chars = INT_MAX;\n  if (INT_SUBTRACT_WRAPV (chars_per_line - chars_used_by_number, sep_chars,\n                          &useful_chars))\n    useful_chars = 0;\n  chars_per_column = useful_chars / columns;\n\n  if (chars_per_column < 1)\n    die (EXIT_FAILURE, 0, _(\"page width too narrow\"));\n\n  if (numbered_lines)\n    {\n      free (number_buff);\n      number_buff = xmalloc (MAX (chars_per_number,\n                                  INT_STRLEN_BOUND (line_number)) + 1);\n    }\n\n  /* Pick the maximum between the tab width and the width of an\n     escape sequence.\n     The width of an escape sequence (4) isn't the lower limit any longer.\n     We've to use 8 as the lower limit, if we use chars_per_default_tab = 8\n     to expand a tab which is not an input_tab-char. */\n  free (clump_buff);\n  clump_buff = xmalloc (MAX (8, chars_per_input_tab));\n}",
        "start": 1190,
         "end": 1298
       },       
    "cpp_peglib-1": {
        "buggy":"  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,\n                                        const Rules &rules, std::string &start,\n                                        Log log) {\n    Data data;\n    any dt = &data;\n    auto r = g[\"Grammar\"].parse(s, n, dt);\n\n    if (!r.ret) {\n      if (log) {\n        if (r.message_pos) {\n          auto line = line_info(s, r.message_pos);\n          log(line.first, line.second, r.message);\n        } else {\n          auto line = line_info(s, r.error_pos);\n          log(line.first, line.second, \"syntax error\");\n        }\n      }\n      return nullptr;\n    }\n\n    auto &grammar = *data.grammar;\n\n    // User provided rules\n    for (const auto &x : rules) {\n      auto name = x.first;\n      bool ignore = false;\n      if (!name.empty() && name[0] == '~') {\n        ignore = true;\n        name.erase(0, 1);\n      }\n      if (!name.empty()) {\n        auto &rule = grammar[name];\n        rule <= x.second;\n        rule.name = name;\n        rule.ignoreSemanticValue = ignore;\n      }\n    }\n\n    // Check duplicated definitions\n    bool ret = data.duplicates.empty();\n\n    for (const auto &x : data.duplicates) {\n      if (log) {\n        const auto &name = x.first;\n        auto ptr = x.second;\n        auto line = line_info(s, ptr);\n        log(line.first, line.second, \"'\" + name + \"' is already defined.\");\n      }\n    }\n\n    // Check if the start rule has ignore operator\n    {\n      auto &rule = grammar[data.start];\n      if (rule.ignoreSemanticValue) {\n        if (log) {\n          auto line = line_info(s, rule.s_);\n          log(line.first, line.second,\n              \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");\n        }\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Check missing definitions\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n\n      ReferenceChecker vis(*data.grammar, rule.params);\n      rule.accept(vis);\n      for (const auto &y : vis.error_s) {\n        const auto &name = y.first;\n        const auto ptr = y.second;\n        if (log) {\n          auto line = line_info(s, ptr);\n          log(line.first, line.second, vis.error_message[name]);\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Link references\n    for (auto &x : grammar) {\n      auto &rule = x.second;\n      LinkReferences vis(*data.grammar, rule.params);\n      rule.accept(vis);\n    }\n\n    // Check left recursion\n    ret = true;\n\n    for (auto &x : grammar) {\n      const auto &name = x.first;\n      auto &rule = x.second;\n\n      DetectLeftRecursion vis(name);\n      rule.accept(vis);\n      if (vis.error_s) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second, \"'\" + name + \"' is left recursive.\");\n        }\n        ret = false;\n      }\n    }\n\n    if (!ret) { return nullptr; }\n\n    // Set root definition\n    auto &start_rule = (*data.grammar)[data.start];\n\n    // Check infinite loop\n    {\n      DetectInfiniteLoop vis(data.start_pos, data.start);\n      start_rule.accept(vis);\n      if (vis.has_error) {\n        if (log) {\n          auto line = line_info(s, vis.error_s);\n          log(line.first, line.second,\n              \"infinite loop is detected in '\" + vis.error_name + \"'.\");\n        }\n        return nullptr;\n      }\n    }\n\n    // Automatic whitespace skipping\n    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {\n      for (auto &x : grammar) {\n        auto &rule = x.second;\n        auto ope = rule.get_core_operator();\n        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }\n      }\n\n      start_rule.whitespaceOpe =\n          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());\n    }\n\n    // Word expression\n    if (grammar.count(WORD_DEFINITION_NAME)) {\n      start_rule.wordOpe =\n          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();\n    }\n\n    // Apply instructions\n    for (const auto &item : data.instructions) {\n      const auto &name = item.first;\n      const auto &instruction = item.second;\n      auto &rule = grammar[name];\n\n      if (instruction.type == \"precedence\") {\n        const auto &info =\n            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);\n\n        if (!apply_precedence_instruction(rule, info, s, log)) {\n          return nullptr;\n        }\n      }\n    }\n\n    // Set root definition\n    start = data.start;\n\n    return data.grammar;\n  }",
        "start": 3389,
         "end": 3554
       }, 
    "cpp_peglib-2": {
        "buggy":"inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,\n                                 Context &c, any &dt) const {\n  if (!ope_) {\n    throw std::logic_error(\"Uninitialized definition ope was used...\");\n  }\n\n  // Macro reference\n  // TODO: need packrat support\n  if (outer_->is_macro) { return ope_->parse(s, n, sv, c, dt); }\n\n  size_t len;\n  any val;\n\n  c.packrat(s, outer_->id, len, val, [&](any &a_val) {\n    if (outer_->enter) { outer_->enter(s, n, dt); }\n\n    auto se2 = make_scope_exit([&]() {\n      c.pop();\n\n      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }\n    });\n\n    auto &chldsv = c.push();\n\n    c.rule_stack.push_back(outer_);\n    len = ope_->parse(s, n, chldsv, c, dt);\n    c.rule_stack.pop_back();\n\n    // Invoke action\n    if (success(len)) {\n      chldsv.s_ = s;\n      chldsv.n_ = len;\n      chldsv.name_ = outer_->name;\n\n      if (!IsPrioritizedChoice::check(*ope_)) {\n        chldsv.choice_count_ = 0;\n        chldsv.choice_ = 0;\n      }\n\n      try {\n        a_val = reduce(chldsv, dt);\n      } catch (const parse_error &e) {\n        if (e.what()) {\n          if (c.message_pos < s) {\n            c.message_pos = s;\n            c.message = e.what();\n          }\n        }\n        len = static_cast<size_t>(-1);\n      }\n    }\n  });\n\n  if (success(len)) {\n    if (!outer_->ignoreSemanticValue) {\n      sv.emplace_back(std::move(val));\n      sv.tags.emplace_back(str2tag(outer_->name.c_str()));\n    }\n  } else {\n    if (outer_->error_message) {\n      if (c.message_pos < s) {\n        c.message_pos = s;\n        c.message = outer_->error_message();\n      }\n    }\n  }\n\n  return len;\n}",
        "start": 2472,
         "end": 2540
       },
    "cpp_peglib-3": {
        "buggy":"  template <typename T = Ast> parser &enable_ast() {\n    for (auto &x : *grammar_) {\n      auto &rule = x.second;\n      if (!rule.action) { add_ast_action(rule); }\n    }\n    return *this;\n  }\n",
        "start": 3937,
         "end": 3943
       },
    "cpp_peglib-4": {
        "buggy":"inline void LinkReferences::visit(Reference& ope) {\n    // Check if the reference is a macro parameter\n    auto found_param = false;\n    for (size_t i = 0; i < params_.size(); i++) {\n        const auto& param = params_[i];\n        if (param == ope.name_) {\n            ope.iarg_ = i;\n            found_param = true;\n            break;\n        }\n    }\n\n    // Check if the reference is a definition rule\n    if (grammar_.count(ope.name_)) {\n        auto& rule = grammar_.at(ope.name_);\n        ope.rule_ = &rule;\n    }\n\n    for (auto arg: ope.args_) {\n        arg->accept(*this);\n    }\n}",
        "start": 2488,
         "end": 2509
       },
    "cpp_peglib-5": {
        "buggy":"inline void DetectLeftRecursion::visit(Reference& ope) {\n    if (ope.name_ == name_) {\n        error_s = ope.s_;\n    } else if (!refs_.count(ope.name_)) {\n        refs_.insert(ope.name_);\n        if (ope.rule_) {\n            ope.rule_->accept(*this);\n        }\n    }\n    done_ = true;\n}",
        "start": 2370,
         "end": 2380
       },
    "cpp_peglib-6": {
        "buggy":"inline void AssignIDToDefinition::visit(Reference& ope) {\n    if (ope.rule_) {\n        ope.rule_->accept(*this);\n    }\n}",
        "start": 2030,
         "end": 2034
       },
    "cpp_peglib-7": {
        "buggy":"    std::pair<size_t, size_t> line_info() const {\n}",
        "start": 247,
         "end": 248
       },
    "cpp_peglib-8": {
        "buggy":"void make_grammar() {\n        // Setup PEG syntax parser\n        g[\"Grammar\"]    <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);\n        g[\"Definition\"] <= seq(opt(g[\"IGNORE\"]), g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"]);\n\n        g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));\n        g[\"Sequence\"]   <= zom(g[\"Prefix\"]);\n        g[\"Prefix\"]     <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);\n        g[\"Suffix\"]     <= seq(g[\"Primary\"], opt(cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"])));\n        g[\"Primary\"]    <= cho(seq(opt(g[\"IGNORE\"]), g[\"Identifier\"], npd(g[\"LEFTARROW\"])),\n                               seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),\n                               seq(g[\"Begin\"], g[\"Expression\"], g[\"End\"]),\n                               seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]),\n                               g[\"Literal\"], g[\"Class\"], g[\"DOT\"]);\n\n        g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);\n        g[\"IdentCont\"]  <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));\n        g[\"IdentStart\"] <= cls(\"a-zA-Z_\");\n        g[\"IdentRest\"]  <= cho(g[\"IdentStart\"], cls(\"0-9\"));\n\n        g[\"Literal\"]    <= cho(seq(cls(\"'\"), anc(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), cls(\"'\"), g[\"Spacing\"]),\n                               seq(cls(\"\\\"\"), anc(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), cls(\"\\\"\"), g[\"Spacing\"]));\n\n        g[\"Class\"]      <= seq(chr('['), anc(zom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'), g[\"Spacing\"]);\n\n        g[\"Range\"]      <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);\n        g[\"Char\"]       <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\\")),\n                               seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),\n                               seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),\n                               seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),\n                               seq(npd(chr('\\\\')), dot()));\n\n        g[\"LEFTARROW\"]  <= seq(lit(\"<-\"), g[\"Spacing\"]);\n        ~g[\"SLASH\"]     <= seq(chr('/'), g[\"Spacing\"]);\n        g[\"AND\"]        <= seq(chr('&'), g[\"Spacing\"]);\n        g[\"NOT\"]        <= seq(chr('!'), g[\"Spacing\"]);\n        g[\"QUESTION\"]   <= seq(chr('?'), g[\"Spacing\"]);\n        g[\"STAR\"]       <= seq(chr('*'), g[\"Spacing\"]);\n        g[\"PLUS\"]       <= seq(chr('+'), g[\"Spacing\"]);\n        g[\"OPEN\"]       <= seq(chr('('), g[\"Spacing\"]);\n        g[\"CLOSE\"]      <= seq(chr(')'), g[\"Spacing\"]);\n        g[\"DOT\"]        <= seq(chr('.'), g[\"Spacing\"]);\n\n        g[\"Spacing\"]    <= zom(cho(g[\"Space\"], g[\"Comment\"]));\n        g[\"Comment\"]    <= seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);\n        g[\"Space\"]      <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);\n        g[\"EndOfLine\"]  <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));\n        g[\"EndOfFile\"]  <= npd(dot());\n\n        g[\"Begin\"]      <= seq(chr('<'), g[\"Spacing\"]);\n        g[\"End\"]        <= seq(chr('>'), g[\"Spacing\"]);\n\n        g[\"BeginCap\"]   <= seq(chr('$'), anc(opt(g[\"Identifier\"])), chr('<'), g[\"Spacing\"]);\n        g[\"EndCap\"]     <= seq(lit(\">\"), g[\"Spacing\"]);\n\n        g[\"IGNORE\"]     <= chr('~');\n\n        // Set definition names\n        for (auto& x: g) {\n            x.second.name = x.first;\n        }\n    }",
        "start": 1574,
         "end": 1635
       },
    "cppcheck-1": {
        "buggy":"void CheckLeakAutoVar::ret(const Token *tok, const VarInfo &varInfo)\n{\n    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;\n    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (std::map<int, VarInfo::AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {\n        // don't warn if variable is conditionally allocated\n        if (!it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())\n            continue;\n\n        // don't warn if there is a reference of the variable\n        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())\n            continue;\n\n        const int varid = it->first;\n        const Variable *var = symbolDatabase->getVariableFromVarId(varid);\n        if (var) {\n            bool used = false;\n            for (const Token *tok2 = tok; tok2; tok2 = tok2->next()) {\n                if (tok2->str() == \";\")\n                    break;\n                if (Token::Match(tok2, \"return|(|{|, %varid% [});,]\", varid)) {\n                    used = true;\n                    break;\n                }\n                if (Token::Match(tok2, \"return|(|{|, & %varid% . %name% [});,]\", varid)) {\n                    used = true;\n                    break;\n                }\n            }\n\n            // return deallocated pointer\n            if (used && it->second.status == VarInfo::DEALLOC)\n                deallocReturnError(tok, var->name());\n\n            else if (!used && !it->second.managed()) {\n                const std::map<int, std::string>::const_iterator use = possibleUsage.find(varid);\n                if (use == possibleUsage.end()) {\n                    leakError(tok, var->name(), it->second.type);\n                } else {\n                    configurationInfo(tok, use->second);\n                }\n            }\n        }\n    }\n}",
        "start": 913,
         "end": 959
       },
    "cppcheck-2": {
        "buggy":"void CheckOther::checkRedundantAssignment()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope *scope : symbolDatabase->functionScopes) {\n        if (!scope->bodyStart)\n            continue;\n        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {\n            if (Token::simpleMatch(tok, \"] (\"))\n                // todo: handle lambdas\n                break;\n            if (Token::simpleMatch(tok, \"try {\"))\n                // todo: check try blocks\n                tok = tok->linkAt(1);\n            if ((tok->isAssignmentOp() || Token::Match(tok, \"++|--\")) && tok->astOperand1()) {\n                if (tok->astParent())\n                    continue;\n\n                // Do not warn about redundant initialization when rhs is trivial\n                // TODO : do not simplify the variable declarations\n                bool isInitialization = false;\n                if (Token::Match(tok->tokAt(-3), \"%var% ; %var% =\") && tok->previous()->variable() && tok->previous()->variable()->nameToken() == tok->tokAt(-3) && tok->tokAt(-3)->linenr() == tok->previous()->linenr()) {\n                    isInitialization = true;\n                    bool trivial = true;\n                    visitAstNodes(tok->astOperand2(),\n                    [&](const Token *rhs) {\n                        if (Token::simpleMatch(rhs, \"{ 0 }\"))\n                            return ChildrenToVisit::none;\n                        if (Token::Match(rhs, \"%str%|%num%|%name%\") && !rhs->varId())\n                            return ChildrenToVisit::none;\n                        if (rhs->isCast())\n                            return ChildrenToVisit::op2;\n                        trivial = false;\n                        return ChildrenToVisit::done;\n                    });\n                    if (trivial)\n                        continue;\n                }\n\n                // Do not warn about assignment with 0 / NULL\n                if (Token::simpleMatch(tok->astOperand2(), \"0\") || FwdAnalysis::isNullOperand(tok->astOperand2()))\n                    continue;\n\n                if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isReference())\n                    // todo: check references\n                    continue;\n\n                if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isStatic())\n                    // todo: check static variables\n                    continue;\n\n                // If there is a custom assignment operator => this is inconclusive\n                bool inconclusive = false;\n                if (mTokenizer->isCPP() && tok->astOperand1()->valueType() && tok->astOperand1()->valueType()->typeScope) {\n                    const std::string op = \"operator\" + tok->str();\n                    for (const Function &f : tok->astOperand1()->valueType()->typeScope->functionList) {\n                        if (f.name() == op) {\n                            inconclusive = true;\n                            break;\n                        }\n                    }\n                }\n                if (inconclusive && !mSettings->inconclusive)\n                    continue;\n\n                FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);\n                if (fwdAnalysis.hasOperand(tok->astOperand2(), tok->astOperand1()))\n                    continue;\n\n                // Is there a redundant assignment?\n                const Token *start;\n                if (tok->isAssignmentOp())\n                    start = tok->next();\n                else\n                    start = tok->findExpressionStartEndTokens().second->next();\n\n                // Get next assignment..\n                const Token *nextAssign = fwdAnalysis.reassign(tok->astOperand1(), start, scope->bodyEnd);\n\n                if (!nextAssign)\n                    continue;\n\n                // there is redundant assignment. Is there a case between the assignments?\n                bool hasCase = false;\n                for (const Token *tok2 = tok; tok2 != nextAssign; tok2 = tok2->next()) {\n                    if (tok2->str() == \"break\" || tok2->str() == \"return\")\n                        break;\n                    if (tok2->str() == \"case\") {\n                        hasCase = true;\n                        break;\n                    }\n                }\n\n                // warn\n                if (hasCase)\n                    redundantAssignmentInSwitchError(tok, nextAssign, tok->astOperand1()->expressionString());\n                else if (isInitialization)\n                    redundantInitializationError(tok, nextAssign, tok->astOperand1()->expressionString(), inconclusive);\n                else\n                    redundantAssignmentError(tok, nextAssign, tok->astOperand1()->expressionString(), inconclusive);\n            }\n        }\n    }\n}",
        "start": 415,
         "end": 519
       },
    "cppcheck-4": {
        "buggy":"static const Token *checkMissingReturnScope(const Token *tok, const Library &library)\n{\n    const Token *lastStatement = nullptr;\n    while ((tok = tok->previous()) != nullptr) {\n        if (tok->str() == \"{\")\n            return lastStatement ? lastStatement : tok->next();\n        if (tok->str() == \"}\") {\n            for (const Token *prev = tok->link()->previous(); prev && prev->scope() == tok->scope() && !Token::Match(prev, \"[;{}]\"); prev = prev->previous()) {\n                if (prev->isKeyword() && Token::Match(prev, \"return|throw\"))\n                    return nullptr;\n                if (prev->str() == \"goto\" && !isForwardJump(prev))\n                    return nullptr;\n            }\n            if (tok->scope()->type == Scope::ScopeType::eSwitch) {\n                // find reachable break / !default\n                bool hasDefault = false;\n                bool reachable = false;\n                for (const Token *switchToken = tok->link(); switchToken != tok; switchToken = switchToken->next()) {\n                    if (reachable && Token::simpleMatch(switchToken, \"break ;\"))\n                        return switchToken;\n                    if (switchToken->isKeyword() && Token::Match(switchToken, \"return|throw\"))\n                        reachable = false;\n                    if (Token::Match(switchToken, \"%name% (\") && library.isnoreturn(switchToken))\n                        reachable = false;\n                    if (Token::Match(switchToken, \"case|default\"))\n                        reachable = true;\n                    if (Token::simpleMatch(switchToken, \"default :\"))\n                        hasDefault = true;\n                    else if (switchToken->str() == \"{\" && switchToken->scope()->isLoopScope())\n                        switchToken = switchToken->link();\n                }\n                if (!hasDefault)\n                    return tok->link();\n            } else if (tok->scope()->type == Scope::ScopeType::eIf) {\n                const Token *condition = tok->scope()->classDef->next()->astOperand2();\n                if (condition && condition->hasKnownIntValue() && condition->getKnownIntValue() == 1)\n                    return checkMissingReturnScope(tok, library);\n                return tok;\n            } else if (tok->scope()->type == Scope::ScopeType::eElse) {\n                const Token *errorToken = checkMissingReturnScope(tok, library);\n                if (errorToken)\n                    return errorToken;\n                tok = tok->link();\n                if (Token::simpleMatch(tok->tokAt(-2), \"} else {\"))\n                    return checkMissingReturnScope(tok->tokAt(-2), library);\n                return tok;\n            }\n            // FIXME\n            return nullptr;\n        }\n        if (tok->isKeyword() && Token::Match(tok, \"return|throw\"))\n            return nullptr;\n        if (tok->str() == \"goto\" && !isForwardJump(tok))\n            return nullptr;\n        if (Token::Match(tok, \"%name% (\") && library.isnoreturn(tok))\n            return nullptr;\n        if (Token::Match(tok, \"[;{}] %name% :\"))\n            return tok;\n        if (Token::Match(tok, \"; !!}\") && !lastStatement)\n            lastStatement = tok->next();\n    }\n    return nullptr;\n}",
        "start": 287,
         "end": 349
       },
    "cppcheck-5": {
        "buggy":"bool isTemporary(bool cpp, const Token* tok, const Library* library, bool unknown)\n{\n    if (!tok)\n        return false;\n    if (Token::simpleMatch(tok, \".\"))\n        return (tok->originalName() != \"->\" && isTemporary(cpp, tok->astOperand1(), library)) ||\n               isTemporary(cpp, tok->astOperand2(), library);\n    if (Token::Match(tok, \",|::\"))\n        return isTemporary(cpp, tok->astOperand2(), library);\n    if (tok->isCast() || (cpp && isCPPCast(tok)))\n        return isTemporary(cpp, tok->astOperand2(), library);\n    if (Token::Match(tok, \"?|.|[|++|--|%name%|%assign%\"))\n        return false;\n    if (tok->isUnaryOp(\"*\"))\n        return false;\n    if (Token::Match(tok, \"&|<<|>>\") && isLikelyStream(cpp, tok->astOperand1()))\n        return false;\n    if (Token::Match(tok->previous(), \">|%name% (\")) {\n        const Token* ftok = nullptr;\n        if (tok->previous()->link())\n            ftok = tok->previous()->link()->previous();\n        else\n            ftok = tok->previous();\n        if (!ftok)\n            return false;\n        if (const Function * f = ftok->function()) {\n            return !Function::returnsReference(f, true);\n        } else if (library) {\n            std::string returnType = library->returnValueType(ftok);\n            return !returnType.empty() && returnType.back() != '&';\n        } else {\n            return unknown;\n        }\n    }\n    return true;\n}",
        "start": 223,
         "end": 258
       },
    "cppcheck-7": {
        "buggy":"void Tokenizer::removeMacrosInGlobalScope()\n{\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (tok->str() == \"(\") {\n            tok = tok->link();\n            if (Token::Match(tok, \") %type% {\") &&\n                !Token::Match(tok->next(), \"const|namespace|class|struct|union|noexcept|override|final|volatile\"))\n                tok->deleteNext();\n        }\n\n        if (Token::Match(tok, \"%type%\") && tok->isUpperCaseName() &&\n            (!tok->previous() || Token::Match(tok->previous(), \"[;{}]\") || (tok->previous()->isName() && endsWith(tok->previous()->str(), ':')))) {\n            const Token *tok2 = tok->next();\n            if (tok2 && tok2->str() == \"(\")\n                tok2 = tok2->link()->next();\n\n\n            if (Token::Match(tok, \"%name% (\") && Token::Match(tok2, \"%name% *|&|::|<| %name%\") && !Token::Match(tok2, \"namespace|class|struct|union\"))\n                unknownMacroError(tok);\n\n            if (Token::Match(tok, \"%type% (\") && Token::Match(tok2, \"%type% (\") && !Token::Match(tok2, \"noexcept|throw\") && isFunctionHead(tok2->next(), \":;{\"))\n                unknownMacroError(tok);\n\n            // remove unknown macros before namespace|class|struct|union\n            if (Token::Match(tok2, \"namespace|class|struct|union\")) {\n                // is there a \"{\" for?\n                const Token *tok3 = tok2;\n                while (tok3 && !Token::Match(tok3,\"[;{}()]\"))\n                    tok3 = tok3->next();\n                if (tok3 && tok3->str() == \"{\") {\n                    Token::eraseTokens(tok, tok2);\n                    tok->deleteThis();\n                }\n                continue;\n            }\n\n            // replace unknown macros before foo(\n            /*\n                        if (Token::Match(tok2, \"%type% (\") && isFunctionHead(tok2->next(), \"{\")) {\n                            std::string typeName;\n                            for (const Token* tok3 = tok; tok3 != tok2; tok3 = tok3->next())\n                                typeName += tok3->str();\n                            Token::eraseTokens(tok, tok2);\n                            tok->str(typeName);\n                        }\n            */\n            // remove unknown macros before foo::foo(\n            if (Token::Match(tok2, \"%type% :: %type%\")) {\n                const Token *tok3 = tok2;\n                while (Token::Match(tok3, \"%type% :: %type% ::\"))\n                    tok3 = tok3->tokAt(2);\n                if (Token::Match(tok3, \"%type% :: %type% (\") && tok3->str() == tok3->strAt(2)) {\n                    Token::eraseTokens(tok, tok2);\n                    tok->deleteThis();\n                }\n                continue;\n            }\n        }\n\n        // Skip executable scopes\n        if (tok->str() == \"{\") {\n            const Token *prev = tok->previous();\n            while (prev && prev->isName())\n                prev = prev->previous();\n            if (prev && prev->str() == \")\")\n                tok = tok->link();\n        }\n    }\n}",
        "start": 5024,
         "end": 5092
       },
    "cppcheck-8": {
        "buggy":"bool isLikelyStreamRead(bool cpp, const Token *op)\n{\n    if (!cpp)\n        return false;\n\n    if (!Token::Match(op, \"&|>>\") || !op->isBinaryOp())\n        return false;\n\n    if (!Token::Match(op->astOperand2(), \"%name%|.|*|[\") && op->str() != op->astOperand2()->str())\n        return false;\n\n    const Token *parent = op;\n    while (parent->astParent() && parent->astParent()->str() == op->str())\n        parent = parent->astParent();\n    if (parent->astParent() && !Token::Match(parent->astParent(), \"%oror%|&&|(|,|!\"))\n        return false;\n    if (op->str() == \"&\" && parent->astParent())\n        return false;\n    if (!parent->astOperand1() || !parent->astOperand2())\n        return false;\n    return (!parent->astOperand1()->valueType() || !parent->astOperand1()->valueType()->isIntegral());\n}",
        "start": 1567,
         "end": 1588
       },
    "cppcheck-9": {
        "buggy":"std::vector<LifetimeToken> getLifetimeTokens(const Token* tok, ValueFlow::Value::ErrorPath errorPath, int depth)\n{\n    if (!tok)\n        return std::vector<LifetimeToken> {};\n    const Variable *var = tok->variable();\n    if (depth < 0)\n        return {{tok, std::move(errorPath)}};\n    if (var && var->declarationId() == tok->varId()) {\n        if (var->isReference() || var->isRValueReference()) {\n            if (!var->declEndToken())\n                return {{tok, true, std::move(errorPath)}};\n            if (var->isArgument()) {\n                errorPath.emplace_back(var->declEndToken(), \"Passed to reference.\");\n                return {{tok, true, std::move(errorPath)}};\n            } else if (Token::simpleMatch(var->declEndToken(), \"=\")) {\n                errorPath.emplace_back(var->declEndToken(), \"Assigned to reference.\");\n                const Token *vartok = var->declEndToken()->astOperand2();\n                if (vartok == tok || (var->isConst() && isTemporary(true, vartok, nullptr, true)))\n                    return {{tok, true, std::move(errorPath)}};\n                if (vartok)\n                    return getLifetimeTokens(vartok, std::move(errorPath), depth - 1);\n            } else if (Token::simpleMatch(var->nameToken()->astParent(), \":\") &&\n                       var->nameToken()->astParent()->astParent() &&\n                       Token::simpleMatch(var->nameToken()->astParent()->astParent()->previous(), \"for (\")) {\n                errorPath.emplace_back(var->nameToken(), \"Assigned to reference.\");\n                const Token* vartok = var->nameToken();\n                if (vartok == tok)\n                    return {{tok, true, std::move(errorPath)}};\n                const Token* contok = var->nameToken()->astParent()->astOperand2();\n                if (contok)\n                    return getLifetimeTokens(contok, std::move(errorPath), depth - 1);\n            } else {\n                return std::vector<LifetimeToken> {};\n            }\n        }\n    } else if (Token::Match(tok->previous(), \"%name% (\")) {\n        const Function *f = tok->previous()->function();\n        if (f) {\n            if (!Function::returnsReference(f))\n                return {{tok, std::move(errorPath)}};\n            std::vector<LifetimeToken> result;\n            std::vector<const Token*> returns = Function::findReturns(f);\n            for (const Token* returnTok : returns) {\n                if (returnTok == tok)\n                    continue;\n                for (LifetimeToken& lt : getLifetimeTokens(returnTok, std::move(errorPath), depth - 1)) {\n                    const Token* argvarTok = lt.token;\n                    const Variable* argvar = argvarTok->variable();\n                    if (!argvar)\n                        continue;\n                    if (argvar->isArgument() && (argvar->isReference() || argvar->isRValueReference())) {\n                        int n = getArgumentPos(argvar, f);\n                        if (n < 0)\n                            return std::vector<LifetimeToken> {};\n                        std::vector<const Token*> args = getArguments(tok->previous());\n                        // TODO: Track lifetimes of default parameters\n                        if (n >= args.size())\n                            return std::vector<LifetimeToken> {};\n                        const Token* argTok = args[n];\n                        lt.errorPath.emplace_back(returnTok, \"Return reference.\");\n                        lt.errorPath.emplace_back(tok->previous(), \"Called function passing '\" + argTok->str() + \"'.\");\n                        std::vector<LifetimeToken> arglts = LifetimeToken::setInconclusive(\n                                                                getLifetimeTokens(argTok, std::move(lt.errorPath), depth - 1), returns.size() > 1);\n                        result.insert(result.end(), arglts.begin(), arglts.end());\n                    }\n                }\n            }\n            return result;\n        } else if (Token::Match(tok->tokAt(-2), \". %name% (\") && astIsContainer(tok->tokAt(-2)->astOperand1())) {\n            const Library::Container* library = getLibraryContainer(tok->tokAt(-2)->astOperand1());\n            Library::Container::Yield y = library->getYield(tok->previous()->str());\n            if (y == Library::Container::Yield::AT_INDEX || y == Library::Container::Yield::ITEM) {\n                errorPath.emplace_back(tok->previous(), \"Accessing container.\");\n                return LifetimeToken::setAddressOf(\n                           getLifetimeTokens(tok->tokAt(-2)->astOperand1(), std::move(errorPath), depth - 1), false);\n            }\n        }\n    } else if (Token::Match(tok, \".|::|[\")) {\n        const Token *vartok = tok;\n        while (vartok) {\n            if (vartok->str() == \"[\" || vartok->originalName() == \"->\")\n                vartok = vartok->astOperand1();\n            else if (vartok->str() == \".\" || vartok->str() == \"::\")\n                vartok = vartok->astOperand2();\n            else\n                break;\n        }\n\n        if (!vartok)\n            return {{tok, std::move(errorPath)}};\n        const Variable *tokvar = vartok->variable();\n        if (!astIsContainer(vartok) && !(tokvar && tokvar->isArray() && !tokvar->isArgument()) &&\n            (Token::Match(vartok->astParent(), \"[|*\") || vartok->astParent()->originalName() == \"->\")) {\n            for (const ValueFlow::Value &v : vartok->values()) {\n                if (!v.isLocalLifetimeValue())\n                    continue;\n                errorPath.insert(errorPath.end(), v.errorPath.begin(), v.errorPath.end());\n                return getLifetimeTokens(v.tokvalue, std::move(errorPath));\n            }\n        } else {\n            return LifetimeToken::setAddressOf(getLifetimeTokens(vartok, std::move(errorPath)),\n                                               !(astIsContainer(vartok) && Token::simpleMatch(vartok->astParent(), \"[\")));\n        }\n    }\n    return {{tok, std::move(errorPath)}};\n}",
        "start": 2998,
         "end": 3103
       },
    "cppcheck-10": {
        "buggy":"const Token * Variable::declEndToken() const\n{\n    Token const * declEnd = typeStartToken();\n    while (declEnd && !Token::Match(declEnd, \"[;,)={]\")) {\n        if (declEnd->link() && Token::Match(declEnd,\"(|[\"))\n            declEnd = declEnd->link();\n        declEnd = declEnd->next();\n    }\n    return declEnd;\n}",
        "start": 1954,
         "end": 1963
       },
    "cppcheck-11": {
        "buggy":"static bool isContainerSizeChangedByFunction(const Token *tok, int depth = 20)\n{\n    if (!tok->valueType() || !tok->valueType()->container)\n        return false;\n    // If we are accessing an element then we are not changing the container size\n    if (Token::Match(tok, \"%name% . %name% (\")) {\n        Library::Container::Yield yield = tok->valueType()->container->getYield(tok->strAt(2));\n        if (yield != Library::Container::Yield::NO_YIELD)\n            return false;\n    }\n    if (Token::simpleMatch(tok->astParent(), \"[\"))\n        return false;\n\n    // address of variable\n    const bool addressOf = tok->valueType()->pointer || (tok->astParent() && tok->astParent()->isUnaryOp(\"&\"));\n\n    int narg;\n    const Token * ftok = getTokenArgumentFunction(tok, narg);\n    if (!ftok)\n        return false; // not a function => variable not changed\n    const Function * fun = ftok->function();\n    if (fun) {\n        const Variable *arg = fun->getArgumentVar(narg);\n        if (arg) {\n            if (!arg->isReference() && !addressOf)\n                return false;\n            if (!addressOf && arg->isConst())\n                return false;\n            if (arg->valueType() && arg->valueType()->constness == 1)\n                return false;\n            const Scope * scope = fun->functionScope;\n            if (scope) {\n                // Argument not used\n                if (!arg->nameToken())\n                    return false;\n                if (depth > 0)\n                    return isContainerSizeChanged(arg->declarationId(), scope->bodyStart, scope->bodyEnd, depth - 1);\n            }\n            // Don't know => Safe guess\n            return true;\n        }\n    }\n\n    bool inconclusive = false;\n    const bool isChanged = isVariableChangedByFunctionCall(tok, 0, nullptr, &inconclusive);\n    return (isChanged || inconclusive);\n}",
        "start": 5840,
         "end": 5886
       },
    "cppcheck-15": {
        "buggy":"void CheckUnusedVar::checkFunctionVariableUsage()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    // Parse all executing scopes..\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n\n    // only check functions\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        // Bailout when there are lambdas or inline functions\n        // TODO: Handle lambdas and inline functions properly\n        if (scope->hasInlineOrLambdaFunction())\n            continue;\n\n        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (findLambdaEndToken(tok))\n                // todo: handle lambdas\n                break;\n            if (Token::simpleMatch(tok, \"try {\"))\n                // todo: check try blocks\n                tok = tok->linkAt(1);\n            const Token *varDecl = nullptr;\n            if (tok->variable() && tok->variable()->nameToken() == tok) {\n                const Token * eq = tok->next();\n                while (Token::simpleMatch(eq, \"[\"))\n                    eq = eq->link()->next();\n                if (Token::simpleMatch(eq, \"=\")) {\n                    varDecl = tok;\n                    tok = eq;\n                }\n            }\n            // not assignment/initialization/increment => continue\n            const bool isAssignment = tok->isAssignmentOp() && tok->astOperand1();\n            const bool isInitialization = (Token::Match(tok, \"%var% (\") && tok->variable() && tok->variable()->nameToken() == tok);\n            const bool isIncrementOrDecrement = (tok->tokType() == Token::Type::eIncDecOp);\n            if (!isAssignment && !isInitialization && !isIncrementOrDecrement)\n                continue;\n            if (tok->isName()) {\n                if (mTokenizer->isCPP()) {\n                    // do not check RAII/scope_lock objects\n                    if (!tok->valueType())\n                        continue;\n                    bool check = false;\n                    switch (tok->valueType()->type) {\n                    case ValueType::Type::UNKNOWN_TYPE:\n                    case ValueType::Type::NONSTD:\n                    case ValueType::Type::RECORD:\n                        check = tok->valueType()->typeScope && !tok->valueType()->typeScope->getDestructor();\n                        break;\n                    case ValueType::Type::CONTAINER:\n                    case ValueType::Type::ITERATOR:\n                    case ValueType::Type::VOID:\n                    case ValueType::Type::BOOL:\n                    case ValueType::Type::CHAR:\n                    case ValueType::Type::SHORT:\n                    case ValueType::Type::WCHAR_T:\n                    case ValueType::Type::INT:\n                    case ValueType::Type::LONG:\n                    case ValueType::Type::LONGLONG:\n                    case ValueType::Type::UNKNOWN_INT:\n                    case ValueType::Type::FLOAT:\n                    case ValueType::Type::DOUBLE:\n                    case ValueType::Type::LONGDOUBLE:\n                        check = true;\n                        break;\n                    };\n                    if (!check)\n                        continue;\n                }\n                tok = tok->next();\n            }\n            if (tok->astParent() && tok->str() != \"(\") {\n                const Token *parent = tok->astParent();\n                while (Token::Match(parent, \"%oror%|%comp%|!|&&\"))\n                    parent = parent->astParent();\n                if (!parent)\n                    continue;\n                if (!Token::simpleMatch(parent->previous(), \"if (\"))\n                    continue;\n            }\n            // Do not warn about assignment with NULL\n            if (FwdAnalysis::isNullOperand(tok->astOperand2()))\n                continue;\n\n            if (!tok->astOperand1())\n                continue;\n\n            const Token *iteratorToken = tok->astOperand1();\n            while (Token::Match(iteratorToken, \"[.*]\"))\n                iteratorToken = iteratorToken->astOperand1();\n            if (iteratorToken && iteratorToken->variable() && iteratorToken->variable()->typeEndToken()->str().find(\"iterator\") != std::string::npos)\n                continue;\n\n\n            const Variable *op1Var = tok->astOperand1() ? tok->astOperand1()->variable() : nullptr;\n            if (op1Var && op1Var->isReference() && op1Var->nameToken() != tok->astOperand1())\n                // todo: check references\n                continue;\n\n            if (op1Var && op1Var->isStatic())\n                // todo: check static variables\n                continue;\n\n            if (op1Var && op1Var->nameToken()->isAttributeUnused())\n                continue;\n\n            // Is there a redundant assignment?\n            const Token *start = tok->findExpressionStartEndTokens().second->next();\n\n            const Token *expr = varDecl ? varDecl : tok->astOperand1();\n\n            FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);\n            if (fwdAnalysis.unusedValue(expr, start, scope->bodyEnd))\n                // warn\n                unreadVariableError(tok, expr->expressionString(), false);\n        }\n\n        // varId, usage {read, write, modified}\n        Variables variables;\n\n        checkFunctionVariableUsage_iterateScopes(scope, variables);\n\n\n        // Check usage of all variables in the current scope..\n        for (std::map<unsigned int, Variables::VariableUsage>::const_iterator it = variables.varUsage().begin();\n             it != variables.varUsage().end();\n             ++it) {\n            const Variables::VariableUsage &usage = it->second;\n\n            // variable has been marked as unused so ignore it\n            if (usage._var->nameToken()->isAttributeUnused() || usage._var->nameToken()->isAttributeUsed())\n                continue;\n\n            // skip things that are only partially implemented to prevent false positives\n            if (usage.mType == Variables::pointerPointer ||\n                usage.mType == Variables::pointerArray ||\n                usage.mType == Variables::referenceArray)\n                continue;\n\n            const std::string &varname = usage._var->name();\n            const Variable* var = symbolDatabase->getVariableFromVarId(it->first);\n\n            // variable has had memory allocated for it, but hasn't done\n            // anything with that memory other than, perhaps, freeing it\n            if (usage.unused() && !usage._modified && usage._allocateMemory)\n                allocatedButUnusedVariableError(usage._lastAccess, varname);\n\n            // variable has not been written, read, or modified\n            else if (usage.unused() && !usage._modified)\n                unusedVariableError(usage._var->nameToken(), varname);\n\n            // variable has not been written but has been modified\n            else if (usage._modified && !usage._write && !usage._allocateMemory && var && !var->isStlType())\n                unassignedVariableError(usage._var->nameToken(), varname);\n\n            // variable has been read but not written\n            else if (!usage._write && !usage._allocateMemory && var && !var->isStlType() && !isEmptyType(var->type()))\n                unassignedVariableError(usage._var->nameToken(), varname);\n        }\n    }\n}",
        "start": 1089,
         "end": 1250
       },
    "cppcheck-19": {
        "buggy":"static bool isDeadTemporary(bool cpp, const Token* tok, const Token* expr, const Library* library)\n{\n    if (!isTemporary(cpp, tok, library))\n        return false;\n    if (expr && !precedes(nextAfterAstRightmostLeaf(tok->astTop()), nextAfterAstRightmostLeaf(expr->astTop())))\n        return false;\n    return true;\n}",
        "start": 444,
         "end": 451
       },
    "cppcheck-21": {
        "buggy":"const ::Type * clangimport::AstNode::addTypeTokens(TokenList *tokenList, const std::string &str, const Scope *scope)\n{\n    if (str.find(\"\\':\\'\") != std::string::npos) {\n        return addTypeTokens(tokenList, str.substr(0, str.find(\"\\':\\'\") + 1), scope);\n    }\n\n\n    std::string type;\n    if (str.find(\" (\") != std::string::npos) {\n        if (str.find(\"<\") != std::string::npos)\n            type = str.substr(1, str.find(\"<\")) + \"...>\";\n        else\n            type = str.substr(1,str.find(\" (\")-1);\n    } else\n        type = unquote(str);\n\n    for (const std::string &s: splitString(type))\n        addtoken(tokenList, s, false);\n\n    // Set Type\n    if (!scope) {\n        scope = tokenList->back() ? tokenList->back()->scope() : nullptr;\n        if (!scope)\n            return nullptr;\n    }\n    for (const Token *typeToken = tokenList->back(); Token::Match(typeToken, \"&|*|%name%\"); typeToken = typeToken->previous()) {\n        if (!typeToken->isName())\n            continue;\n        const ::Type *recordType = scope->check->findVariableType(scope, typeToken);\n        if (recordType) {\n            const_cast<Token*>(typeToken)->type(recordType);\n            return recordType;\n        }\n    }\n    return nullptr;\n}",
        "start": 494,
         "end": 529
       },
    "cppcheck-22": {
        "buggy":"const Token* CheckUninitVar::isVariableUsage(const Token *vartok, bool pointer, Alloc alloc, int indirect) const\n{\n    const Token *valueExpr = vartok;   // non-dereferenced , no address of value as variable\n    while (Token::Match(valueExpr->astParent(), \".|::\") && astIsRhs(valueExpr))\n        valueExpr = valueExpr->astParent();\n    if (!pointer) {\n        if (Token::Match(vartok, \"%name% [.(]\") && vartok->variable() && !vartok->variable()->isPointer())\n            return nullptr;\n        while (Token::simpleMatch(valueExpr->astParent(), \".\") && astIsLhs(valueExpr) && valueExpr->astParent()->valueType() && valueExpr->astParent()->valueType()->pointer == 0)\n            valueExpr = valueExpr->astParent();\n    }\n    const Token *derefValue = nullptr; // dereferenced value expression\n    if (alloc != NO_ALLOC) {\n        const int arrayDim = (vartok->variable() && vartok->variable()->isArray()) ? vartok->variable()->dimensions().size() : 1;\n        int deref = 0;\n        derefValue = valueExpr;\n        while (Token::Match(derefValue->astParent(), \"+|-|*|[|.\") || (derefValue->astParent() && derefValue->astParent()->isCast())) {\n            if (derefValue->astParent()->isUnaryOp(\"*\"))\n                ++deref;\n            else if (derefValue->astParent()->str() == \"[\") {\n                if (astIsLhs(derefValue))\n                    ++deref;\n                else\n                    break;\n            } else if (derefValue->astParent()->str() == \".\")\n                ++deref;\n            derefValue = derefValue->astParent();\n            if (deref < arrayDim)\n                valueExpr = derefValue;\n        }\n        if (deref < arrayDim) {\n            // todo compare deref with array dimensions\n            derefValue = nullptr;\n        }\n    } else if (vartok->astParent() && vartok->astParent()->isUnaryOp(\"&\")) {\n        const Token *child = vartok->astParent();\n        const Token *parent = child->astParent();\n        while (parent && (parent->isCast() || parent->str() == \"+\")) {\n            child = parent;\n            parent = child->astParent();\n        }\n        if (parent && (parent->isUnaryOp(\"*\") || (parent->str() == \"[\" && astIsLhs(child))))\n            derefValue = parent;\n    }\n\n    if (!valueExpr->astParent())\n        return nullptr;\n\n    // FIXME handle address of!!\n    if (valueExpr->astParent()->isUnaryOp(\"&\"))\n        return nullptr;\n    if (derefValue && derefValue->astParent() && derefValue->astParent()->isUnaryOp(\"&\"))\n        return nullptr;\n\n    // BAILOUT for binary &\n    if (Token::simpleMatch(valueExpr->astParent(), \"&\") && astIsRhs(valueExpr) && Token::Match(valueExpr->astParent()->tokAt(-3), \"( %name% ) &\"))\n        return nullptr;\n\n    // safe operations\n    if (isVoidCast(valueExpr->astParent()))\n        return nullptr;\n    if (Token::simpleMatch(valueExpr->astParent(), \".\")) {\n        const Token *parent = valueExpr->astParent();\n        while (Token::simpleMatch(parent, \".\"))\n            parent = parent->astParent();\n        if (isVoidCast(parent))\n            return nullptr;\n    }\n    if (alloc != NO_ALLOC) {\n        if (Token::Match(valueExpr->astParent(), \"%comp%|%oror%|&&|?|!\"))\n            return nullptr;\n        if (Token::Match(valueExpr->astParent(), \"%or%|&\") && valueExpr->astParent()->isBinaryOp())\n            return nullptr;\n        if (alloc == CTOR_CALL && derefValue && Token::simpleMatch(derefValue->astParent(), \"(\") && astIsLhs(derefValue))\n            return nullptr;\n    }\n\n    // Passing variable to function..\n    if (Token::Match(valueExpr->astParent(), \"[(,]\") && (valueExpr->astParent()->str() == \",\" || astIsRhs(valueExpr))) {\n        const Token *parent = valueExpr->astParent();\n        while (Token::simpleMatch(parent, \",\"))\n            parent = parent->astParent();\n        if (Token::simpleMatch(parent, \"{\"))\n            return valueExpr;\n        const int use = isFunctionParUsage(valueExpr, pointer, alloc, indirect);\n        return (use>0) ? valueExpr : nullptr;\n    }\n    if (derefValue && Token::Match(derefValue->astParent(), \"[(,]\") && (derefValue->astParent()->str() == \",\" || astIsRhs(derefValue))) {\n        const int use = isFunctionParUsage(derefValue, false, NO_ALLOC, indirect);\n        return (use>0) ? derefValue : nullptr;\n    }\n\n\n    // Assignments;\n    // * Is this LHS in assignment\n    // * Passing address in RHS to pointer variable\n    {\n        const Token *tok = derefValue ? derefValue : valueExpr;\n        if (Token::simpleMatch(tok->astParent(), \"=\")) {\n            if (astIsLhs(tok))\n                return nullptr;\n            if (alloc != NO_ALLOC && astIsRhs(valueExpr))\n                return nullptr;\n        }\n    }\n\n    // Initialize reference variable\n    if (Token::Match((derefValue ? derefValue : vartok)->astParent(), \"(|=\") && astIsRhs(derefValue ? derefValue : vartok)) {\n        const Token *rhstok = derefValue ? derefValue : vartok;\n        const Token *lhstok = rhstok->astParent()->astOperand1();\n        const Variable *lhsvar = lhstok->variable();\n        if (lhsvar && lhsvar->isReference() && lhsvar->nameToken() == lhstok)\n            return nullptr;\n    }\n\n    // LHS in range for loop:\n    if (Token::simpleMatch(valueExpr->astParent(), \":\") &&\n        astIsLhs(valueExpr) &&\n        valueExpr->astParent()->astParent() &&\n        Token::simpleMatch(valueExpr->astParent()->astParent()->previous(), \"for (\"))\n        return nullptr;\n\n    // Stream read/write\n    // FIXME this code is a hack!!\n    if (mTokenizer->isCPP() && Token::Match(valueExpr->astParent(), \"<<|>>\")) {\n        if (isLikelyStreamRead(mTokenizer->isCPP(), vartok->previous()))\n            return nullptr;\n\n        if (valueExpr->valueType() && valueExpr->valueType()->type == ValueType::Type::VOID)\n            return nullptr;\n\n        // overloaded << operator to initialize variable?\n        if (Token::simpleMatch(valueExpr->astParent(), \"<<\") && !valueExpr->astParent()->astParent()) {\n            if (astIsLhs(valueExpr))\n                return nullptr;\n            const Token *lhs = valueExpr->astParent()->astOperand1();\n            if (Token::simpleMatch(lhs, \"<<\"))\n                return valueExpr;\n            if (Token::simpleMatch(lhs->previous(), \"std ::\"))\n                return valueExpr;\n            const Variable *var = lhs->variable();\n            if (var && (var->typeStartToken()->isStandardType() || var->typeStartToken()->isEnumType() || Token::simpleMatch(var->typeStartToken(), \"std ::\")))\n                return valueExpr;\n            return nullptr;\n        }\n    }\n\n    if (mTokenizer->isCPP() && Token::simpleMatch(valueExpr->astParent(), \"&\") && !valueExpr->astParent()->astParent() && astIsRhs(valueExpr) && Token::Match(valueExpr->astSibling(), \"%type%\"))\n        return nullptr;\n\n    return derefValue ? derefValue : valueExpr;\n}",
        "start": 1020,
         "end": 1171
       },
    "cppcheck-25": {
        "buggy":"static bool isLifetimeBorrowed(const ValueType *vt, const ValueType *vtParent)\n{\n    if (!vtParent)\n        return false;\n    if (!vt)\n        return false;\n    if (vt->type != ValueType::UNKNOWN_TYPE && vtParent->type != ValueType::UNKNOWN_TYPE) {\n        if (vtParent->pointer > vt->pointer)\n            return true;\n        if (vtParent->pointer < vt->pointer && vtParent->isIntegral())\n            return true;\n        if (vtParent->str() == vt->str())\n            return true;\n        if (vtParent->pointer == vt->pointer && vtParent->type == vt->type && vtParent->isIntegral())\n            // sign conversion\n            return true;\n    }\n\n    return false;\n}",
        "start": 3065,
         "end": 3084
       },
    "cppcheck-28": {
        "buggy":"void CheckAutoVariables::checkVarLifetimeScope(const Token * start, const Token * end)\n{\n    const bool printInconclusive = (mSettings->inconclusive);\n    if (!start)\n        return;\n    const Scope * scope = start->scope();\n    if (!scope)\n        return;\n    // If the scope is not set correctly then skip checking it\n    if (scope->bodyStart != start)\n        return;\n    bool returnRef = Function::returnsReference(scope->function);\n    for (const Token *tok = start; tok && tok != end; tok = tok->next()) {\n        // Return reference from function\n        if (returnRef && Token::simpleMatch(tok->astParent(), \"return\")) {\n            for (const LifetimeToken& lt : getLifetimeTokens(tok, true)) {\n                if (!printInconclusive && lt.inconclusive)\n                    continue;\n                const Variable* var = lt.token->variable();\n                if (var && !var->isGlobal() && !var->isStatic() && !var->isReference() && !var->isRValueReference() &&\n                    isInScope(var->nameToken(), tok->scope())) {\n                    errorReturnReference(tok, lt.errorPath, lt.inconclusive);\n                    break;\n                } else if (isDeadTemporary(mTokenizer->isCPP(), lt.token, nullptr, &mSettings->library)) {\n                    errorReturnTempReference(tok, lt.errorPath, lt.inconclusive);\n                    break;\n                }\n            }\n            // Assign reference to non-local variable\n        } else if (Token::Match(tok->previous(), \"&|&& %var% =\") && tok->astParent() == tok->next() &&\n                   tok->variable() && tok->variable()->nameToken() == tok &&\n                   tok->variable()->declarationId() == tok->varId() && tok->variable()->isStatic() &&\n                   !tok->variable()->isArgument()) {\n            ErrorPath errorPath;\n            const Variable *var = getLifetimeVariable(tok, errorPath);\n            if (var && isInScope(var->nameToken(), tok->scope())) {\n                errorDanglingReference(tok, var, errorPath);\n                continue;\n            }\n            // Reference to temporary\n        } else if (tok->variable() && (tok->variable()->isReference() || tok->variable()->isRValueReference())) {\n            for (const LifetimeToken& lt : getLifetimeTokens(getParentLifetime(tok))) {\n                if (!printInconclusive && lt.inconclusive)\n                    continue;\n                const Token * tokvalue = lt.token;\n                if (isDeadTemporary(mTokenizer->isCPP(), tokvalue, tok, &mSettings->library)) {\n                    errorDanglingTempReference(tok, lt.errorPath, lt.inconclusive);\n                    break;\n                }\n            }\n\n        }\n        for (const ValueFlow::Value& val:tok->values()) {\n            if (!val.isLocalLifetimeValue() && !val.isSubFunctionLifetimeValue())\n                continue;\n            if (!printInconclusive && val.isInconclusive())\n                continue;\n            const bool escape = Token::Match(tok->astParent(), \"return|throw\");\n            for (const LifetimeToken& lt : getLifetimeTokens(getParentLifetime(val.tokvalue), escape)) {\n                const Token * tokvalue = lt.token;\n                if (val.isLocalLifetimeValue()) {\n                    if (escape) {\n                        if (getPointerDepth(tok) < getPointerDepth(tokvalue))\n                            continue;\n                        if (!isLifetimeBorrowed(tok, mSettings))\n                            continue;\n                        if ((tokvalue->variable() && !isEscapedReference(tokvalue->variable()) &&\n                             isInScope(tokvalue->variable()->nameToken(), scope)) ||\n                            isDeadTemporary(mTokenizer->isCPP(), tokvalue, tok, &mSettings->library)) {\n                            errorReturnDanglingLifetime(tok, &val);\n                            break;\n                        }\n                    } else if (tokvalue->variable() && isDeadScope(tokvalue->variable()->nameToken(), tok->scope())) {\n                        errorInvalidLifetime(tok, &val);\n                        break;\n                    } else if (!tokvalue->variable() &&\n                               isDeadTemporary(mTokenizer->isCPP(), tokvalue, tok, &mSettings->library)) {\n                        errorDanglingTemporaryLifetime(tok, &val);\n                        break;\n                    }\n                }\n                if (tokvalue->variable() && (isInScope(tokvalue->variable()->nameToken(), tok->scope()) ||\n                                             (val.isSubFunctionLifetimeValue() && isDanglingSubFunction(tokvalue, tok)))) {\n                    const Variable * var = nullptr;\n                    const Token * tok2 = tok;\n                    if (Token::simpleMatch(tok->astParent(), \"=\")) {\n                        if (tok->astParent()->astOperand2() == tok) {\n                            var = getLHSVariable(tok->astParent());\n                            tok2 = tok->astParent()->astOperand1();\n                        }\n                    } else if (tok->variable() && tok->variable()->declarationId() == tok->varId()) {\n                        var = tok->variable();\n                    }\n                    if (!isLifetimeBorrowed(tok, mSettings))\n                        continue;\n                    if (var && !var->isLocal() && !var->isArgument() && !isVariableChanged(tok->next(), tok->scope()->bodyEnd, var->declarationId(), var->isGlobal(), mSettings, mTokenizer->isCPP())) {\n                        errorDanglngLifetime(tok2, &val);\n                        break;\n                    }\n                }\n            }\n        }\n        const Token *lambdaEndToken = findLambdaEndToken(tok);\n        if (lambdaEndToken) {\n            checkVarLifetimeScope(lambdaEndToken->link(), lambdaEndToken);\n            tok = lambdaEndToken;\n        }\n        if (tok->str() == \"{\" && tok->scope()) {\n            // Check functions in local classes\n            if (tok->scope()->type == Scope::eClass ||\n                tok->scope()->type == Scope::eStruct ||\n                tok->scope()->type == Scope::eUnion) {\n                for (const Function& f:tok->scope()->functionList) {\n                    if (f.functionScope)\n                        checkVarLifetimeScope(f.functionScope->bodyStart, f.functionScope->bodyEnd);\n                }\n                tok = tok->link();\n            }\n        }\n    }\n}",
        "start": 530,
         "end": 650
       },
    "cppcheck-29": {
        "buggy":"void Tokenizer::simplifyOperatorName()\n{\n    if (isC())\n        return;\n\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (Token::Match(tok, \"using|:: operator %op% ;\")) {\n            tok->next()->str(\"operator\" + tok->strAt(2));\n            tok->next()->deleteNext();\n            continue;\n        }\n\n        if (tok->str() != \"operator\")\n            continue;\n        // operator op\n        std::string op;\n        Token *par = tok->next();\n        bool done = false;\n        while (!done && par) {\n            done = true;\n            if (par->isName()) {\n                op += par->str();\n                par = par->next();\n                // merge namespaces eg. 'operator std :: string () const {'\n                if (Token::Match(par, \":: %name%|%op%|.\")) {\n                    op += par->str();\n                    par = par->next();\n                }\n                done = false;\n            } else if (Token::Match(par, \".|%op%|,\")) {\n                // check for operator in template\n                if (!(Token::Match(par, \"<|>\") && !op.empty())) {\n                    op += par->str();\n                    par = par->next();\n                    done = false;\n                }\n            } else if (Token::simpleMatch(par, \"[ ]\")) {\n                op += \"[]\";\n                par = par->tokAt(2);\n                done = false;\n            } else if (Token::Match(par, \"( *| )\")) {\n                // break out and simplify..\n                if (operatorEnd(par->next()))\n                    break;\n\n                while (par->str() != \")\") {\n                    op += par->str();\n                    par = par->next();\n                }\n                op += \")\";\n                par = par->next();\n                done = false;\n            } else if (Token::Match(par, \"\\\"\\\" %name% (\")) {\n                op += \"\\\"\\\"\";\n                op += par->strAt(1);\n                par = par->tokAt(2);\n                done = true;\n            }\n        }\n\n        if (par && (Token::Match(par, \"<|>\") || isFunctionHead(par, \"{|;\"))) {\n            tok->str(\"operator\" + op);\n            Token::eraseTokens(tok, par);\n        }\n\n        if (!op.empty())\n            tok->isOperatorKeyword(true);\n    }\n\n    if (mSettings->debugwarnings) {\n        const Token *tok = list.front();\n\n        while ((tok = Token::findsimplematch(tok, \"operator\")) != nullptr) {\n            reportError(tok, Severity::debug, \"debug\",\n                        \"simplifyOperatorName: found unsimplified operator name\");\n            tok = tok->next();\n        }\n    }\n}",
        "start": 10836,
         "end": 10914
       },
    "cppcheck-30": {
        "buggy":"bool isVariableChanged(const Token *tok, int indirect, const Settings *settings, bool cpp, int depth)\n{\n    if (!tok)\n        return false;\n    const Token *tok2 = tok;\n    while (Token::simpleMatch(tok2->astParent(), \"*\") || (Token::simpleMatch(tok2->astParent(), \".\") && !Token::simpleMatch(tok2->astParent()->astParent(), \"(\")) ||\n           (Token::simpleMatch(tok2->astParent(), \"[\") && tok2 == tok2->astParent()->astOperand1()))\n        tok2 = tok2->astParent();\n\n    while (Token::simpleMatch(tok2->astParent(), \"?\") || (Token::simpleMatch(tok2->astParent(), \":\") && Token::simpleMatch(tok2->astParent()->astParent(), \"?\")))\n        tok2 = tok2->astParent();\n\n    if (Token::Match(tok2->astParent(), \"++|--\"))\n        return true;\n\n    if (tok2->astParent() && tok2->astParent()->isAssignmentOp()) {\n        if (tok2 == tok2->astParent()->astOperand1())\n            return true;\n        // Check if assigning to a non-const lvalue\n        const Variable * var = getLHSVariable(tok2->astParent());\n        if (var && var->isReference() && !var->isConst() && var->nameToken() && var->nameToken()->next() == tok2->astParent()) {\n            if (!var->isLocal() || isVariableChanged(var, settings, cpp, depth - 1))\n                return true;\n        }\n    }\n\n    if (isLikelyStreamRead(cpp, tok->previous()))\n        return true;\n\n    if (isLikelyStream(cpp, tok2))\n        return true;\n\n    // Member function call\n    if (tok->variable() && Token::Match(tok2->astParent(), \". %name%\") && isFunctionCall(tok2->astParent()->next()) && tok2->astParent()->astOperand1() == tok2) {\n        const Variable * var = tok->variable();\n        bool isConst = var && var->isConst();\n        if (!isConst) {\n            const ValueType * valueType = var->valueType();\n            isConst = (valueType && valueType->pointer == 1 && valueType->constness == 1);\n        }\n\n        const Token *ftok = tok->tokAt(2);\n        const Function * fun = ftok->function();\n        if (!isConst && (!fun || !fun->isConst()))\n            return true;\n        else\n            return false;\n    }\n\n    const Token *ftok = tok2;\n    while (ftok && (!Token::Match(ftok, \"[({]\") || ftok->isCast()))\n        ftok = ftok->astParent();\n\n    if (ftok && Token::Match(ftok->link(), \")|} !!{\")) {\n        const Token * ptok = tok2;\n        while (Token::Match(ptok->astParent(), \".|::|[\"))\n            ptok = ptok->astParent();\n        bool inconclusive = false;\n        bool isChanged = isVariableChangedByFunctionCall(ptok, indirect, settings, &inconclusive);\n        isChanged |= inconclusive;\n        if (isChanged)\n            return true;\n    }\n\n    const Token *parent = tok2->astParent();\n    while (Token::Match(parent, \".|::\"))\n        parent = parent->astParent();\n    if (parent && parent->tokType() == Token::eIncDecOp)\n        return true;\n\n    if (Token::simpleMatch(tok2->astParent(), \":\") && tok2->astParent()->astParent() && Token::simpleMatch(tok2->astParent()->astParent()->previous(), \"for (\")) {\n        const Token * varTok = tok2->astParent()->previous();\n        if (!varTok)\n            return false;\n        const Variable * loopVar = varTok->variable();\n        if (!loopVar)\n            return false;\n        if (!loopVar->isConst() && loopVar->isReference() && isVariableChanged(loopVar, settings, cpp, depth - 1))\n            return true;\n        return false;\n    }\n    return false;\n}",
        "start": 1330,
         "end": 1412
       },
    "dlt_daemon-1": {
        "buggy":"DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    char str1[DLT_COMMON_BUFFER_LENGTH];\n    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"r\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    /* Reset filters */\n    filter->counter = 0;\n\n    while (!feof(handle)) {\n        str1[0] = 0;\n\n        if (fscanf(handle, \"%s\", str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(apid, \"\");\n        else\n            dlt_set_id(apid, str1);\n\n        str1[0] = 0;\n\n        if (fscanf(handle, \"%254s\", str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\\r\\n\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(ctid, \"\");\n        else\n            dlt_set_id(ctid, str1);\n\n        if (filter->counter < DLT_FILTER_MAX) {\n            dlt_filter_add(filter, apid, ctid, verbose);\n        }\n        else {\n            dlt_vlog(LOG_WARNING,\n                     \"Maximum number (%d) of allowed filters reached, ignoring rest of filters!\\n\",\n                     DLT_FILTER_MAX);\n        }\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}",
        "start": 383,
         "end": 448
       },
    "example-1": {
        "buggy":"int func1(int x) {\n    int y = 100;\n    y = x;\n    if (x >= 100) {\n        return -y;\n    }\n    return y;\n}",
        "start": 1,
         "end": 8
       },
    "exiv2-2": {
        "buggy":"    DataBuf packIfdId(const ExifData& exifData,\n                            IfdId     ifdId,\n                            ByteOrder byteOrder)\n    {\n        const uint16_t size = 1024;\n        DataBuf buf(size);\n        std::memset(buf.pData_, 0x0, buf.size_);\n\n        uint16_t len = 0;\n        const ExifData::const_iterator b = exifData.begin();\n        const ExifData::const_iterator e = exifData.end();\n        for (ExifData::const_iterator i = b; i != e; ++i) {\n            if (i->ifdId() != ifdId) continue;\n            const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size());\n            assert(s <= size);\n            if (len < s) len = s;\n            i->copy(buf.pData_ + i->tag()*2, byteOrder);\n            \n        }\n        // Round the size to make it even.\n        buf.size_ = len + len%2;\n        return buf;\n    }\n",
        "start": 1243,
         "end": 1265
       },
    "exiv2-3": {
        "buggy":" void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox = *pSubBox ;\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata);\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    } // Jp2Image::encodeJp2Header",
        "start": 646,
         "end": 721
       },
    "exiv2-4": {
        "buggy":"    std::ostream& Nikon1MakerNote::print0x0088(std::ostream& os,\n                                               const Value& value,\n                                               const ExifData*)\n    {\n        if (value.count() >= 1) {\n            unsigned long focusArea = value.toLong(0);\n            os << nikonFocusarea[focusArea];\n        }\n        if (value.count() >= 2) {\n            os << \"; \";\n            unsigned long focusPoint = value.toLong(1);\n\n            switch (focusPoint) {\n            // Could use array nikonFokuspoints\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n                os << nikonFocuspoints[focusPoint];\n                break;\n            default:\n                os << value;\n                if (focusPoint < sizeof(nikonFocuspoints)/sizeof(nikonFocuspoints[0]))\n                    os << \" \" << _(\"guess\") << \" \" << nikonFocuspoints[focusPoint];\n                break;\n            }\n        }\n        if (value.count() >= 3) {\n            unsigned long focusPointsUsed1 = value.toLong(2);\n            unsigned long focusPointsUsed2 = value.toLong(3);\n\n            if (focusPointsUsed1 != 0 && focusPointsUsed2 != 0)\n            {\n                os << \"; [\";\n\n                if (focusPointsUsed1 & 1)\n                    os << nikonFocuspoints[0] << \" \";\n                if (focusPointsUsed1 & 2)\n                    os << nikonFocuspoints[1] << \" \";\n                if (focusPointsUsed1 & 4)\n                    os << nikonFocuspoints[2] << \" \";\n                if (focusPointsUsed1 & 8)\n                    os << nikonFocuspoints[3] << \" \";\n                if (focusPointsUsed1 & 16)\n                    os << nikonFocuspoints[4] << \" \";\n                if (focusPointsUsed1 & 32)\n                    os << nikonFocuspoints[5] << \" \";\n                if (focusPointsUsed1 & 64)\n                    os << nikonFocuspoints[6] << \" \";\n                if (focusPointsUsed1 & 128)\n                    os << nikonFocuspoints[7] << \" \";\n\n                if (focusPointsUsed2 & 1)\n                    os << nikonFocuspoints[8] << \" \";\n                if (focusPointsUsed2 & 2)\n                    os << nikonFocuspoints[9] << \" \";\n                if (focusPointsUsed2 & 4)\n                    os << nikonFocuspoints[10] << \" \";\n\n                os << \"]\";\n            }\n        }\n        else {\n            os << \"(\" << value << \")\";\n        }\n        return os;\n    }",
        "start": 368,
         "end": 435
       },
    "exiv2-8": {
        "buggy":"void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType << \" length: \" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n\n                    profileName_ = std::string(reinterpret_cast<char *>(chunkData.pData_), iccOffset-1);\n                    ++iccOffset; // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }  // PngImage::readMetadata",
        "start": 414,
         "end": 504
       },
    "exiv2-10": {
        "buggy":" void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    } // PsdImage::readMetadata",
        "start": 142,
         "end": 239
       },
    "exiv2-13": {
        "buggy":"void Jp2Image::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        bool bRecursive = option == kpsRecursive;\n        bool bICC = option == kpsIccProfile;\n        bool bXMP = option == kpsXMP;\n        bool bIPTCErase = option == kpsIptcErase;\n\n        if (bPrint) {\n            out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;\n            out << \" address |   length | box       | data\" << std::endl;\n        }\n\n        if (bPrint || bXMP || bICC || bIPTCErase) {\n            Jp2BoxHeader box = {1, 1};\n            Jp2BoxHeader subBox = {1, 1};\n            Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\n            bool bLF = false;\n\n            while (box.length && box.type != kJp2BoxTypeClose && io_->read((byte*)&box, sizeof(box)) == sizeof(box)) {\n                long position = io_->tell();\n                box.length = getLong((byte*)&box.length, bigEndian);\n                box.type = getLong((byte*)&box.type, bigEndian);\n\n                if (bPrint) {\n                    out << Internal::stringFormat(\"%8ld | %8ld | \", (size_t)(position - sizeof(box)),\n                                                  (size_t)box.length)\n                        << toAscii(box.type) << \"      | \";\n                    bLF = true;\n                    if (box.type == kJp2BoxTypeClose)\n                        lf(out, bLF);\n                }\n                if (box.type == kJp2BoxTypeClose)\n                    break;\n\n                switch (box.type) {\n                    case kJp2BoxTypeJp2Header: {\n                        lf(out, bLF);\n\n                        while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) &&\n                               io_->tell() < position + (long)box.length)  // don't read beyond the box!\n                        {\n                            int address = io_->tell() - sizeof(subBox);\n                            subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                            subBox.type = getLong((byte*)&subBox.type, bigEndian);\n\n                            if (subBox.length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n\n                            DataBuf data(subBox.length - sizeof(box));\n                            io_->read(data.pData_, data.size_);\n                            if (bPrint) {\n                                out << Internal::stringFormat(\"%8ld | %8ld |  sub:\", (size_t)address,\n                                                              (size_t)subBox.length)\n                                    << toAscii(subBox.type) << \" | \"\n                                    << Internal::binaryToString(makeSlice(data, 0, 30));\n                                bLF = true;\n                            }\n\n                            if (subBox.type == kJp2BoxTypeColorHeader) {\n                                long pad = 3;  // don't know why there are 3 padding bytes\n                                if (bPrint) {\n                                    out << \" | pad:\";\n                                    for (int i = 0; i < 3; i++)\n                                        out << \" \" << (int)data.pData_[i];\n                                }\n                                long iccLength = getULong(data.pData_ + pad, bigEndian);\n                                if (bPrint) {\n                                    out << \" | iccLength:\" << iccLength;\n                                }\n                                if (bICC) {\n                                    out.write((const char*)data.pData_ + pad, iccLength);\n                                }\n                            }\n                            lf(out, bLF);\n                        }\n                    } break;\n\n                    case kJp2BoxTypeUuid: {\n                        if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid)) {\n                            bool bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid)) == 0;\n                            bool bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid)) == 0;\n                            bool bIsXMP = memcmp(uuid.uuid, kJp2UuidXmp, sizeof(uuid)) == 0;\n\n                            bool bUnknown = !(bIsExif || bIsIPTC || bIsXMP);\n\n                            if (bPrint) {\n                                if (bIsExif)\n                                    out << \"Exif: \";\n                                if (bIsIPTC)\n                                    out << \"IPTC: \";\n                                if (bIsXMP)\n                                    out << \"XMP : \";\n                                if (bUnknown)\n                                    out << \"????: \";\n                            }\n\n                            DataBuf rawData;\n                            rawData.alloc(box.length - sizeof(uuid) - sizeof(box));\n                            long bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error())\n                                throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_)\n                                throw Error(kerInputDataReadFailed);\n\n                            if (bPrint) {\n                                out << Internal::binaryToString(makeSlice(rawData, 0, 40));\n                                out.flush();\n                            }\n                            lf(out, bLF);\n\n                            if (bIsExif && bRecursive && rawData.size_ > 0) {\n                                if ((rawData.pData_[0] == rawData.pData_[1]) &&\n                                    (rawData.pData_[0] == 'I' || rawData.pData_[0] == 'M')) {\n                                    BasicIo::UniquePtr p = BasicIo::UniquePtr(new MemIo(rawData.pData_, rawData.size_));\n                                    printTiffStructure(*p, out, option, depth);\n                                }\n                            }\n\n                            if (bIsIPTC && bRecursive) {\n                                IptcData::printStructure(out, makeSlice(rawData.pData_, 0, rawData.size_), depth);\n                            }\n\n                            if (bIsXMP && bXMP) {\n                                out.write((const char*)rawData.pData_, rawData.size_);\n                            }\n                        }\n                    } break;\n\n                    default:\n                        break;\n                }\n\n                // Move to the next box.\n                io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n                if (io_->error())\n                    throw Error(kerFailedToReadImageData);\n                if (bPrint)\n                    lf(out, bLF);\n            }\n        }\n    }  // JpegBase::printStructure",
        "start": 448,
         "end": 600
       },
    "exiv2-14": {
        "buggy":"void TiffParserWorker::findPrimaryGroups(PrimaryGroups& primaryGroups, TiffComponent* pSourceDir)\n    {\n        if (0 == pSourceDir)\n            return;\n\n        const IfdId imageGroups[] = {\n            ifd0Id,\n            ifd1Id,\n            ifd2Id,\n            ifd3Id,\n            subImage1Id,\n            subImage2Id,\n            subImage3Id,\n            subImage4Id,\n            subImage5Id,\n            subImage6Id,\n            subImage7Id,\n            subImage8Id,\n            subImage9Id\n        };\n\n        for (unsigned int i = 0; i < EXV_COUNTOF(imageGroups); ++i) {\n            TiffFinder finder(0x00fe, imageGroups[i]);\n            pSourceDir->accept(finder);\n            TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n            if (   te\n                && te->pValue()->typeId() == unsignedLong\n                && te->pValue()->count() == 1\n                && (te->pValue()->toLong() & 1) == 0) {\n                primaryGroups.push_back(te->group());\n            }\n        }\n\n    } // TiffParserWorker::findPrimaryGroups",
        "start": 1673,
         "end": 1706
       },   
    "exiv2-15": {
        "buggy":"ExifData::const_iterator isoSpeed(const ExifData& ed)\n    {\n        static const char* keys[] = {\n            \"Exif.Photo.ISOSpeedRatings\",\n            \"Exif.Image.ISOSpeedRatings\",\n            \"Exif.CanonSi.ISOSpeed\",\n            \"Exif.CanonCs.ISOSpeed\",\n            \"Exif.Nikon1.ISOSpeed\",\n            \"Exif.Nikon2.ISOSpeed\",\n            \"Exif.Nikon3.ISOSpeed\",\n            \"Exif.NikonIi.ISO\",\n            \"Exif.NikonIi.ISO2\",\n            \"Exif.MinoltaCsNew.ISOSetting\",\n            \"Exif.MinoltaCsOld.ISOSetting\",\n            \"Exif.MinoltaCs5D.ISOSpeed\",\n            \"Exif.MinoltaCs7D.ISOSpeed\",\n            \"Exif.Sony1Cs.ISOSetting\",\n            \"Exif.Sony2Cs.ISOSetting\",\n            \"Exif.Sony1Cs2.ISOSetting\",\n            \"Exif.Sony2Cs2.ISOSetting\",\n            \"Exif.Sony1MltCsA100.ISOSetting\",\n            \"Exif.Pentax.ISO\",\n            \"Exif.PentaxDng.ISO\",\n            \"Exif.Olympus.ISOSpeed\",\n            \"Exif.Samsung2.ISO\",\n            \"Exif.Casio.ISO\",\n            \"Exif.Casio2.ISO\",\n            \"Exif.Casio2.ISOSpeed\"\n        };\n\n        struct SensKeyNameList {\n            int count;\n            const char* keys[3];\n        };\n\n        // covers Exif.Phot.SensitivityType values 1-7. Note that SOS, REI and\n        // ISO do differ in their meaning. Values coming first in a list (and\n        // existing as a tag) are picked up first and used as the \"ISO\" value.\n        static const SensKeyNameList sensitivityKey[] = {\n            { 1, { \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 1, { \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 1, { \"Exif.Photo.ISOSpeed\" }},\n            { 2, { \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 3, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }}\n        };\n\n        static const char* sensitivityType[] = {\n            \"Exif.Photo.SensitivityType\"\n        };\n\n        // Find the first ISO value which is not \"0\"\n        const int cnt = EXV_COUNTOF(keys);\n        ExifData::const_iterator md = ed.end();\n        long iso_val = -1;\n        for (int idx = 0; idx < cnt; ) {\n            md = findMetadatum(ed, keys + idx, cnt - idx);\n            if (md == ed.end()) break;\n            std::ostringstream os;\n            md->write(os, &ed);\n            bool ok = false;\n            iso_val = parseLong(os.str(), ok);\n            if (ok && iso_val > 0) break;\n            while (strcmp(keys[idx++], md->key().c_str()) != 0 && idx < cnt) {}\n            md = ed.end();\n        }\n\n        // there is either a possible ISO \"overflow\" or no legacy\n        // ISO tag at all. Check for SensitivityType tag and the referenced\n        // ISO value (see EXIF 2.3 Annex G)\n        long iso_tmp_val = -1;\n        while (iso_tmp_val == -1 && (iso_val == 65535 || md == ed.end())) {\n            ExifData::const_iterator md_st = findMetadatum(ed, sensitivityType, 1);\n            // no SensitivityType? exit with existing data\n            if (md_st == ed.end())\n                break;\n            // otherwise pick up actual value and grab value accordingly\n            std::ostringstream os;\n            md_st->write(os, &ed);\n            bool ok = false;\n            const long st_val = parseLong(os.str(), ok);\n            // SensivityType out of range or cannot be parsed properly\n            if (!ok || st_val < 1 || st_val > 7)\n                break;\n            // pick up list of ISO tags, and check for at least one of\n            // them available.\n            const SensKeyNameList *sensKeys = &sensitivityKey[st_val - 1];\n            md_st = ed.end();\n            for (int idx = 0; idx < sensKeys->count; md_st = ed.end()) {\n                md_st = findMetadatum(ed, const_cast<const char**>(sensKeys->keys), sensKeys->count);\n                if (md_st == ed.end())\n                    break;\n                std::ostringstream os_iso;\n                md_st->write(os_iso, &ed);\n                ok = false;\n                iso_tmp_val = parseLong(os_iso.str(), ok);\n                // something wrong with the value\n                if (ok || iso_tmp_val > 0) {\n                    md = md_st;\n                    break;\n                }\n                while (strcmp(sensKeys->keys[idx++], md_st->key().c_str()) != 0 && idx < cnt) {}\n            }\n            break;\n        }\n\n        return md;\n    }",
        "start": 76,
         "end": 184
       }, 
    "exiv2-16": {
        "buggy":"    std::ostream& Exifdatum::write(std::ostream& os, const ExifData* pMetadata) const\n    {\n        if (value().count() == 0) return os;\n\n        PrintFct       fct = printValue;\n        const TagInfo* ti  = Internal::tagInfo(tag(), static_cast<IfdId>(ifdId()));\n        // be careful with comments (User.Photo.UserComment, GPSAreaInfo etc).\n        if ( ti ) {\n            fct = ti->printFct_;\n            if ( ti->typeId_ == comment ) {\n              os << value().toString();\n              fct = nullptr;\n            }\n        }\n        if ( fct ) fct(os, value(), pMetadata);\n        return os;\n    }",
        "start": 218,
         "end": 234
       },
    "exiv2-18": {
        "buggy":"uint32_t TiffDirectory::writeDirEntry(IoWrapper&     ioWrapper,\n                                          ByteOrder      byteOrder,\n                                          int32_t        offset,\n                                          TiffComponent* pTiffComponent,\n                                          uint32_t       valueIdx,\n                                          uint32_t       dataIdx,\n                                          uint32_t&      imageIdx) const\n    {\n        assert(pTiffComponent);\n        TiffEntryBase* pDirEntry = dynamic_cast<TiffEntryBase*>(pTiffComponent);\n        assert(pDirEntry);\n        byte buf[8];\n        us2Data(buf,     pDirEntry->tag(),      byteOrder);\n        us2Data(buf + 2, pDirEntry->tiffType(), byteOrder);\n        ul2Data(buf + 4, pDirEntry->count(),    byteOrder);\n        ioWrapper.write(buf, 8);\n        if (pDirEntry->size() > 4) {\n            pDirEntry->setOffset(offset + static_cast<int32_t>(valueIdx));\n            l2Data(buf, pDirEntry->offset(), byteOrder);\n            ioWrapper.write(buf, 4);\n        }\n        else {\n            const uint32_t len = pDirEntry->write(ioWrapper,\n                                                  byteOrder,\n                                                  offset,\n                                                  valueIdx,\n                                                  dataIdx,\n                                                  imageIdx);\n            assert(len <= 4);\n            if (len < 4) {\n                memset(buf, 0x0, 4);\n                ioWrapper.write(buf, 4 - len);\n            }\n        }\n        return 12;\n    } // TiffDirectory::writeDirEntry",
        "start": 1211,
         "end": 1246
       },
    "exiv2-19": {
        "buggy":"void TiffReader::readTiffEntry(TiffEntryBase* object)\n    {\n        assert(object != 0);\n\n        byte* p = object->start();\n        assert(p >= pData_);\n\n        if (p + 12 > pLast_) {\n#ifndef SUPPRESS_WARNINGS\n            EXV_ERROR << \"Entry in directory \" << groupName(object->group())\n                      << \"requests access to memory beyond the data buffer. \"\n                      << \"Skipping entry.\\n\";\n#endif\n            return;\n        }\n        // Component already has tag\n        p += 2;\n        TiffType tiffType = getUShort(p, byteOrder());\n        TypeId typeId = toTypeId(tiffType, object->tag(), object->group());\n        long typeSize = TypeInfo::typeSize(typeId);\n        if (0 == typeSize) {\n#ifndef SUPPRESS_WARNINGS\n            EXV_WARNING << \"Directory \" << groupName(object->group())\n                        << \", entry 0x\" << std::setw(4)\n                        << std::setfill('0') << std::hex << object->tag()\n                        << \" has unknown Exif (TIFF) type \" << std::dec << tiffType\n                        << \"; setting type size 1.\\n\";\n#endif\n            typeSize = 1;\n        }\n        p += 2;\n        uint32_t count = getULong(p, byteOrder());\n        if (count >= 0x10000000) {\n#ifndef SUPPRESS_WARNINGS\n            EXV_ERROR << \"Directory \" << groupName(object->group())\n                      << \", entry 0x\" << std::setw(4)\n                      << std::setfill('0') << std::hex << object->tag()\n                      << \" has invalid size \"\n                      << std::dec << count << \"*\" << typeSize\n                      << \"; skipping entry.\\n\";\n#endif\n            return;\n        }\n        p += 4;\n        uint32_t isize= 0; // size of Exif.Sony1.PreviewImage\n\n        if (count > std::numeric_limits<uint32_t>::max() / typeSize) {\n            throw Error(kerArithmeticOverflow);\n        }\n        uint32_t size = typeSize * count;\n        uint32_t offset = getLong(p, byteOrder());\n        byte* pData = p;\n        if (   size > 4\n            && (   baseOffset() + offset >= size_\n                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {\n                // #1143\n                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == \"Sony1\" ) {\n                    isize=size;\n                } else {\n#ifndef SUPPRESS_WARNINGS\n            EXV_ERROR << \"Offset of directory \" << groupName(object->group())\n                      << \", entry 0x\" << std::setw(4)\n                      << std::setfill('0') << std::hex << object->tag()\n                      << \" is out of bounds: \"\n                      << \"Offset = 0x\" << std::setw(8)\n                      << std::setfill('0') << std::hex << offset\n                      << \"; truncating the entry\\n\";\n#endif\n                }\n                size = 0;\n        }\n        if (size > 4) {\n            // setting pData to pData_ + baseOffset() + offset can result in pData pointing to invalid memory,\n            // as offset can be arbitrarily large\n            if ((static_cast<uintptr_t>(baseOffset()) > std::numeric_limits<uintptr_t>::max() - static_cast<uintptr_t>(offset))\n             || (static_cast<uintptr_t>(baseOffset() + offset) > std::numeric_limits<uintptr_t>::max() - reinterpret_cast<uintptr_t>(pData_)))\n            {\n                throw Error(kerCorruptedMetadata); // #562 don't throw kerArithmeticOverflow\n            }\n            if (pData_ + static_cast<uintptr_t>(baseOffset()) + static_cast<uintptr_t>(offset) > pLast_) {\n                throw Error(kerCorruptedMetadata);\n            }\n            pData = const_cast<byte*>(pData_) + baseOffset() + offset;\n\n        // check for size being invalid\n            if (size > static_cast<uint32_t>(pLast_ - pData)) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_ERROR << \"Upper boundary of data for \"\n                          << \"directory \" << groupName(object->group())\n                          << \", entry 0x\" << std::setw(4)\n                          << std::setfill('0') << std::hex << object->tag()\n                          << \" is out of bounds: \"\n                          << \"Offset = 0x\" << std::setw(8)\n                          << std::setfill('0') << std::hex << offset\n                          << \", size = \" << std::dec << size\n                          << \", exceeds buffer size by \"\n                          // cast to make MSVC happy\n                          << static_cast<uint32_t>(pData + size - pLast_)\n                          << \" Bytes; truncating the entry\\n\";\n#endif\n                size = 0;\n            }\n        }\n        Value::UniquePtr v = Value::create(typeId);\n        enforce(v.get() != nullptr, kerCorruptedMetadata);\n        if ( !isize ) {\n            v->read(pData, size, byteOrder());\n        } else {\n            // Prevent large memory allocations: https://github.com/Exiv2/exiv2/issues/1881\n\n            // #1143 Write a \"hollow\" buffer for the preview image\n            //       Sadly: we don't know the exact location of the image in the source (it's near offset)\n            //       And neither TiffReader nor TiffEntryBase have access to the BasicIo object being processed\n            std::vector<byte> buffer(isize);\n            v->read(buffer.data() ,isize, byteOrder());\n        }\n\n        object->setValue(std::move(v));\n        object->setData(pData, size);\n        object->setOffset(offset);\n        object->setIdx(nextIdx(object->group()));\n\n    } // TiffReader::readTiffEntry",
        "start":1493,
         "end":1615
       },
    "exiv2-20": {
        "buggy":"int Params::evalPrintFlags(const std::string& optArg)\n{\n    int rc = 0;\n    switch (action_) {\n    case Action::none:\n        action_ = Action::print;\n        printMode_ = pmList;\n        for (auto&& i : optArg) {\n            switch (i) {\n                case 'E':\n                    printTags_ |= Exiv2::mdExif;\n                    break;\n                case 'I':\n                    printTags_ |= Exiv2::mdIptc;\n                    break;\n                case 'X':\n                    printTags_ |= Exiv2::mdXmp;\n                    break;\n                case 'x':\n                    printItems_ |= prTag;\n                    break;\n                case 'g':\n                    printItems_ |= prGroup;\n                    break;\n                case 'k':\n                    printItems_ |= prKey;\n                    break;\n                case 'l':\n                    printItems_ |= prLabel;\n                    break;\n                case 'n':\n                    printItems_ |= prName;\n                    break;\n                case 'y':\n                    printItems_ |= prType;\n                    break;\n                case 'c':\n                    printItems_ |= prCount;\n                    break;\n                case 's':\n                    printItems_ |= prSize;\n                    break;\n                case 'v':\n                    printItems_ |= prValue;\n                    break;\n                case 't':\n                    printItems_ |= prTrans;\n                    break;\n                case 'h':\n                    printItems_ |= prHex;\n                    break;\n                case 'V':\n                    printItems_ |= prSet | prValue;\n                    break;\n                default:\n                    std::cerr << progname() << \": \" << _(\"Unrecognized print item\") << \" `\" << i << \"'\\n\";\n                    rc = 1;\n                    break;\n            }\n        }\n        break;\n    case Action::print:\n        std::cerr << progname() << \": \"\n                  << _(\"Ignoring surplus option -P\") << optArg << \"\\n\";\n        break;\n    default:\n        std::cerr << progname() << \": \"\n                  << _(\"Option -P is not compatible with a previous option\\n\");\n        rc = 1;\n        break;\n    }\n    return rc;\n} // Params::evalPrintFlags",
        "start": 671,
         "end": 743
       },
    "jerryscript-3": {
        "buggy":"ecma_value_t\necma_regexp_match_helper (ecma_value_t this_arg, /**< this argument */\n                          ecma_value_t string_arg) /**< source string */\n{\n  if (!ecma_is_value_object (this_arg))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an object\"));\n  }\n\n  ecma_string_t *str_p = ecma_op_to_string (string_arg);\n\n  if (JERRY_UNLIKELY (str_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);\n\n  ecma_value_t global_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_GLOBAL);\n\n  if (ECMA_IS_VALUE_ERROR (global_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return global_value;\n  }\n\n  bool global = ecma_op_to_boolean (global_value);\n\n  ecma_free_value (global_value);\n\n  if (!global)\n  {\n    ecma_value_t result = ecma_op_regexp_exec (this_arg, str_p);\n    ecma_deref_ecma_string (str_p);\n    return result;\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t full_unicode_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_UNICODE);\n\n  if (ECMA_IS_VALUE_ERROR (full_unicode_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return full_unicode_value;\n  }\n\n  bool full_unicode = ecma_op_to_boolean (full_unicode_value);\n\n  ecma_free_value (full_unicode_value);\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t set_status = ecma_op_object_put (obj_p,\n                                                ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                ecma_make_uint32_value (0),\n                                                true);\n\n  if (ECMA_IS_VALUE_ERROR (set_status))\n  {\n    ecma_deref_ecma_string (str_p);\n    return set_status;\n  }\n\n  ecma_value_t ret_value = ECMA_VALUE_ERROR;\n  ecma_object_t *result_array_p = ecma_op_new_array_object (0);\n  uint32_t n = 0;\n\n  while (true)\n  {\n    ecma_value_t result_value = ecma_op_regexp_exec (this_arg, str_p);\n\n    if (ECMA_IS_VALUE_ERROR (result_value))\n    {\n      goto result_cleanup;\n    }\n\n    if (ecma_is_value_null (result_value))\n    {\n      if (n == 0)\n      {\n        ret_value = ECMA_VALUE_NULL;\n        goto result_cleanup;\n      }\n\n      ecma_deref_ecma_string (str_p);\n      return ecma_make_object_value (result_array_p);\n    }\n\n    ecma_object_t *result_value_p = ecma_get_object_from_value (result_value);\n    ecma_value_t match_value = ecma_op_object_get_by_index (result_value_p, 0);\n\n    ecma_deref_object (result_value_p);\n\n    if (ECMA_IS_VALUE_ERROR (match_value))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_string_t *match_str_p = ecma_op_to_string (match_value);\n    ecma_free_value (match_value);\n\n    if (JERRY_UNLIKELY (match_str_p == NULL))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_value_t new_prop = ecma_builtin_helper_def_prop_by_index (result_array_p,\n                                                                   n,\n                                                                   ecma_make_string_value (match_str_p),\n                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);\n\n    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_prop));\n\n    const bool is_match_empty = ecma_string_is_empty (match_str_p);\n    ecma_deref_ecma_string (match_str_p);\n\n    if (is_match_empty)\n    {\n      ecma_value_t last_index = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);\n\n      if (ECMA_IS_VALUE_ERROR (last_index))\n      {\n        goto result_cleanup;\n      }\n\n#if JERRY_ESNEXT\n      ecma_length_t index;\n      ecma_value_t length_value = ecma_op_to_length (last_index, &index);\n\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (length_value))\n      {\n        goto result_cleanup;\n      }\n\n      index = ecma_op_advance_string_index (str_p, index, full_unicode);\n\n      last_index = ecma_make_length_value (index);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), ecma_make_length_value(index), true);\n#else /* !JERRY_ESNEXT */\n      ecma_number_t index = ecma_get_number_from_value (last_index);\n      ecma_free_value (last_index);\n\n      last_index = ecma_make_number_value (index + 1);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                         last_index,\n                                                         true);\n\n#endif /* JERRY_ESNEXT */\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (next_set_status))\n      {\n        goto result_cleanup;\n      }\n    }\n\n    n++;\n  }\n\nresult_cleanup:\n  ecma_deref_ecma_string (str_p);\n  ecma_deref_object (result_array_p);\n  return ret_value;\n} /* ecma_regexp_match_helper */",
        "start": 3359,
         "end": 3524
       },
    "jerryscript-4": {
        "buggy":"static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */\n                                           ecma_value_t arg2, /**< end */\n                                           ecma_object_t *obj_p, /**< object */\n                                           ecma_length_t len) /**< object's length */\n{\n  ecma_length_t start = 0, end = len;\n\n  /* 5. 6.*/\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,\n                                                                      len,\n                                                                      &start)))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  /* 7. */\n  if (ecma_is_value_undefined (arg2))\n  {\n    end = len;\n  }\n  else\n  {\n    /* 7. part 2, 8.*/\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,\n                                                                        len,\n                                                                        &end)))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n  }\n\n  JERRY_ASSERT (start <= len && end <= len);\n\n  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);\n  ecma_length_t copied_length = (end > start) ? end - start : 0;\n#if JERRY_ESNEXT\n  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);\n\n  if (JERRY_UNLIKELY (new_array_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);\n#else /* !JERRY_ESNEXT */\n  ecma_object_t *new_array_p = ecma_op_new_array_object (0);\n#endif /* JERRY_ESNEXT */\n\n  if (use_fast_path && copied_length > 0)\n  {\n    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;\n\n    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)\n    {\n      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))\n      {\n        /**\n         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.\n         * There is no need to do any copy.\n         */\n        return ecma_make_object_value (new_array_p);\n      }\n\n      /* Source array's length could be changed during the start/end normalization.\n       * If the \"end\" value is greater than the current length, clamp the value to avoid buffer-overflow. */\n\n      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;\n\n#if JERRY_ESNEXT\n      uint32_t target_length = ext_to_obj_p->u.array.length;\n      ecma_value_t *to_buffer_p;\n      JERRY_ASSERT (copied_length <= UINT32_MAX);\n\n      if (copied_length == target_length)\n      {\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n      else if (copied_length > target_length)\n      {\n        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n#else /* !JERRY_ESNEXT */\n      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);\n#endif /* JERRY_ESNEXT */\n\n      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);\n\n      /* 9. */\n      uint32_t n = 0;\n\n      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)\n      {\n#if JERRY_ESNEXT\n        ecma_free_value_if_not_object (to_buffer_p[n]);\n#endif /* JERRY_ESNEXT */\n        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);\n      }\n\n      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;\n\n      return ecma_make_object_value (new_array_p);\n    }\n  }\n\n  /* 9. */\n  ecma_length_t n = 0;\n\n  /* 10. */\n  for (ecma_length_t k = start; k < end; k++, n++)\n  {\n    /* 10.c */\n    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);\n\n    if (ECMA_IS_VALUE_ERROR (get_value))\n    {\n      ecma_deref_object (new_array_p);\n      return get_value;\n    }\n\n    if (ecma_is_value_found (get_value))\n    {\n      /* 10.c.ii */\n      ecma_value_t put_comp;\n#if JERRY_ESNEXT\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n#else /* !JERRY_ESNEXT */\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;\n#endif /* JERRY_ESNEXT */\n      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,\n                                                        n,\n                                                        get_value,\n                                                        prop_flags);\n      ecma_free_value (get_value);\n\n#if JERRY_ESNEXT\n      if (ECMA_IS_VALUE_ERROR (put_comp))\n      {\n        ecma_deref_object (new_array_p);\n        return put_comp;\n      }\n#else /* !JERRY_ESNEXT */\n      JERRY_ASSERT (ecma_is_value_true (put_comp));\n#endif /* JERRY_ESNEXT */\n    }\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));\n\n  if (ECMA_IS_VALUE_ERROR (set_length_value))\n  {\n    ecma_deref_object (new_array_p);\n    return set_length_value;\n  }\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (new_array_p);\n} /* ecma_builtin_array_prototype_object_slice */",
        "start": 811,
         "end": 974
       },
    "jerryscript-6": {
        "buggy":"ecma_value_t\necma_atomic_read_modify_write (ecma_value_t typedarray, /**< typedArray argument */\n                               ecma_value_t index, /**< index argument */\n                               ecma_value_t value, /**< value argument */\n                               ecma_atomics_op_t op) /**< operation argument */\n{\n  /* 1. */\n  ecma_value_t buffer = ecma_validate_shared_integer_typedarray (typedarray, false);\n\n  if (ECMA_IS_VALUE_ERROR (buffer))\n  {\n    return buffer;\n  }\n\n  /* 2. */\n  ecma_value_t idx = ecma_validate_atomic_access (typedarray, index);\n\n  if (ECMA_IS_VALUE_ERROR (idx))\n  {\n    return idx;\n  }\n\n  /* 3. */\n  ecma_object_t *typedarray_p = ecma_get_object_from_value (typedarray);\n  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);\n\n  /* 4-5. */\n  ecma_value_t val = ECMA_VALUE_ERROR;\n  ecma_number_t tmp;\n  if (target_info.id == ECMA_BIGINT64_ARRAY || target_info.id == ECMA_BIGUINT64_ARRAY)\n  {\n    val = ecma_bigint_to_bigint (value, true);\n  }\n  else if (!ECMA_IS_VALUE_ERROR (ecma_op_to_integer (value, &tmp)))\n  {\n    val = ecma_make_number_value (tmp);\n  }\n\n  if (ECMA_IS_VALUE_ERROR (val))\n  {\n    return val;\n  }\n\n  /* 6. */\n  uint8_t element_size = target_info.element_size;\n\n  /* 7. */\n  ecma_typedarray_type_t element_type = target_info.id;\n\n  /* 8. */\n  uint32_t offset = target_info.offset;\n\n  /* 9. */\n  uint32_t indexed_position = ecma_number_to_uint32 (idx) * element_size + offset;\n\n\n  JERRY_UNUSED (indexed_position);\n  JERRY_UNUSED (element_type);\n  JERRY_UNUSED (val);\n  JERRY_UNUSED (buffer);\n  JERRY_UNUSED (op);\n\n  ecma_free_value (val);\n\n  /* 10. */\n  return ecma_make_uint32_value (0);\n} /* ecma_atomic_read_modify_write */",
        "start": 140,
         "end": 206
       },
    "jerryscript-7": {
        "buggy":"ecma_value_t\nopfunc_form_super_reference (ecma_value_t **vm_stack_top_p, /**< current vm stack top */\n                             vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                             ecma_value_t prop_name, /**< property name to resolve */\n                             uint8_t opcode) /**< current cbc opcode */\n{\n\n  if (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_CONSTRUCTOR)\n  {\n    ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);\n      if (!ecma_op_this_binding_is_initialized (environment_record_p))\n    {\n      return ecma_raise_reference_error (ECMA_ERR_CALL_SUPER_CONSTRUCTOR_DERIVED_CLASS_BEFORE_THIS);\n    }\n  }\n\n  ecma_value_t parent = ecma_op_resolve_super_base (frame_ctx_p->lex_env_p);\n\n  if (ECMA_IS_VALUE_ERROR (parent))\n  {\n    return ecma_raise_type_error (ECMA_ERR_INVOKE_NULLABLE_SUPER_METHOD);\n  }\n\n  if (!ecma_op_require_object_coercible (parent))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t *stack_top_p = *vm_stack_top_p;\n\n  if (opcode >= CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE)\n  {\n    JERRY_ASSERT (opcode == CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE\n                  || opcode == CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);\n    *stack_top_p++ = parent;\n    *stack_top_p++ = ecma_copy_value (prop_name);\n    *vm_stack_top_p = stack_top_p;\n\n    return ECMA_VALUE_EMPTY;\n  }\n\n  ecma_object_t *parent_p = ecma_get_object_from_value (parent);\n  ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name);\n\n  if (prop_name_p == NULL)\n  {\n    ecma_deref_object (parent_p);\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t result = ecma_op_object_get_with_receiver (parent_p, prop_name_p, frame_ctx_p->this_binding);\n  ecma_deref_ecma_string (prop_name_p);\n  ecma_deref_object (parent_p);\n\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    return result;\n  }\n\n  if (opcode == CBC_EXT_SUPER_PROP_LITERAL_REFERENCE || opcode == CBC_EXT_SUPER_PROP_REFERENCE)\n  {\n    *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);\n    *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n  }\n\n  *stack_top_p++ = result;\n  *vm_stack_top_p = stack_top_p;\n\n  return ECMA_VALUE_EMPTY;\n} /* opfunc_form_super_reference */",
        "start": 1956,
         "end": 2025
       },
    "jerryscript-8": {
        "buggy":"ecma_value_t\nopfunc_private_set (ecma_value_t base, /**< this object */\n                    ecma_value_t property, /**< property name */\n                    ecma_value_t value) /**< ecma value */\n{\n  ecma_object_t *obj_p = ecma_get_object_from_value (base);\n\n\n  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);\n  ecma_string_t *private_key_p = NULL;\n\n  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);\n\n\n  if (prop_p == NULL)\n  {\n    return ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);\n  }\n  if (*prop_p & ECMA_PROPERTY_FLAG_DATA)\n  {\n    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));\n\n    if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD)\n    {\n      return ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE);\n    }\n    ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value);\n    return ecma_copy_value (value);\n  }\n  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));\n\n\n  if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n  {\n    return ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER);\n  }\n\n  ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n\n  return ecma_op_function_call (setter_p, base, &value, 1);\n} /* opfunc_private_set */",
        "start": 1401,
         "end": 1441
       },
    "jerryscript-9": {
        "buggy":"ecma_value_t\necma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */\n                            ecma_object_t *new_target_p, /**< new target */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL && !ecma_is_lexical_environment (func_obj_p));\n\n\n  switch (ecma_get_object_type (func_obj_p))\n  {\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    {\n      return ecma_op_function_construct_simple (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n    {\n      return ecma_op_function_construct_built_in (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#if JERRY_BUILTIN_PROXY\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      return ecma_proxy_object_construct (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n#if JERRY_ESNEXT\n    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:\n    {\n      return ecma_op_function_construct_constructor (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      return ecma_op_function_construct_bound (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n    {\n      return ecma_op_function_construct_native (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n} /* ecma_op_function_construct */",
        "start": 1764,
         "end": 1810
       },
    "jerryscript-10": {
        "buggy":"static ecma_value_t\necma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */\n                                       ecma_object_t *source, /**< source object */\n                                       ecma_length_t source_len, /**< source object length */\n                                       ecma_length_t start, /**< remaining recursion depth */\n                                       ecma_number_t depth, /**< start index offset */\n                                       ecma_value_t mapped_value, /**< mapped value  */\n                                       ecma_value_t thisArg) /**< this arg */\n{\n\n  /* 7. */\n  ecma_length_t target_index = start;\n\n  /* 9. */\n  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)\n  {\n    /* a. */\n    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);\n\n    if (ECMA_IS_VALUE_ERROR (element))\n    {\n      return element;\n    }\n\n    if (!ecma_is_value_found (element))\n    {\n      continue;\n    }\n\n    /* b-c. */\n    if (!ecma_is_value_undefined (mapped_value))\n    {\n      /* i-ii. */\n      ecma_value_t source_val = ecma_make_length_value (source_index);\n      ecma_value_t args[] = { element, source_val, ecma_make_object_value (source) };\n      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);\n\n      ecma_free_value (element);\n      ecma_free_value (source_val);\n\n      if (ECMA_IS_VALUE_ERROR (temp_element))\n      {\n        return temp_element;\n      }\n\n      element = temp_element;\n    }\n\n    /* iv-v. */\n    if (depth > 0)\n    {\n      ecma_value_t is_array = ecma_is_value_array (element);\n\n      if (ECMA_IS_VALUE_ERROR (is_array))\n      {\n        ecma_free_value (element);\n        return is_array;\n      }\n\n      if (ecma_is_value_true (is_array))\n      {\n        ecma_object_t *element_obj = ecma_get_object_from_value (element);\n        ecma_length_t element_len;\n        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);\n\n        if (ECMA_IS_VALUE_ERROR (len_value))\n        {\n          ecma_deref_object (element_obj);\n          return len_value;\n        }\n\n        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,\n                                                                               element_obj,\n                                                                               element_len,\n                                                                               target_index,\n                                                                               depth - 1,\n                                                                               ECMA_VALUE_UNDEFINED,\n                                                                               ECMA_VALUE_UNDEFINED);\n\n        ecma_deref_object (element_obj);\n\n        if (ECMA_IS_VALUE_ERROR (target_index_val))\n        {\n          return target_index_val;\n        }\n\n        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);\n        continue;\n      }\n    }\n\n    /* vi. */\n    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n    ecma_value_t element_temp =\n      ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target), target_index, element, flags);\n\n    ecma_free_value (element);\n\n    if (ECMA_IS_VALUE_ERROR (element_temp))\n    {\n      return element_temp;\n    }\n\n    target_index++;\n  }\n  /* 10. */\n  return ecma_make_length_value (target_index);\n} /* ecma_builtin_array_flatten_into_array */",
        "start": 2654,
         "end": 2761
       },
    "jerryscript-11": {
        "buggy":"static void\necma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
        "start": 59,
         "end": 74
       },
    "libchewing-1": {
        "buggy":"CHEWING_API void chewing_set_ChiEngMode(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == CHINESE_MODE || mode == SYMBOL_MODE) {\n        // remove all data inside buffer as switching mode.\n        BopomofoRemoveAll(&(ctx->data->bopomofoData));\n        MakeOutputWithRtn(ctx->output, ctx->data, KEYSTROKE_ABSORB);\n        ctx->data->bChiSym = mode;\n    }\n}",
        "start": 684,
         "end": 701
       },
    "libchewing-4": {
        "buggy":"CHEWING_API int chewing_handle_Up( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint key_buf_cursor;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tkey_buf_cursor = pgdata->chiSymbolCursor;\n\t// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tkey_buf_cursor--;\n\n\t/* close candidate list, compared to Down key to open candidate list. */\n\tif ( ! pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\tif ( pgdata->bSelect ) {\n\t\t\tChoiceEndChoice( pgdata );\n\t\t}\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "start": 1065,
         "end": 1100
       },
    "libchewing-5": {
        "buggy":"CHEWING_API int chewing_handle_ShiftSpace(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect) {\n        CheckAndResetRange(pgdata);\n    }\n\n\n    CallPhrasing(pgdata, 0);\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "start": 1713,
         "end": 1735
       },
    "libchewing-6": {
        "buggy":"int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )\n{\n\tint throwEnd;\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];\n\n\tthrowEnd = CountReleaseNum( pgdata );\n\n\tpgo->nCommitStr = throwEnd;\n\tif ( throwEnd ) {\n\t\t/*\n\t\t * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n\t\t * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n\t\t */\n\t\tWriteChiSymbolToBuf( pgo->commitStr, throwEnd, pgdata );\n\n\t\t/* Add to userphrase */\n\t\tmemcpy( bufPhoneSeq, pgdata->phoneSeq, sizeof( uint16_t ) * throwEnd );\n\t\tbufPhoneSeq[ throwEnd ] = (uint16_t) 0;\n\t\tueStrNCpy( bufWordSeq, pgdata->phrOut.chiBuf, throwEnd, 1 );\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\n\t\tKillFromLeft( pgdata, throwEnd );\n\t}\n\treturn throwEnd;\n}",
        "start": 537,
         "end": 562
       },
    "libchewing-7": {
        "buggy":"int CallPhrasing(ChewingData *pgdata, int all_phrasing)\n{\n    /* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n    int i, ch_count = 0;\n\n    memcpy(pgdata->bArrBrkpt, pgdata->bUserArrBrkpt, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n    memset(pgdata->bSymbolArrBrkpt, 0, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            ch_count++;\n        else {\n            pgdata->bArrBrkpt[ch_count] = 1;\n            pgdata->bSymbolArrBrkpt[ch_count] = 1;\n        }\n    }\n\n    /* kill select interval */\n    for (i = 0; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bArrBrkpt[i]) {\n            ChewingKillSelectIntervalAcross(i, pgdata);\n        }\n    }\n\n    ShowChewingData(pgdata);\n\n    /* then phrasing */\n    Phrasing(pgdata, all_phrasing);\n\n    /* and then make prefer interval */\n    MakePreferInterval(pgdata);\n\n    return 0;\n}",
        "start": 719,
         "end": 752
       },
    "libchewing-8": {
        "buggy":"CHEWING_API int chewing_handle_Numlock( ChewingContext *ctx, int key )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint rtn, QuickCommit = 0;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( ! pgdata->bSelect ) {\n\t\t/* If we're not selecting words, we should send out numeric\n\t\t * characters at once.\n\t\t */\n\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\tQuickCommit = 1;\n\t\t}\n\t\trtn = SymbolInput( key, pgdata );\n\t\t/* copied from chewing_handle_Default */\n\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE ;\n\t\t}\n\t\telse if ( QuickCommit ) {\n\t\t\tpgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];\n\t\t\tpgo->nCommitStr = 1;\n\t\t\tpgdata->chiSymbolBufLen = 0;\n\t\t\tpgdata->chiSymbolCursor = 0;\n\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t\telse {\t/* Not quick commit */\n\t\t\tCallPhrasing( pgdata, 0 );\n\t\t\tif( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t}\n\telse {\n\t\t/* Otherwise, if we are selecting words, we use numeric keys\n\t\t * as selkey\n\t\t * and submit the words.\n\t\t */\n\t\tint num = -1;\n\t\tif ( key > '0' && key < '9' )\n\t\t\tnum = key - '1';\n\t\telse if ( key == '0' )\n\t\t\tnum = 9;\n\t\tDoSelect( pgdata, num );\n\t}\n\tCallPhrasing( pgdata, 0 );\n\tif ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "start": 1348,
         "end": 1397
       },
    "libtiff-1": {
        "buggy":"static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }",
        "start": 951,
         "end": 1096
       },
    "libtiff-2": {
        "buggy":"int\nreadextension(void)\n{\n    int count;\n    char buf[255];\n    int status = 1;\n\n    (void) getc(infile);\n    while ((count = getc(infile)) && count <= 255)\n        if (fread(buf, 1, count, infile) != (size_t) count) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            status = 0;\n            break;\n        }\n    return status;\n}",
        "start": 365,
         "end": 381
       },
    "libtiff-3": {
        "buggy":"int\nmain(int argc, char* argv[])\n  {\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thorizSubSampling = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvertSubSampling = atoi(optarg);\n            if( vertSubSampling != 1 && vertSubSampling != 2 && vertSubSampling != 4 )\n                usage(-1);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\t/* CCIR Rec 601-1 w/ headroom/footroom */\n\t\t\trefBlackWhite[0] = 16.;\n\t\t\trefBlackWhite[1] = 235.;\n\t\t\trefBlackWhite[2] = 128.;\n\t\t\trefBlackWhite[3] = 240.;\n\t\t\trefBlackWhite[4] = 128.;\n\t\t\trefBlackWhite[5] = 240.;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(0);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(-1);\n\tout = TIFFOpen(argv[argc-1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tsetupLumaTables();\n\tfor (; optind < argc-1; optind++) {\n\t\tin = TIFFOpen(argv[optind], \"r\");\n\t\tif (in != NULL) {\n\t\t\tdo {\n\t\t\t\tif (!tiffcvt(in, out) ||\n\t\t\t\t    !TIFFWriteDirectory(out)) {\n\t\t\t\t\t(void) TIFFClose(out);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t} while (TIFFReadDirectory(in));\n\t\t\t(void) TIFFClose(in);\n\t\t}\n\t}\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
        "start": 81,
         "end": 161
       },
    "libtiff-4": {
        "buggy":"static int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
        "start": 1576,
         "end": 1732
       },
    "libtiff-5": {
        "buggy":"uint32\nTIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n    /* If the value was already computed and store in td_nstrips, then return it,\n       since ChopUpSingleUncompressedStrip might have altered and resized the\n       since the td_stripbytecount and td_stripoffset arrays to the new value\n       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in\n       tif_dirread.c ~line 3612.\n       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}",
        "start": 60,
         "end": 79
       },
    "libtiff_sanitize-1": {
        "buggy":"void\nPSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)\n{\n\tuint32 row;\n\tint breaklen = MAXLINE, es = samplesperpixel - nc;\n\ttsize_t cc;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\n\t(void) w;\n\ttf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\tfor (row = 0; row < h; row++) {\n\t\tif (TIFFReadScanline(tif, tf_buf, row, 0) < 0)\n\t\t\tbreak;\n\t\tcp = tf_buf;\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, tf_bytesperrow);\n\t\t}\n\t\tif (alpha) {\n\t\t\tint adjust;\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\t/*\n\t\t\t\t * For images with alpha, matte against\n\t\t\t\t * a white background; i.e.\n\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t * where Cback = 1.\n\t\t\t\t */\n\t\t\t\tadjust = 255 - cp[nc];\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t} else {\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n}",
        "start": 2459,
         "end": 2520
       },
    "libtiff_sanitize-3": {
        "buggy":"static int\nprepare_JPEGTables(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\n\t/* Initialize quant tables for current quality setting */\n\tif (!TIFFjpeg_set_quality(sp, sp->jpegquality, FALSE))\n\t\treturn (0);\n\t/* Mark only the tables we want for output */\n\t/* NB: chrominance tables are currently used only with YCbCr */\n\tif (!TIFFjpeg_suppress_tables(sp, TRUE))\n\t\treturn (0);\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_QUANT) {\n\t\tunsuppress_quant_table(sp, 0);\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR)\n\t\t\tunsuppress_quant_table(sp, 1);\n\t}\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_HUFF) {\n\t\tunsuppress_huff_table(sp, 0);\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR)\n\t\t\tunsuppress_huff_table(sp, 1);\n\t}\n\t/* Direct libjpeg output into jpegtables */\n\tif (!TIFFjpeg_tables_dest(sp, tif))\n\t\treturn (0);\n\t/* Emit tables-only datastream */\n\tif (!TIFFjpeg_write_tables(sp))\n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
        "start": 1544,
         "end": 1738
       },
    "libucl-2": {
        "buggy":"static ucl_object_t *\nucl_parse_macro_arguments (struct ucl_parser *parser,\n\t\tstruct ucl_chunk *chunk)\n{\n\tucl_object_t *res = NULL;\n\tstruct ucl_parser *params_parser;\n\tint obraces = 1, ebraces = 0, state = 0;\n\tconst unsigned char *p, *c;\n\tsize_t args_len = 0;\n\tstruct ucl_parser_saved_state saved;\n\n\tsaved.column = chunk->column;\n\tsaved.line = chunk->line;\n\tsaved.pos = chunk->pos;\n\tsaved.remain = chunk->remain;\n\tp = chunk->pos;\n\n\tif (*p != '(' || chunk->remain < 2) {\n\t\treturn NULL;\n\t}\n\n\t/* Set begin and start */\n\tucl_chunk_skipc (chunk, p);\n\tc = p;\n\n\twhile ((p) < (chunk)->end) {\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\t/* Parse symbols and check for '(', ')' and '\"' */\n\t\t\tif (*p == '(') {\n\t\t\t\tobraces ++;\n\t\t\t}\n\t\t\telse if (*p == ')') {\n\t\t\t\tebraces ++;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\t/* Check pairing */\n\t\t\tif (obraces == ebraces) {\n\t\t\t\tstate = 99;\n\t\t\t}\n\t\t\telse {\n\t\t\t\targs_len ++;\n\t\t\t}\n\t\t\t/* Check overflow */\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* We have quote character, so skip all but quotes */\n\t\t\tif (*p == '\"' && *(p - 1) != '\\\\') {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t\tif (chunk->remain == 0) {\n\t\t\t\tgoto restore_chunk;\n\t\t\t}\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\tbreak;\n\t\tcase 99:\n\t\t\t/*\n\t\t\t * We have read the full body of arguments, so we need to parse and set\n\t\t\t * object from that\n\t\t\t */\n\t\t\tparams_parser = ucl_parser_new (parser->flags);\n\t\t\tif (!ucl_parser_add_chunk (params_parser, c, args_len)) {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"macro arguments parsing error\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = ucl_parser_get_object (params_parser);\n\t\t\t}\n\t\t\tucl_parser_free (params_parser);\n\n\t\t\treturn res;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n\nrestore_chunk:\n\tchunk->column = saved.column;\n\tchunk->line = saved.line;\n\tchunk->pos = saved.pos;\n\tchunk->remain = saved.remain;\n\n\treturn NULL;\n}",
        "start": 1775,
         "end": 1866
       },
    "libucl-4": {
        "buggy":"static bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false;\n\n\tif (parser->top_obj == NULL) {\n\t\tif (*chunk->pos == '[') {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, true, 0);\n\t\t}\n\t\telse {\n\t\t\tobj = ucl_add_parser_stack (NULL, parser, false, 0);\n\t\t}\n\t\tif (obj == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tparser->top_obj = obj;\n\t\tparser->cur_obj = obj;\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t/*\n\t\t\t * At the init state we can either go to the parse array or object\n\t\t\t * if we got [ or { correspondingly or can just treat new data as\n\t\t\t * a key of newly created object\n\t\t\t */\n\t\t\tobj = parser->cur_obj;\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip any spaces */\n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\t\t/* Skip any spaces */\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (*p == '}') {\n\t\t\t\t/* We have the end of an object */\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t/* No objects are on stack, but we want to parse a key */\n\t\t\t\tucl_set_err (chunk, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t/* Parse more keys and nest objects accordingly */\n\t\t\t\t\tobj = ucl_add_parser_stack (parser->cur_obj, parser, false,\n\t\t\t\t\t\t\tparser->stack->level + 1);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t/* We need to check what we do have */\n\t\t\tif (!ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* State is set in ucl_parse_value call */\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* Array */\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* Skip everything at the end */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (p - c > 0) {\n\t\t\t\t/* We got macro name */\n\t\t\t\tmacro_len = (size_t)(p - c);\n\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\tif (macro == NULL) {\n\t\t\t\t\tucl_create_err (&parser->err, \"error on line %d at column %d: \"\n\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\tchunk->line, chunk->column, (int)(p - c), c, *chunk->pos);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Now we need to skip all spaces */\n\t\t\t\twhile (p < chunk->end) {\n\t\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\t\t\t\t/* Skip comment */\n\t\t\t\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped, macro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\t\t\tif (macro_escaped == NULL) {\n\t\t\t\tif (!macro->handler (macro_start, macro_len, macro->ud)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!macro->handler (macro_escaped, macro_len, macro->ud)) {\n\t\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* TODO: add all states */\n\t\t\tucl_set_err (chunk, UCL_EINTERNAL, \"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
        "start": 1622,
         "end": 1819
       },
    "libxml2-3": {
        "buggy":"int\nxmlParseElementDecl(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    int ret = -1;\n    xmlElementContentPtr content  = NULL;\n\n    /* GROW; done in the caller */\n    if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {\n\txmlParserInputPtr input = ctxt->input;\n\n\tSKIP(9);\n\tif (!IS_BLANK_CH(CUR)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t           \"Space required after 'ELEMENT'\\n\");\n\t}\n        SKIP_BLANKS;\n        name = xmlParseName(ctxt);\n\tif (name == NULL) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t\t   \"xmlParseElementDecl: no name for Element\\n\");\n\t    return(-1);\n\t}\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\tif (!IS_BLANK_CH(CUR)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"Space required after the element name\\n\");\n\t}\n        SKIP_BLANKS;\n\tif (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n\t    SKIP(5);\n\t    /*\n\t     * Element must always be empty.\n\t     */\n\t    ret = XML_ELEMENT_TYPE_EMPTY;\n\t} else if ((RAW == 'A') && (NXT(1) == 'N') &&\n\t           (NXT(2) == 'Y')) {\n\t    SKIP(3);\n\t    /*\n\t     * Element is a generic container.\n\t     */\n\t    ret = XML_ELEMENT_TYPE_ANY;\n\t} else if (RAW == '(') {\n\t    ret = xmlParseElementContentDecl(ctxt, name, &content);\n\t} else {\n\t    /*\n\t     * [ WFC: PEs in Internal Subset ] error handling.\n\t     */\n\t    if ((RAW == '%') && (ctxt->external == 0) &&\n\t        (ctxt->inputNr == 1)) {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,\n\t  \"PEReference: forbidden within markup decl in internal subset\\n\");\n\t    } else {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n\t\t      \"xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\\n\");\n            }\n\t    return(-1);\n\t}\n\n\tSKIP_BLANKS;\n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\tSKIP_BLANKS;\n\n\tif (RAW != '>') {\n\t    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n\t    if (content != NULL) {\n\t\txmlFreeDocElementContent(ctxt->myDoc, content);\n\t    }\n\t} else {\n\t    if (input != ctxt->input) {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n    \"Element declaration doesn't start and stop in the same entity\\n\");\n\t    }\n\n\t    NEXT;\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t(ctxt->sax->elementDecl != NULL)) {\n\t\tif (content != NULL)\n\t\t    content->parent = NULL;\n\t        ctxt->sax->elementDecl(ctxt->userData, name, ret,\n\t\t                       content);\n\t\tif ((content != NULL) && (content->parent == NULL)) {\n\t\t    /*\n\t\t     * this is a trick: if xmlAddElementDecl is called,\n\t\t     * instead of copying the full tree it is plugged directly\n\t\t     * if called from the parser. Avoid duplicating the\n\t\t     * interfaces or change the API/ABI\n\t\t     */\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, content);\n\t\t}\n\t    } else if (content != NULL) {\n\t\txmlFreeDocElementContent(ctxt->myDoc, content);\n\t    }\n\t}\n    }\n    return(ret);\n}",
        "start": 6697,
         "end": 6797
       },
    "libxml2-6": {
        "buggy":"int\nxmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}",
        "start": 2240,
         "end": 2264
       },
    "libxml2-7": {
        "buggy":"static void\nxmlParseInternalSubset(xmlParserCtxtPtr ctxt) {\n    /*\n     * Is there any DTD definition ?\n     */\n    if (RAW == '[') {\n        ctxt->instate = XML_PARSER_DTD;\n        NEXT;\n\t/*\n\t * Parse the succession of Markup declarations and\n\t * PEReferences.\n\t * Subsequence (markupdecl | PEReference | S)*\n\t */\n\twhile ((RAW != ']') && (ctxt->instate != XML_PARSER_EOF)) {\n\t    const xmlChar *check = CUR_PTR;\n\t    unsigned int cons = ctxt->input->consumed;\n\n\t    SKIP_BLANKS;\n\t    xmlParseMarkupDecl(ctxt);\n\t    xmlParsePEReference(ctxt);\n\n\t    /*\n\t     * Pop-up of finished entities.\n\t     */\n\t    while ((RAW == 0) && (ctxt->inputNr > 1))\n\t\txmlPopInput(ctxt);\n\n\t    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n\t\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t     \"xmlParseInternalSubset: error detected in Markup declaration\\n\");\n\t\tbreak;\n\t    }\n\t}\n\tif (RAW == ']') {\n\t    NEXT;\n\t    SKIP_BLANKS;\n\t}\n    }\n\n    /*\n     * We should be at the end of the DOCTYPE declaration.\n     */\n    if (RAW != '>') {\n\txmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n    }\n    NEXT;\n}",
        "start": 8427,
         "end": 8473
       },
    "ndpi-3": {
        "buggy":"void ndpi_search_syslog(struct ndpi_detection_module_struct\n\t\t\t*ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &ndpi_struct->packet;\n  u_int16_t i;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search syslog\\n\");\n\n  if (packet->payload_packet_len > 20 && packet->payload[0] == '<') {\n    NDPI_LOG_DBG2(ndpi_struct, \"checked len>20 and <1024 and first symbol=<\\n\");\n\n    for (i = 1; i <= 3; i++) {\n      if (packet->payload[i] < '0' || packet->payload[i] > '9') {\n\t\tbreak;\n      }\n    }\n    NDPI_LOG_DBG2(ndpi_struct,\n             \"read symbols while the symbol is a number.\\n\");\n\n    if (packet->payload[i++] != '>') {\n      NDPI_LOG_DBG(ndpi_struct, \"excluded, there is no > following the number\\n\");\n      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n      return;\n    } else {\n      NDPI_LOG_DBG2(ndpi_struct, \"a > following the number\\n\");\n    }\n\n    if (packet->payload[i] == 0x20) {\n      NDPI_LOG_DBG2(ndpi_struct, \"a blank following the >: increment i\\n\");\n      i++;\n    } else {\n      NDPI_LOG_DBG2(ndpi_struct, \"no blank following the >: do nothing\\n\");\n    }\n\n    while (i < packet->payload_packet_len - 1)\n    {\n        if (ndpi_isalnum(packet->payload[i]) == 0)\n        {\n            if (packet->payload[i] == ' ' || packet->payload[i] == ':' ||\n                packet->payload[i] == '=')\n            {\n                break;\n            }\n            NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n            return;\n        }\n\n        i++;\n    }\n\n    if (packet->payload[i] == ':')\n    {\n        if (++i >= packet->payload_packet_len ||\n            packet->payload[i] != ' ')\n        {\n            NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n            return;\n        }\n    }\n\n    NDPI_LOG_INFO(ndpi_struct, \"found syslog\\n\");\n    ndpi_int_syslog_add_connection(ndpi_struct, flow);\n    return;\n  }\n  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n}",
        "start": 37,
         "end": 102
       },
    "ndpi-4": {
        "buggy":"static void ndpi_http_parse_subprotocol(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t struct ndpi_flow_struct *flow) {\n  if((flow->l4.tcp.http_stage == 0) || (flow->http.url && flow->http_detected)) {\n    char *double_col = strchr((char*)flow->host_server_name, ':');\n\n    if(double_col) double_col[0] = '\\0';\n\n    if(ndpi_match_hostname_protocol(ndpi_struct, flow,\n\t\t\t\t    flow->detected_protocol_stack[1],\n\t\t\t\t    flow->host_server_name,\n\t\t\t\t    strlen(flow->host_server_name)) == 0) {\n      if(flow->http.url &&\n         ((strstr(flow->http.url, \":8080/downloading?n=0.\") != NULL)\n          || (strstr(flow->http.url, \":8080/upload?n=0.\") != NULL))) {\n\t/* This looks like Ookla speedtest */\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OOKLA, NDPI_PROTOCOL_HTTP, NDPI_CONFIDENCE_DPI);\n      }\n    }\n\n  }\n}",
        "start": 398,
         "end": 418
       },
    "proj-1": {
        "buggy":"PJ *PROJECTION(omerc) {\n    double con, com, cosph0, D, F, H, L, sinph0, p, J, gamma=0,\n        gamma0, lamc=0, lam1=0, lam2=0, phi1=0, phi2=0, alpha_c=0;\n    int alp, gam, no_off = 0;\n\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc (1, sizeof (struct pj_opaque)));\n    if (nullptr==Q)\n        return pj_default_destructor (P, ENOMEM);\n    P->opaque = Q;\n\n    Q->no_rot = pj_param(P->ctx, P->params, \"bno_rot\").i;\n        if ((alp = pj_param(P->ctx, P->params, \"talpha\").i) != 0)\n            alpha_c = pj_param(P->ctx, P->params, \"ralpha\").f;\n        if ((gam = pj_param(P->ctx, P->params, \"tgamma\").i) != 0)\n            gamma = pj_param(P->ctx, P->params, \"rgamma\").f;\n    if (alp || gam) {\n        lamc    = pj_param(P->ctx, P->params, \"rlonc\").f;\n        no_off =\n                    /* For libproj4 compatibility */\n                    pj_param(P->ctx, P->params, \"tno_off\").i\n                    /* for backward compatibility */\n                    || pj_param(P->ctx, P->params, \"tno_uoff\").i;\n        if( no_off )\n        {\n            /* Mark the parameter as used, so that the pj_get_def() return them */\n            pj_param(P->ctx, P->params, \"sno_uoff\");\n            pj_param(P->ctx, P->params, \"sno_off\");\n        }\n    } else {\n        lam1 = pj_param(P->ctx, P->params, \"rlon_1\").f;\n        phi1 = pj_param(P->ctx, P->params, \"rlat_1\").f;\n        lam2 = pj_param(P->ctx, P->params, \"rlon_2\").f;\n        phi2 = pj_param(P->ctx, P->params, \"rlat_2\").f;\n        if (fabs(phi1 - phi2) <= TOL ||\n            (con = fabs(phi1)) <= TOL ||\n            fabs(con - M_HALFPI) <= TOL ||\n            fabs(fabs(P->phi0) - M_HALFPI) <= TOL ||\n            fabs(fabs(phi2) - M_HALFPI) <= TOL)\n                return pj_default_destructor(P, PJD_ERR_LAT_0_OR_ALPHA_EQ_90);\n    }\n    com = sqrt(P->one_es);\n    if (fabs(P->phi0) > EPS) {\n        sinph0 = sin(P->phi0);\n        cosph0 = cos(P->phi0);\n        con = 1. - P->es * sinph0 * sinph0;\n        Q->B = cosph0 * cosph0;\n        Q->B = sqrt(1. + P->es * Q->B * Q->B / P->one_es);\n        Q->A = Q->B * P->k0 * com / con;\n        D = Q->B * com / (cosph0 * sqrt(con));\n        if ((F = D * D - 1.) <= 0.)\n            F = 0.;\n        else {\n            F = sqrt(F);\n            if (P->phi0 < 0.)\n                F = -F;\n        }\n        Q->E = F += D;\n        Q->E *= pow(pj_tsfn(P->phi0, sinph0, P->e), Q->B);\n    } else {\n        Q->B = 1. / com;\n        Q->A = P->k0;\n        Q->E = D = F = 1.;\n    }\n    if (alp || gam) {\n        if (alp) {\n            gamma0 = aasin(P->ctx, sin(alpha_c) / D);\n            if (!gam)\n                gamma = alpha_c;\n        } else\n            alpha_c = aasin(P->ctx, D*sin(gamma0 = gamma));\n        P->lam0 = lamc - aasin(P->ctx, .5 * (F - 1. / F) *\n           tan(gamma0)) / Q->B;\n    } else {\n        H = pow(pj_tsfn(phi1, sin(phi1), P->e), Q->B);\n        L = pow(pj_tsfn(phi2, sin(phi2), P->e), Q->B);\n        F = Q->E / H;\n        p = (L - H) / (L + H);\n        J = Q->E * Q->E;\n        J = (J - L * H) / (J + L * H);\n        if ((con = lam1 - lam2) < -M_PI)\n            lam2 -= M_TWOPI;\n        else if (con > M_PI)\n            lam2 += M_TWOPI;\n        P->lam0 = adjlon(.5 * (lam1 + lam2) - atan(\n           J * tan(.5 * Q->B * (lam1 - lam2)) / p) / Q->B);\n        gamma0 = atan(2. * sin(Q->B * adjlon(lam1 - P->lam0)) /\n           (F - 1. / F));\n        gamma = alpha_c = aasin(P->ctx, D * sin(gamma0));\n    }\n    Q->singam = sin(gamma0);\n    Q->cosgam = cos(gamma0);\n    Q->sinrot = sin(gamma);\n    Q->cosrot = cos(gamma);\n    Q->BrA = 1. / (Q->ArB = Q->A * (Q->rB = 1. / Q->B));\n    Q->AB = Q->A * Q->B;\n    if (no_off)\n        Q->u_0 = 0;\n    else {\n        Q->u_0 = fabs(Q->ArB * atan(sqrt(D * D - 1.) / cos(alpha_c)));\n        if (P->phi0 < 0.)\n            Q->u_0 = - Q->u_0;\n    }\n    F = 0.5 * gamma0;\n    Q->v_pole_n = Q->ArB * log(tan(M_FORTPI - F));\n    Q->v_pole_s = Q->ArB * log(tan(M_FORTPI + F));\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    return P;\n}",
        "start": 124,
         "end": 233
       },
    "proj-2": {
        "buggy":"static PJ_XY s_forward (PJ_LP lp, PJ *P) {           /* Spheroidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double  sinlam, coslam, cosphi, sinphi, t, s, Krho, cosz;\n\n    sinlam = sin(lp.lam);\n    coslam = cos(lp.lam);\n    switch (Q->mode) {\n    case EQUIT:\n    case OBLIQ:\n        sinphi = sin(lp.phi);\n        cosphi = cos(lp.phi);\n        cosz = cosphi * coslam;\n        if (Q->mode == OBLIQ)\n            cosz = Q->sinph0 * sinphi + Q->cosph0 * cosz;\n        if (!Q->no_cut && cosz < -EPS) {\n            proj_errno_set(P, PJD_ERR_TOLERANCE_CONDITION);\n            return xy;\n        }\n        if (fabs(s = 1. - cosz) > EPS) {\n            t = 0.5 * (1. + cosz);\n            Krho = -log(t)/s - Q->Cb / t;\n        } else\n            Krho = 0.5 - Q->Cb;\n        xy.x = Krho * cosphi * sinlam;\n        if (Q->mode == OBLIQ)\n            xy.y = Krho * (Q->cosph0 * sinphi -\n                Q->sinph0 * cosphi * coslam);\n        else\n            xy.y = Krho * sinphi;\n        break;\n    case S_POLE:\n    case N_POLE:\n        lp.phi = fabs(Q->p_halfpi - lp.phi);\n        if (!Q->no_cut && (lp.phi - EPS) > M_HALFPI) {\n            proj_errno_set(P, PJD_ERR_TOLERANCE_CONDITION);\n            return xy;\n        }\n        if ((lp.phi *= 0.5) > EPS) {\n            t = tan(lp.phi);\n            Krho = -2.*(log(cos(lp.phi)) / t + t * Q->Cb);\n            xy.x = Krho * sinlam;\n            xy.y = Krho * coslam;\n            if (Q->mode == N_POLE)\n                xy.y = -xy.y;\n        } else\n            xy.x = xy.y = 0.;\n    }\n    return xy;\n}",
        "start": 61,
         "end": 110
       },
    "proj-3": {
        "buggy":"static int isea_hex(struct isea_dgg *g, int tri,\n                    struct isea_pt *pt, struct isea_pt *hex) {\n    struct isea_pt v;\n#ifdef FIXME\n    long sidelength;\n    long d, i, x, y;\n#endif\n    int quad;\n\n    quad = isea_ptdi(g, tri, pt, &v);\n\n    hex->x = ((int)v.x << 4) + quad;\n    hex->y = v.y;\n\n    return 1;\n#ifdef FIXME\n    d = lround(floor(v.x));\n    i = lround(floor(v.y));\n\n    /* Aperture 3 odd resolutions */\n    if (g->aperture == 3 && g->resolution % 2 != 0) {\n        long offset = lround((pow(3.0, g->resolution - 1) + 0.5));\n\n        d += offset * ((g->quad-1) % 5);\n        i += offset * ((g->quad-1) % 5);\n\n        if (quad == 0) {\n            d = 0;\n            i = offset;\n        } else if (quad == 11) {\n            d = 2 * offset;\n            i = 0;\n        } else if (quad > 5) {\n            d += offset;\n        }\n\n        x = (2*d - i) /3;\n        y = (2*i - d) /3;\n\n        hex->x = x + offset / 3;\n        hex->y = y + 2 * offset / 3;\n        return 1;\n    }\n\n    /* aperture 3 even resolutions and aperture 4 */\n    sidelength = lround((pow(g->aperture, g->resolution / 2.0)));\n    if (g->quad == 0) {\n        hex->x = 0;\n        hex->y = sidelength;\n    } else if (g->quad == 11) {\n        hex->x = sidelength * 2;\n        hex->y = 0;\n    } else {\n        hex->x = d + sidelength * ((g->quad-1) % 5);\n        if (g->quad > 5) hex->x += sidelength;\n        hex->y = i + sidelength * ((g->quad-1) % 5);\n    }\n\n    return 1;\n#endif\n}",
        "start": 890,
         "end": 950
       },
    "proj-5": {
        "buggy":"int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations,\n                                 PJ_DIRECTION direction, PJ_COORD coord) {\n    SANITIZE_CTX(ctx);\n    auto opList = dynamic_cast<PJ_OPERATION_LIST *>(operations);\n    if (opList == nullptr) {\n        proj_log_error(ctx, __FUNCTION__,\n                       \"operations is not a list of operations\");\n        return -1;\n    }\n\n    int iExcluded[2] = {-1, -1};\n    const auto &preparedOps = opList->getPreparedOperations(ctx);\n    int idx = pj_get_suggested_operation(ctx, preparedOps, iExcluded, direction,\n                                         coord);\n    if (idx >= 0) {\n        idx = preparedOps[idx].idxInOriginalList;\n    }\n    return idx;\n}",
        "start": 7655,
         "end": 7673
       },
    "proj-7": {
        "buggy":"static bool isIgnoredChar(char ch) {\n    return ch == ' ' || ch == '_' || ch == '-' || ch == '/' || ch == '(' ||\n           ch == ')' || ch == '.' || ch == '&';\n}",
        "start": 1125,
         "end": 1128
       },
    "proj-9": {
        "buggy":"PJ *PROJECTION(urm5) {\n    double alpha, t;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc (1, sizeof (struct pj_opaque)));\n    if (nullptr==Q)\n        return pj_default_destructor(P, ENOMEM);\n    P->opaque = Q;\n\n    if (pj_param(P->ctx, P->params, \"tn\").i) {\n        Q->n = pj_param(P->ctx, P->params, \"dn\").f;\n        if (Q->n <= 0. || Q->n > 1.)\n            return pj_default_destructor(P, PJD_ERR_N_OUT_OF_RANGE);\n    } else {\n            return pj_default_destructor(P, PJD_ERR_N_OUT_OF_RANGE);\n    }\n    Q->q3 = pj_param(P->ctx, P->params, \"dq\").f / 3.;\n    alpha = pj_param(P->ctx, P->params, \"ralpha\").f;\n    t = Q->n * sin (alpha);\n    Q->m = cos (alpha) / sqrt (1. - t * t);\n    Q->rmn = 1. / (Q->m * Q->n);\n\n    P->es = 0.;\n    P->inv = nullptr;\n    P->fwd = s_forward;\n\n    return P;\n}\n",
        "start": 31,
         "end": 56
       },
    "proj-10": {
        "buggy":"static PJ_XY aeqd_s_forward (PJ_LP lp, PJ *P) {           /* Spheroidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double  coslam, cosphi, sinphi;\n\n    sinphi = sin(lp.phi);\n    cosphi = cos(lp.phi);\n    coslam = cos(lp.lam);\n    switch (Q->mode) {\n    case EQUIT:\n        xy.y = cosphi * coslam;\n        goto oblcon;\n    case OBLIQ:\n        xy.y = Q->sinph0 * sinphi + Q->cosph0 * cosphi * coslam;\noblcon:\n        if (fabs(fabs(xy.y) - 1.) < TOL)\n            if (xy.y < 0.) {\n                proj_errno_set(P, PJD_ERR_TOLERANCE_CONDITION);\n                return xy;\n            }\n            else\n                xy.x = xy.y = 0.;\n        else {\n            xy.y = acos(xy.y);\n            xy.y /= sin(xy.y);\n            xy.x = xy.y * cosphi * sin(lp.lam);\n            xy.y *= (Q->mode == EQUIT) ? sinphi :\n                Q->cosph0 * sinphi - Q->sinph0 * cosphi * coslam;\n        }\n        break;\n    case N_POLE:\n        lp.phi = -lp.phi;\n        coslam = -coslam;\n        /*-fallthrough*/\n    case S_POLE:\n        if (fabs(lp.phi - M_HALFPI) < EPS10) {\n            proj_errno_set(P, PJD_ERR_TOLERANCE_CONDITION);\n            return xy;\n        }\n        xy.x = (xy.y = (M_HALFPI + lp.phi)) * sin(lp.lam);\n        xy.y *= coslam;\n        break;\n    }\n    return xy;\n}",
        "start": 133,
         "end": 177
       },
    "proj-11": {
        "buggy":"PJ *PROJECTION(lcc) {\n    double cosphi, sinphi;\n    int secant;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc(1, sizeof (struct pj_opaque)));\n\n    if (nullptr == Q)\n        return pj_default_destructor(P, ENOMEM);\n    P->opaque = Q;\n\n    Q->phi1 = pj_param(P->ctx, P->params, \"rlat_1\").f;\n    if (pj_param(P->ctx, P->params, \"tlat_2\").i)\n        Q->phi2 = pj_param(P->ctx, P->params, \"rlat_2\").f;\n    else {\n        Q->phi2 = Q->phi1;\n        if (!pj_param(P->ctx, P->params, \"tlat_0\").i)\n            P->phi0 = Q->phi1;\n    }\n    if (fabs(Q->phi1 + Q->phi2) < EPS10)\n        return pj_default_destructor(P, PJD_ERR_CONIC_LAT_EQUAL);\n\n    Q->n = sinphi = sin(Q->phi1);\n    cosphi = cos(Q->phi1);\n    secant = fabs(Q->phi1 - Q->phi2) >= EPS10;\n    if (P->es != 0.) {\n        double ml1, m1;\n\n        m1 = pj_msfn(sinphi, cosphi, P->es);\n        ml1 = pj_tsfn(Q->phi1, sinphi, P->e);\n        if (secant) { /* secant cone */\n            sinphi = sin(Q->phi2);\n            Q->n = log(m1 / pj_msfn(sinphi, cos(Q->phi2), P->es));\n            Q->n /= log(ml1 / pj_tsfn(Q->phi2, sinphi, P->e));\n        }\n        Q->c = (Q->rho0 = m1 * pow(ml1, -Q->n) / Q->n);\n        Q->rho0 *= (fabs(fabs(P->phi0) - M_HALFPI) < EPS10) ? 0. :\n            pow(pj_tsfn(P->phi0, sin(P->phi0), P->e), Q->n);\n    } else {\n        if (secant)\n            Q->n = log(cosphi / cos(Q->phi2)) /\n               log(tan(M_FORTPI + .5 * Q->phi2) /\n               tan(M_FORTPI + .5 * Q->phi1));\n        Q->c = cosphi * pow(tan(M_FORTPI + .5 * Q->phi1), Q->n) / Q->n;\n        Q->rho0 = (fabs(fabs(P->phi0) - M_HALFPI) < EPS10) ? 0. :\n            Q->c * pow(tan(M_FORTPI + .5 * P->phi0), -Q->n);\n    }\n\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    return P;\n}",
        "start": 80,
         "end": 130
       },
    "proj-12": {
        "buggy":"static PJ_XY e_forward (PJ_LP lp, PJ *P) {          /* Ellipsoidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double cosc, sinc, cosl, k;\n\n    lp = pj_gauss(P->ctx, lp, Q->en);\n    sinc = sin(lp.phi);\n    cosc = cos(lp.phi);\n    cosl = cos(lp.lam);\n    k = P->k0 * Q->R2 / (1. + Q->sinc0 * sinc + Q->cosc0 * cosc * cosl);\n    xy.x = k * cosc * sin(lp.lam);\n    xy.y = k * (Q->cosc0 * sinc - Q->sinc0 * cosc * cosl);\n    return xy;\n}",
        "start": 47,
         "end": 60
       },
    "proj-13": {
        "buggy":"static int ellps_spherification (PJ *P) {\n/***************************************************************************************/\n    const char *keys[] =  {\"R_A\", \"R_V\", \"R_a\", \"R_g\", \"R_h\", \"R_lat_a\", \"R_lat_g\"};\n    size_t len, i;\n    paralist *par = nullptr;\n\n    double t;\n    char *v, *endp;\n\n    len = sizeof (keys) /  sizeof (char *);\n\n    /* Check which spherification key is specified */\n    for (i = 0;  i < len;  i++) {\n        par = pj_get_param (P->params, keys[i]);\n        if (par)\n            break;\n    }\n\n    /* No spherification specified? Then we're done */\n    if (i==len)\n        return 0;\n\n    /* Store definition */\n    P->def_spherification = pj_strdup(par->param);\n    par->used = 1;\n\n    switch (i) {\n\n    /* R_A - a sphere with same area as ellipsoid */\n    case 0:\n        P->a *= 1. - P->es * (SIXTH + P->es * (RA4 + P->es * RA6));\n        break;\n\n    /* R_V - a sphere with same volume as ellipsoid */\n    case 1:\n        P->a *= 1. - P->es * (SIXTH + P->es * (RV4 + P->es * RV6));\n        break;\n\n    /* R_a - a sphere with R = the arithmetic mean of the ellipsoid */\n    case 2:\n        P->a = (P->a + P->b) / 2;\n        break;\n\n    /* R_g - a sphere with R = the geometric mean of the ellipsoid */\n    case 3:\n        P->a = sqrt (P->a * P->b);\n        break;\n\n    /* R_h - a sphere with R = the harmonic mean of the ellipsoid */\n    case 4:\n        if (P->a + P->b == 0)\n            return proj_errno_set (P, PJD_ERR_TOLERANCE_CONDITION);\n        P->a = (2*P->a * P->b) / (P->a + P->b);\n        break;\n\n    /* R_lat_a - a sphere with R = the arithmetic mean of the ellipsoid at given latitude */\n    case 5:\n    /* R_lat_g - a sphere with R = the geometric  mean of the ellipsoid at given latitude */\n    case 6:\n        v = pj_param_value (par);\n        t = proj_dmstor (v, &endp);\n        if (fabs (t) > M_HALFPI)\n            return proj_errno_set (P, PJD_ERR_REF_RAD_LARGER_THAN_90);\n        t = sin (t);\n        t = 1 - P->es * t * t;\n        if (i==5)   /* arithmetic */\n            P->a *= (1. - P->es + t) / (2 * t * sqrt(t));\n        else        /* geometric */\n            P->a *= sqrt (1 - P->es) / t;\n        break;\n    }\n\n\n    /* Clean up the ellipsoidal parameters to reflect the sphere */\n    P->es = P->e = P->f = 0;\n    P->rf = HUGE_VAL;\n    P->b = P->a;\n    pj_calc_ellipsoid_params (P, P->a, 0);\n\n    return 0;\n}",
        "start": 330,
         "end": 410
       },
    "proj-16": {
        "buggy":"PJ *PROJECTION(lcc) {\n    double cosphi, sinphi;\n    int secant;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc(1, sizeof (struct pj_opaque)));\n\n    if (nullptr == Q)\n        return pj_default_destructor(P, ENOMEM);\n    P->opaque = Q;\n\n    Q->phi1 = pj_param(P->ctx, P->params, \"rlat_1\").f;\n    if (pj_param(P->ctx, P->params, \"tlat_2\").i)\n        Q->phi2 = pj_param(P->ctx, P->params, \"rlat_2\").f;\n    else {\n        Q->phi2 = Q->phi1;\n        if (!pj_param(P->ctx, P->params, \"tlat_0\").i)\n            P->phi0 = Q->phi1;\n    }\n    if (fabs(Q->phi1 + Q->phi2) < EPS10)\n        return pj_default_destructor(P, PJD_ERR_CONIC_LAT_EQUAL);\n\n    Q->n = sinphi = sin(Q->phi1);\n    cosphi = cos(Q->phi1);\n    secant = fabs(Q->phi1 - Q->phi2) >= EPS10;\n    if (P->es != 0.) {\n        double ml1, m1;\n\n        m1 = pj_msfn(sinphi, cosphi, P->es);\n        ml1 = pj_tsfn(Q->phi1, sinphi, P->e);\n        if( ml1 == 0 ) {\n            return pj_default_destructor(P, PJD_ERR_LAT_1_OR_2_ZERO_OR_90);\n        }\n        if (secant) { /* secant cone */\n            sinphi = sin(Q->phi2);\n            Q->n = log(m1 / pj_msfn(sinphi, cos(Q->phi2), P->es));\n            if (Q->n == 0) {\n                // Not quite, but es is very close to 1...\n                return pj_default_destructor(P, PJD_ERR_INVALID_ECCENTRICITY);\n            }\n            const double ml2 = pj_tsfn(Q->phi2, sinphi, P->e);\n            if( ml2 == 0 ) {\n                return pj_default_destructor(P, PJD_ERR_LAT_1_OR_2_ZERO_OR_90);\n            }\n            Q->n /= log(ml1 / ml2);\n        }\n        Q->c = (Q->rho0 = m1 * pow(ml1, -Q->n) / Q->n);\n        Q->rho0 *= (fabs(fabs(P->phi0) - M_HALFPI) < EPS10) ? 0. :\n            pow(pj_tsfn(P->phi0, sin(P->phi0), P->e), Q->n);\n    } else {\n        if (secant)\n            Q->n = log(cosphi / cos(Q->phi2)) /\n               log(tan(M_FORTPI + .5 * Q->phi2) /\n               tan(M_FORTPI + .5 * Q->phi1));\n        Q->c = cosphi * pow(tan(M_FORTPI + .5 * Q->phi1), Q->n) / Q->n;\n        Q->rho0 = (fabs(fabs(P->phi0) - M_HALFPI) < EPS10) ? 0. :\n            Q->c * pow(tan(M_FORTPI + .5 * P->phi0), -Q->n);\n    }\n\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    return P;\n}",
        "start": 80,
         "end": 141
       },
    "proj-17": {
        "buggy":"PJ *PROJECTION(omerc) {\n    double con, com, cosph0, D, F, H, L, sinph0, p, J, gamma=0,\n        gamma0, lamc=0, lam1=0, lam2=0, phi1=0, phi2=0, alpha_c=0;\n    int alp, gam, no_off = 0;\n\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc (1, sizeof (struct pj_opaque)));\n    if (nullptr==Q)\n        return pj_default_destructor (P, ENOMEM);\n    P->opaque = Q;\n\n    Q->no_rot = pj_param(P->ctx, P->params, \"bno_rot\").i;\n        if ((alp = pj_param(P->ctx, P->params, \"talpha\").i) != 0)\n            alpha_c = pj_param(P->ctx, P->params, \"ralpha\").f;\n        if ((gam = pj_param(P->ctx, P->params, \"tgamma\").i) != 0)\n            gamma = pj_param(P->ctx, P->params, \"rgamma\").f;\n    if (alp || gam) {\n        lamc    = pj_param(P->ctx, P->params, \"rlonc\").f;\n        no_off =\n                    /* For libproj4 compatibility */\n                    pj_param(P->ctx, P->params, \"tno_off\").i\n                    /* for backward compatibility */\n                    || pj_param(P->ctx, P->params, \"tno_uoff\").i;\n        if( no_off )\n        {\n            /* Mark the parameter as used, so that the pj_get_def() return them */\n            pj_param(P->ctx, P->params, \"sno_uoff\");\n            pj_param(P->ctx, P->params, \"sno_off\");\n        }\n    } else {\n        lam1 = pj_param(P->ctx, P->params, \"rlon_1\").f;\n        phi1 = pj_param(P->ctx, P->params, \"rlat_1\").f;\n        lam2 = pj_param(P->ctx, P->params, \"rlon_2\").f;\n        phi2 = pj_param(P->ctx, P->params, \"rlat_2\").f;\n        if (fabs(phi1 - phi2) <= TOL ||\n            (con = fabs(phi1)) <= TOL ||\n            fabs(con - M_HALFPI) <= TOL ||\n            fabs(fabs(P->phi0) - M_HALFPI) <= TOL ||\n            fabs(fabs(phi2) - M_HALFPI) <= TOL)\n                return pj_default_destructor(P, PJD_ERR_LAT_0_OR_ALPHA_EQ_90);\n    }\n    com = sqrt(P->one_es);\n    if (fabs(P->phi0) > EPS) {\n        sinph0 = sin(P->phi0);\n        cosph0 = cos(P->phi0);\n        con = 1. - P->es * sinph0 * sinph0;\n        Q->B = cosph0 * cosph0;\n        Q->B = sqrt(1. + P->es * Q->B * Q->B / P->one_es);\n        Q->A = Q->B * P->k0 * com / con;\n        D = Q->B * com / (cosph0 * sqrt(con));\n        if ((F = D * D - 1.) <= 0.)\n            F = 0.;\n        else {\n            F = sqrt(F);\n            if (P->phi0 < 0.)\n                F = -F;\n        }\n        Q->E = F += D;\n        Q->E *= pow(pj_tsfn(P->phi0, sinph0, P->e), Q->B);\n    } else {\n        Q->B = 1. / com;\n        Q->A = P->k0;\n        Q->E = D = F = 1.;\n    }\n    if (alp || gam) {\n        if (alp) {\n            gamma0 = aasin(P->ctx, sin(alpha_c) / D);\n            if (!gam)\n                gamma = alpha_c;\n        } else\n            alpha_c = aasin(P->ctx, D*sin(gamma0 = gamma));\n        if( fabs(fabs(P->phi0) - M_HALFPI) <= TOL ) {\n            return pj_default_destructor(P, PJD_ERR_LAT_0_OR_ALPHA_EQ_90);\n        }\n        P->lam0 = lamc - aasin(P->ctx, .5 * (F - 1. / F) *\n           tan(gamma0)) / Q->B;\n    } else {\n        H = pow(pj_tsfn(phi1, sin(phi1), P->e), Q->B);\n        L = pow(pj_tsfn(phi2, sin(phi2), P->e), Q->B);\n        F = Q->E / H;\n        p = (L - H) / (L + H);\n        if( p == 0 ) {\n            // Not quite, but es is very close to 1...\n            return pj_default_destructor(P, PJD_ERR_INVALID_ECCENTRICITY);\n        }\n        J = Q->E * Q->E;\n        J = (J - L * H) / (J + L * H);\n        if ((con = lam1 - lam2) < -M_PI)\n            lam2 -= M_TWOPI;\n        else if (con > M_PI)\n            lam2 += M_TWOPI;\n        P->lam0 = adjlon(.5 * (lam1 + lam2) - atan(\n           J * tan(.5 * Q->B * (lam1 - lam2)) / p) / Q->B);\n        const double denom = F - 1. / F;\n        if( denom == 0 ) {\n            return pj_default_destructor(P, PJD_ERR_INVALID_ECCENTRICITY);\n        }\n        gamma0 = atan(2. * sin(Q->B * adjlon(lam1 - P->lam0)) / denom);\n        gamma = alpha_c = aasin(P->ctx, D * sin(gamma0));\n    }\n    Q->singam = sin(gamma0);\n    Q->cosgam = cos(gamma0);\n    Q->sinrot = sin(gamma);\n    Q->cosrot = cos(gamma);\n    Q->BrA = 1. / (Q->ArB = Q->A * (Q->rB = 1. / Q->B));\n    Q->AB = Q->A * Q->B;\n    if (no_off)\n        Q->u_0 = 0;\n    else {\n        Q->u_0 = fabs(Q->ArB * atan(sqrt(D * D - 1.) / cos(alpha_c)));\n        if (P->phi0 < 0.)\n            Q->u_0 = - Q->u_0;\n    }\n    F = 0.5 * gamma0;\n    Q->v_pole_n = Q->ArB * log(tan(M_FORTPI - F));\n    Q->v_pole_s = Q->ArB * log(tan(M_FORTPI + F));\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    return P;\n}",
        "start": 124,
         "end": 243
       },
    "proj-18": {
        "buggy":"static PJ_LP approx_s_inv (PJ_XY xy, PJ *P) {\n    PJ_LP lp = {0.0, 0.0};\n    double h, g;\n\n    h = exp(xy.x / static_cast<struct pj_opaque_approx*>(P->opaque)->esp);\n    g = .5 * (h - 1. / h);\n    h = cos (P->phi0 + xy.y / static_cast<struct pj_opaque_approx*>(P->opaque)->esp);\n    lp.phi = asin(sqrt((1. - h * h) / (1. + g * g)));\n\n    /* Make sure that phi is on the correct hemisphere when false northing is used */\n    if (xy.y < 0. && -lp.phi+P->phi0 < 0.0) lp.phi = -lp.phi;\n\n    lp.lam = (g != 0.0 || h != 0.0) ? atan2 (g, h) : 0.;\n    return lp;\n}",
        "start": 186,
         "end": 200
       },
    "proj-20": {
        "buggy":"std::unique_ptr<NTv2GridSet> NTv2GridSet::open(PJ_CONTEXT *ctx,\n                                               std::unique_ptr<File> fp,\n                                               const std::string &filename) {\n    File *fpRaw = fp.get();\n    auto set = std::unique_ptr<NTv2GridSet>(new NTv2GridSet(std::move(fp)));\n    set->m_name = filename;\n    set->m_format = \"ntv2\";\n\n    char header[11 * 16];\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the header.                                                */\n    /* -------------------------------------------------------------------- */\n    if (fpRaw->read(header, sizeof(header)) != sizeof(header)) {\n        pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n        return nullptr;\n    }\n\n    constexpr int OFFSET_GS_TYPE = 56;\n    if (memcmp(header + OFFSET_GS_TYPE, \"SECONDS\", 7) != 0) {\n        pj_log(ctx, PJ_LOG_ERROR, \"Only GS_TYPE=SECONDS is supported\");\n        pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n        return nullptr;\n    }\n\n    const bool must_swap = (header[8] == 11) ? !IS_LSB : IS_LSB;\n    constexpr int OFFSET_NUM_SUBFILES = 8 + 32;\n    if (must_swap) {\n        // swap_words( header+8, 4, 1 );\n        // swap_words( header+8+16, 4, 1 );\n        swap_words(header + OFFSET_NUM_SUBFILES, 4, 1);\n        // swap_words( header+8+7*16, 8, 1 );\n        // swap_words( header+8+8*16, 8, 1 );\n        // swap_words( header+8+9*16, 8, 1 );\n        // swap_words( header+8+10*16, 8, 1 );\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the subfile count out ... all we really use for now.        */\n    /* -------------------------------------------------------------------- */\n    unsigned int num_subfiles;\n    memcpy(&num_subfiles, header + OFFSET_NUM_SUBFILES, 4);\n\n    std::map<std::string, NTv2Grid *> mapGrids;\n\n    /* ==================================================================== */\n    /*      Step through the subfiles, creating a grid for each.            */\n    /* ==================================================================== */\n    for (unsigned subfile = 0; subfile < num_subfiles; subfile++) {\n        // Read header\n        if (fpRaw->read(header, sizeof(header)) != sizeof(header)) {\n            pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n            return nullptr;\n        }\n\n        if (strncmp(header, \"SUB_NAME\", 8) != 0) {\n            pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n            return nullptr;\n        }\n\n        // Byte swap interesting fields if needed.\n        constexpr int OFFSET_GS_COUNT = 8 + 16 * 10;\n        constexpr int OFFSET_SOUTH_LAT = 8 + 16 * 4;\n        if (must_swap) {\n            // 6 double values: southLat, northLat, eastLon, westLon, resLat,\n            // resLon\n            swap_words(header + OFFSET_SOUTH_LAT, sizeof(double), 6);\n            swap_words(header + OFFSET_GS_COUNT, sizeof(int), 1);\n        }\n\n        std::string gridName;\n        gridName.append(header + 8, 8);\n\n        ExtentAndRes extent;\n        extent.southLat = to_double(header + OFFSET_SOUTH_LAT) * DEG_TO_RAD /\n                          3600.0; /* S_LAT */\n        extent.northLat = to_double(header + OFFSET_SOUTH_LAT + 16) *\n                          DEG_TO_RAD / 3600.0; /* N_LAT */\n        extent.eastLon = -to_double(header + OFFSET_SOUTH_LAT + 16 * 2) *\n                         DEG_TO_RAD / 3600.0; /* E_LONG */\n        extent.westLon = -to_double(header + OFFSET_SOUTH_LAT + 16 * 3) *\n                         DEG_TO_RAD / 3600.0; /* W_LONG */\n        extent.resLat =\n            to_double(header + OFFSET_SOUTH_LAT + 16 * 4) * DEG_TO_RAD / 3600.0;\n        extent.resLon =\n            to_double(header + OFFSET_SOUTH_LAT + 16 * 5) * DEG_TO_RAD / 3600.0;\n\n        if (!(fabs(extent.westLon) <= 4 * M_PI &&\n              fabs(extent.eastLon) <= 4 * M_PI &&\n              fabs(extent.northLat) <= M_PI + 1e-5 &&\n              fabs(extent.southLat) <= M_PI + 1e-5 &&\n              extent.westLon < extent.eastLon &&\n              extent.southLat < extent.northLat && extent.resLon > 1e-10 &&\n              extent.resLat > 1e-10)) {\n            pj_log(ctx, PJ_LOG_ERROR, \"Inconsistent georeferencing for %s\",\n                   filename.c_str());\n            pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n            return nullptr;\n        }\n        const int columns = static_cast<int>(\n            fabs((extent.eastLon - extent.westLon) / extent.resLon + 0.5) + 1);\n        const int rows = static_cast<int>(\n            fabs((extent.northLat - extent.southLat) / extent.resLat + 0.5) +\n            1);\n\n        pj_log(ctx, PJ_LOG_DEBUG_MINOR,\n               \"NTv2 %s %dx%d: LL=(%.9g,%.9g) UR=(%.9g,%.9g)\", gridName.c_str(),\n               columns, rows, extent.westLon * RAD_TO_DEG,\n               extent.southLat * RAD_TO_DEG, extent.eastLon * RAD_TO_DEG,\n               extent.northLat * RAD_TO_DEG);\n\n        unsigned int gs_count;\n        memcpy(&gs_count, header + OFFSET_GS_COUNT, 4);\n        if (gs_count / columns != static_cast<unsigned>(rows)) {\n            pj_log(ctx, PJ_LOG_ERROR,\n                   \"GS_COUNT(%u) does not match expected cells (%dx%d)\",\n                   gs_count, columns, rows);\n            pj_ctx_set_errno(ctx, PJD_ERR_FAILED_TO_LOAD_GRID);\n            return nullptr;\n        }\n\n        const auto offset = fpRaw->tell();\n        auto grid = std::unique_ptr<NTv2Grid>(\n            new NTv2Grid(filename + \", \" + gridName, ctx, fpRaw, offset,\n                         must_swap, columns, rows, extent));\n        std::string parentName;\n        parentName.assign(header + 24, 8);\n        auto iter = mapGrids.find(parentName);\n        auto gridPtr = grid.get();\n        if (iter == mapGrids.end()) {\n            set->m_grids.emplace_back(std::move(grid));\n        } else {\n            iter->second->m_children.emplace_back(std::move(grid));\n        }\n        mapGrids[gridName] = gridPtr;\n\n        // Skip grid data. 4 components of size float\n        fpRaw->seek(static_cast<unsigned long long>(gs_count) * 4 * 4,\n                    SEEK_CUR);\n    }\n    return set;\n}",
        "start": 1836,
         "end": 1977
       },
    "proj-21": {
        "buggy":"PJ *PROJECTION(laea) {\n    double t;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc (1, sizeof (struct pj_opaque)));\n    if (nullptr==Q)\n        return pj_default_destructor (P, ENOMEM);\n    P->opaque = Q;\n    P->destructor = destructor;\n\n    t = fabs(P->phi0);\n    if (fabs(t - M_HALFPI) < EPS10)\n        Q->mode = P->phi0 < 0. ? S_POLE : N_POLE;\n    else if (fabs(t) < EPS10)\n        Q->mode = EQUIT;\n    else\n        Q->mode = OBLIQ;\n    if (P->es != 0.0) {\n        double sinphi;\n\n        P->e = sqrt(P->es);\n        Q->qp = pj_qsfn(1., P->e, P->one_es);\n        Q->mmf = .5 / (1. - P->es);\n        Q->apa = pj_authset(P->es);\n        if (nullptr==Q->apa)\n            return destructor(P, ENOMEM);\n        switch (Q->mode) {\n        case N_POLE:\n        case S_POLE:\n            Q->dd = 1.;\n            break;\n        case EQUIT:\n            Q->dd = 1. / (Q->rq = sqrt(.5 * Q->qp));\n            Q->xmf = 1.;\n            Q->ymf = .5 * Q->qp;\n            break;\n        case OBLIQ:\n            Q->rq = sqrt(.5 * Q->qp);\n            sinphi = sin(P->phi0);\n            Q->sinb1 = pj_qsfn(sinphi, P->e, P->one_es) / Q->qp;\n            Q->cosb1 = sqrt(1. - Q->sinb1 * Q->sinb1);\n            Q->dd = cos(P->phi0) / (sqrt(1. - P->es * sinphi * sinphi) *\n               Q->rq * Q->cosb1);\n            Q->ymf = (Q->xmf = Q->rq) / Q->dd;\n            Q->xmf *= Q->dd;\n            break;\n        }\n        P->inv = e_inverse;\n        P->fwd = e_forward;\n    } else {\n        if (Q->mode == OBLIQ) {\n            Q->sinb1 = sin(P->phi0);\n            Q->cosb1 = cos(P->phi0);\n        }\n        P->inv = s_inverse;\n        P->fwd = s_forward;\n    }\n\n    return P;\n}",
        "start": 242,
         "end": 299
       },
    "proj-22": {
        "buggy":"static PJ *setup(PJ *P) {\n    double cosphi, sinphi;\n    int secant;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    if (fabs(Q->phi1) > M_HALFPI || fabs(Q->phi2) > M_HALFPI)\n        return destructor(P, PJD_ERR_LAT_LARGER_THAN_90);\n    if (fabs(Q->phi1 + Q->phi2) < EPS10)\n        return destructor(P, PJD_ERR_CONIC_LAT_EQUAL);\n    Q->n = sinphi = sin(Q->phi1);\n    cosphi = cos(Q->phi1);\n    secant = fabs(Q->phi1 - Q->phi2) >= EPS10;\n    if( (Q->ellips = (P->es > 0.))) {\n        double ml1, m1;\n\n        if (!(Q->en = pj_enfn(P->es)))\n            return destructor(P, 0);\n        m1 = pj_msfn(sinphi, cosphi, P->es);\n        ml1 = pj_qsfn(sinphi, P->e, P->one_es);\n        if (secant) { /* secant cone */\n            double ml2, m2;\n\n            sinphi = sin(Q->phi2);\n            cosphi = cos(Q->phi2);\n            m2 = pj_msfn(sinphi, cosphi, P->es);\n            ml2 = pj_qsfn(sinphi, P->e, P->one_es);\n            if (ml2 == ml1)\n                return destructor(P, 0);\n\n            Q->n = (m1 * m1 - m2 * m2) / (ml2 - ml1);\n        }\n        Q->ec = 1. - .5 * P->one_es * log((1. - P->e) /\n            (1. + P->e)) / P->e;\n        Q->c = m1 * m1 + Q->n * ml1;\n        Q->dd = 1. / Q->n;\n        Q->rho0 = Q->dd * sqrt(Q->c - Q->n * pj_qsfn(sin(P->phi0),\n            P->e, P->one_es));\n    } else {\n        if (secant) Q->n = .5 * (Q->n + sin(Q->phi2));\n        Q->n2 = Q->n + Q->n;\n        Q->c = cosphi * cosphi + Q->n2 * sinphi;\n        Q->dd = 1. / Q->n;\n        Q->rho0 = Q->dd * sqrt(Q->c - Q->n2 * sin(P->phi0));\n    }\n\n    return P;\n}",
        "start": 150,
         "end": 199
       },
    "proj-23": {
        "buggy":"const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx,\n                                               const char *key) {\n    SANITIZE_CTX(ctx);\n    try {\n        // temporary variable must be used as getDBcontext() might create\n        // ctx->cpp_context\n        auto osVal(getDBcontext(ctx)->getMetadata(key));\n        ctx->cpp_context->lastDbMetadataItem_ = osVal;\n        ctx->cpp_context->autoCloseDbIfNeeded();\n        return ctx->cpp_context->lastDbMetadataItem_.c_str();\n    } catch (const std::exception &e) {\n        proj_log_error(ctx, __FUNCTION__, e.what());\n        return nullptr;\n    }\n}",
        "start": 344,
         "end": 358
       },
    "proj-24": {
        "buggy":"PJ *PROJECTION(labrd) {\n    double Az, sinp, R, N, t;\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(pj_calloc (1, sizeof (struct pj_opaque)));\n    if (nullptr==Q)\n        return pj_default_destructor (P, ENOMEM);\n    P->opaque = Q;\n\n\n    Az = pj_param(P->ctx, P->params, \"razi\").f;\n    sinp = sin(P->phi0);\n    t = 1. - P->es * sinp * sinp;\n    N = 1. / sqrt(t);\n    R = P->one_es * N / t;\n    Q->kRg = P->k0 * sqrt( N * R );\n    Q->p0s = atan( sqrt(R / N) * tan(P->phi0) );\n    Q->A = sinp / sin(Q->p0s);\n    t = P->e * sinp;\n    Q->C = .5 * P->e * Q->A * log((1. + t)/(1. - t)) +\n          - Q->A * log( tan(M_FORTPI + .5 * P->phi0))\n          + log( tan(M_FORTPI + .5 * Q->p0s));\n    t = Az + Az;\n    Q->Ca = (1. - cos(t)) * ( Q->Cb = 1. / (12. * Q->kRg * Q->kRg) );\n    Q->Cb *= sin(t);\n    Q->Cc = 3. * (Q->Ca * Q->Ca - Q->Cb * Q->Cb);\n    Q->Cd = 6. * Q->Ca * Q->Cb;\n\n    P->inv = e_inverse;\n    P->fwd = e_forward;\n\n    return P;\n}",
        "start": 104,
         "end": 134
       },
    "proj-25": {
        "buggy":"std::vector<CoordinateOperationNNPtr>\nCoordinateOperationFactory::createOperations(\n    const crs::CRSNNPtr &sourceCRS, const crs::CRSNNPtr &targetCRS,\n    const CoordinateOperationContextNNPtr &context) const {\n\n#ifdef TRACE_CREATE_OPERATIONS\n    ENTER_FUNCTION();\n#endif\n    // Look if we are called on CRS that have a link to a 'canonical'\n    // BoundCRS\n    // If so, use that one as input\n    const auto &srcBoundCRS = sourceCRS->canonicalBoundCRS();\n    const auto &targetBoundCRS = targetCRS->canonicalBoundCRS();\n    auto l_sourceCRS = srcBoundCRS ? NN_NO_CHECK(srcBoundCRS) : sourceCRS;\n    auto l_targetCRS = targetBoundCRS ? NN_NO_CHECK(targetBoundCRS) : targetCRS;\n    const auto &authFactory = context->getAuthorityFactory();\n\n    metadata::ExtentPtr sourceCRSExtent;\n    auto l_resolvedSourceCRS =\n        crs::CRS::getResolvedCRS(l_sourceCRS, authFactory, sourceCRSExtent);\n    metadata::ExtentPtr targetCRSExtent;\n    auto l_resolvedTargetCRS =\n        crs::CRS::getResolvedCRS(l_targetCRS, authFactory, targetCRSExtent);\n    Private::Context contextPrivate(sourceCRSExtent, targetCRSExtent, context);\n\n    if (context->getSourceAndTargetCRSExtentUse() ==\n        CoordinateOperationContext::SourceTargetCRSExtentUse::INTERSECTION) {\n        if (sourceCRSExtent && targetCRSExtent &&\n            !sourceCRSExtent->intersects(NN_NO_CHECK(targetCRSExtent))) {\n            return std::vector<CoordinateOperationNNPtr>();\n        }\n    }\n\n    return filterAndSort(Private::createOperations(l_resolvedSourceCRS,\n                                                   l_resolvedTargetCRS,\n                                                   contextPrivate),\n                         context, sourceCRSExtent, targetCRSExtent);\n}",
        "start": 5326,
         "end": 5363
       },
    "proj-27": {
        "buggy":"ProjectedCRSNNPtr\nWKTParser::Private::buildProjectedCRS(const WKTNodeNNPtr &node) {\n\n    const auto *nodeP = node->GP();\n    auto &conversionNode = nodeP->lookForChild(WKTConstants::CONVERSION);\n    auto &projectionNode = nodeP->lookForChild(WKTConstants::PROJECTION);\n    if (isNull(conversionNode) && isNull(projectionNode)) {\n        ThrowMissing(WKTConstants::CONVERSION);\n    }\n\n    auto &baseGeodCRSNode =\n        nodeP->lookForChild(WKTConstants::BASEGEODCRS,\n                            WKTConstants::BASEGEOGCRS, WKTConstants::GEOGCS);\n    if (isNull(baseGeodCRSNode)) {\n        throw ParsingException(\n            \"Missing BASEGEODCRS / BASEGEOGCRS / GEOGCS node\");\n    }\n    auto baseGeodCRS = buildGeodeticCRS(baseGeodCRSNode);\n\n    auto props = buildProperties(node);\n\n    auto &csNode = nodeP->lookForChild(WKTConstants::CS_);\n    const auto &nodeValue = nodeP->value();\n    if (isNull(csNode) && !ci_equal(nodeValue, WKTConstants::PROJCS) &&\n        !ci_equal(nodeValue, WKTConstants::BASEPROJCRS)) {\n        ThrowMissing(WKTConstants::CS_);\n    }\n    auto cs = buildCS(csNode, node, UnitOfMeasure::NONE);\n    auto cartesianCS = nn_dynamic_pointer_cast<CartesianCS>(cs);\n\n    const std::string projCRSName = stripQuotes(nodeP->children()[0]);\n    if (esriStyle_ && dbContext_) {\n        // It is likely that the ESRI definition of EPSG:32661 (UPS North) &\n        // EPSG:32761 (UPS South) uses the easting-northing order, instead\n        // of the EPSG northing-easting order\n        // so don't substitue names to avoid confusion.\n        if (projCRSName == \"UPS_North\") {\n            props.set(IdentifiedObject::NAME_KEY, \"WGS 84 / UPS North (E,N)\");\n        } else if (projCRSName == \"UPS_South\") {\n            props.set(IdentifiedObject::NAME_KEY, \"WGS 84 / UPS South (E,N)\");\n        } else {\n            std::string outTableName;\n            std::string authNameFromAlias;\n            std::string codeFromAlias;\n            auto authFactory = AuthorityFactory::create(NN_NO_CHECK(dbContext_),\n                                                        std::string());\n            auto officialName = authFactory->getOfficialNameFromAlias(\n                projCRSName, \"projected_crs\", \"ESRI\", false, outTableName,\n                authNameFromAlias, codeFromAlias);\n            if (!officialName.empty()) {\n                // Special case for https://github.com/OSGeo/PROJ/issues/2086\n                // The name of the CRS to identify is\n                // NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501\n                // whereas it should be\n                // NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501_Feet\n                constexpr double US_FOOT_CONV_FACTOR = 12.0 / 39.37;\n                if (projCRSName.find(\"_FIPS_\") != std::string::npos &&\n                    projCRSName.find(\"_Feet\") == std::string::npos &&\n                    std::fabs(\n                        cartesianCS->axisList()[0]->unit().conversionToSI() -\n                        US_FOOT_CONV_FACTOR) < 1e-10 * US_FOOT_CONV_FACTOR) {\n                    auto officialNameFromFeet =\n                        authFactory->getOfficialNameFromAlias(\n                            projCRSName + \"_Feet\", \"projected_crs\", \"ESRI\",\n                            false, outTableName, authNameFromAlias,\n                            codeFromAlias);\n                    if (!officialNameFromFeet.empty()) {\n                        officialName = officialNameFromFeet;\n                    }\n                }\n\n                props.set(IdentifiedObject::NAME_KEY, officialName);\n            }\n        }\n    }\n\n    if (isNull(conversionNode) && hasWebMercPROJ4String(node, projectionNode)) {\n        toWGS84Parameters_.clear();\n        return createPseudoMercator(props);\n    }\n\n    // WGS_84_Pseudo_Mercator: Particular case for corrupted ESRI WKT generated\n    // by older GDAL versions\n    // https://trac.osgeo.org/gdal/changeset/30732\n    // WGS_1984_Web_Mercator: deprecated ESRI:102113\n    if (metadata::Identifier::isEquivalentName(projCRSName.c_str(),\n                                               \"WGS_84_Pseudo_Mercator\") ||\n        metadata::Identifier::isEquivalentName(projCRSName.c_str(),\n                                               \"WGS_1984_Web_Mercator\")) {\n        toWGS84Parameters_.clear();\n        return createPseudoMercator(props);\n    }\n\n    auto linearUnit = buildUnitInSubNode(node, UnitOfMeasure::Type::LINEAR);\n    auto angularUnit = baseGeodCRS->coordinateSystem()->axisList()[0]->unit();\n\n    auto conversion =\n        !isNull(conversionNode)\n            ? buildConversion(conversionNode, linearUnit, angularUnit)\n            : buildProjection(node, projectionNode, linearUnit, angularUnit);\n\n    // No explicit AXIS node ? (WKT1)\n    if (isNull(nodeP->lookForChild(WKTConstants::AXIS))) {\n        props.set(\"IMPLICIT_CS\", true);\n    }\n\n    if (isNull(csNode) && node->countChildrenOfName(WKTConstants::AXIS) == 0) {\n\n        const auto methodCode = conversion->method()->getEPSGCode();\n        // Krovak south oriented ?\n        if (methodCode == EPSG_CODE_METHOD_KROVAK) {\n            cartesianCS =\n                CartesianCS::create(\n                    PropertyMap(),\n                    CoordinateSystemAxis::create(\n                        util::PropertyMap().set(IdentifiedObject::NAME_KEY,\n                                                AxisName::Southing),\n                        emptyString, AxisDirection::SOUTH, linearUnit),\n                    CoordinateSystemAxis::create(\n                        util::PropertyMap().set(IdentifiedObject::NAME_KEY,\n                                                AxisName::Westing),\n                        emptyString, AxisDirection::WEST, linearUnit))\n                    .as_nullable();\n        } else if (methodCode ==\n                       EPSG_CODE_METHOD_POLAR_STEREOGRAPHIC_VARIANT_A ||\n                   methodCode ==\n                       EPSG_CODE_METHOD_LAMBERT_AZIMUTHAL_EQUAL_AREA) {\n            // It is likely that the ESRI definition of EPSG:32661 (UPS North) &\n            // EPSG:32761 (UPS South) uses the easting-northing order, instead\n            // of the EPSG northing-easting order.\n            // Same for WKT1_GDAL\n            const double lat0 = conversion->parameterValueNumeric(\n                EPSG_CODE_PARAMETER_LATITUDE_OF_NATURAL_ORIGIN,\n                common::UnitOfMeasure::DEGREE);\n            if (std::fabs(lat0 - 90) < 1e-10) {\n                cartesianCS =\n                    CartesianCS::createNorthPoleEastingSouthNorthingSouth(\n                        linearUnit)\n                        .as_nullable();\n            } else if (std::fabs(lat0 - -90) < 1e-10) {\n                cartesianCS =\n                    CartesianCS::createSouthPoleEastingNorthNorthingNorth(\n                        linearUnit)\n                        .as_nullable();\n            }\n        } else if (methodCode ==\n                   EPSG_CODE_METHOD_POLAR_STEREOGRAPHIC_VARIANT_B) {\n            const double lat_ts = conversion->parameterValueNumeric(\n                EPSG_CODE_PARAMETER_LATITUDE_STD_PARALLEL,\n                common::UnitOfMeasure::DEGREE);\n            if (lat_ts > 0) {\n                cartesianCS =\n                    CartesianCS::createNorthPoleEastingSouthNorthingSouth(\n                        linearUnit)\n                        .as_nullable();\n            } else if (lat_ts < 0) {\n                cartesianCS =\n                    CartesianCS::createSouthPoleEastingNorthNorthingNorth(\n                        linearUnit)\n                        .as_nullable();\n            }\n        } else if (methodCode ==\n                   EPSG_CODE_METHOD_TRANSVERSE_MERCATOR_SOUTH_ORIENTATED) {\n            cartesianCS =\n                CartesianCS::createWestingSouthing(linearUnit).as_nullable();\n        }\n    }\n    if (!cartesianCS) {\n        ThrowNotExpectedCSType(\"Cartesian\");\n    }\n\n\n    addExtensionProj4ToProp(nodeP, props);\n\n    return ProjectedCRS::create(props, baseGeodCRS, conversion,\n                                NN_NO_CHECK(cartesianCS));\n}",
        "start": 3671,
         "end": 3847
       },
    "proj-28": {
        "buggy":"static PJ_XY stere_e_forward (PJ_LP lp, PJ *P) {          /* Ellipsoidal, forward */\n    PJ_XY xy = {0.0,0.0};\n    struct pj_opaque *Q = static_cast<struct pj_opaque*>(P->opaque);\n    double coslam, sinlam, sinX = 0.0, cosX = 0.0, A = 0.0, sinphi;\n\n    coslam = cos (lp.lam);\n    sinlam = sin (lp.lam);\n    sinphi = sin (lp.phi);\n    if (Q->mode == OBLIQ || Q->mode == EQUIT) {\n        const double X = 2. * atan(ssfn_(lp.phi, sinphi, P->e)) - M_HALFPI;\n        sinX = sin (X);\n        cosX = cos (X);\n    }\n\n    switch (Q->mode) {\n    case OBLIQ: {\n        const double denom = Q->cosX1 * (1. + Q->sinX1 * sinX +\n           Q->cosX1 * cosX * coslam);\n        if( denom == 0 ) {\n            proj_errno_set(P, PJD_ERR_TOLERANCE_CONDITION);\n            return proj_coord_error().xy;\n        }\n        A = Q->akm1 / denom;\n        xy.y = A * (Q->cosX1 * sinX - Q->sinX1 * cosX * coslam);\n        xy.x = A * cosX;\n        break;\n    }\n\n    case EQUIT:\n        /* avoid zero division */\n        if (1. + cosX * coslam == 0.0) {\n            xy.y = HUGE_VAL;\n        } else {\n            A = Q->akm1 / (1. + cosX * coslam);\n            xy.y = A * sinX;\n        }\n        xy.x = A * cosX;\n        break;\n\n    case S_POLE:\n        lp.phi = -lp.phi;\n        coslam = - coslam;\n        sinphi = -sinphi;\n        /*-fallthrough*/\n    case N_POLE:\n        xy.x = Q->akm1 * pj_tsfn (lp.phi, sinphi, P->e);\n        xy.y = - xy.x * coslam;\n        break;\n    }\n\n    xy.x = xy.x * sinlam;\n    return xy;\n}",
        "start": 44,
         "end": 96
       },
    "wireshark-1": {
        "buggy":"static void\nuinteger_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display, char *buf, unsigned int size)\n{\n\tif ((field_display == BASE_HEX) || (field_display == BASE_HEX_DEC))\n\t{\n\t\t/* This format perfectly fits into 11 bytes. */\n\t\t*buf++ = '0';\n\t\t*buf++ = 'x';\n\n\n\n\n\n\n\t\tbuf = dword_to_hex(buf, fv->value.uinteger);\n\t\t*buf++ = '\\0';\n\t}\n\telse\n\t{\n\t\tguint32_to_str_buf(fv->value.uinteger, buf, size);\n\t}\n}",
        "start": 420,
         "end": 441
       },
    "wireshark-2": {
        "buggy":"WSLUA_METAMETHOD TvbRange__tostring(lua_State* L) {\n    /* Converts the `TvbRange` into a string. Since the string gets truncated,\n       you should use this only for debugging purposes\n       or if what you want is to have a truncated string in the format 67:89:AB:... */\n    TvbRange tvbr = checkTvbRange(L,1);\n    char* str = NULL;\n\n    if (!(tvbr && tvbr->tvb)) return 0;\n    if (tvbr->tvb->expired) {\n        luaL_error(L,\"expired tvb\");\n        return 0;\n    }\n\n    str = tvb_bytes_to_str(NULL,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len);\n    lua_pushstring(L,str);\n    wmem_free(NULL, str);\n\n    WSLUA_RETURN(1); /* A Lua hex string of the first 24 binary bytes in the `TvbRange`. */\n}",
        "start": 1389,
         "end": 1407
       },
    "wireshark-5": {
        "buggy":"static void\nek_write_attr(GSList *attr_instances, write_json_data *pdata)\n{\n    GSList *current_node = attr_instances;\n    proto_node *pnode    = (proto_node *) current_node->data;\n    field_info *fi       = PNODE_FINFO(pnode);\n\n    // Hex dump -x\n    if (pdata->print_hex && fi && fi->length > 0 && fi->hfinfo->id != hf_text_only) {\n        ek_write_attr_hex(attr_instances, pdata);\n    }\n\n    // Print attr name\n    ek_write_name(pnode, NULL, pdata);\n\n    if (g_slist_length(attr_instances) > 1) {\n        json_dumper_begin_array(pdata->dumper);\n    }\n\n    while (current_node != NULL) {\n        pnode = (proto_node *) current_node->data;\n        fi    = PNODE_FINFO(pnode);\n\n        /* Field */\n        if (fi->hfinfo->type != FT_PROTOCOL) {\n            if (pdata->filter != NULL\n                && !ek_check_protocolfilter(pdata->filter, fi->hfinfo->abbrev)) {\n\n                /* print dummy field */\n                json_dumper_set_member_name(pdata->dumper, \"filtered\");\n                json_dumper_value_string(pdata->dumper, fi->hfinfo->abbrev);\n            } else {\n                ek_write_field_value(fi, pdata);\n            }\n        } else {\n            /* Object */\n            json_dumper_begin_object(pdata->dumper);\n\n            if (pdata->filter != NULL) {\n                if (ek_check_protocolfilter(pdata->filter, fi->hfinfo->abbrev)) {\n                    gchar **_filter = NULL;\n                    /* Remove protocol filter for children, if children should be included */\n                    if ((pdata->filter_flags&PF_INCLUDE_CHILDREN) == PF_INCLUDE_CHILDREN) {\n                        _filter = pdata->filter;\n                        pdata->filter = NULL;\n                    }\n\n                    proto_tree_write_node_ek(pnode, pdata);\n\n                    /* Put protocol filter back */\n                    if ((pdata->filter_flags&PF_INCLUDE_CHILDREN) == PF_INCLUDE_CHILDREN) {\n                        pdata->filter = _filter;\n                    }\n                } else {\n                    /* print dummy field */\n                    json_dumper_set_member_name(pdata->dumper, \"filtered\");\n                    json_dumper_value_string(pdata->dumper, fi->hfinfo->abbrev);\n                }\n            } else {\n                proto_tree_write_node_ek(pnode, pdata);\n            }\n\n            json_dumper_end_object(pdata->dumper);\n        }\n\n        current_node = current_node->next;\n    }\n\n    if (g_slist_length(attr_instances) > 1) {\n        json_dumper_end_array(pdata->dumper);\n    }\n}",
        "start": 1341,
         "end": 1412
       },
    "wireshark-6": {
        "buggy":"WSLUA_METHOD ByteArray_base64_decode(lua_State* L) {\n    /* Obtain a Base64 decoded <<lua_class_ByteArray,`ByteArray`>>.\n\n       @since 1.11.3\n     */\n    ByteArray ba = checkByteArray(L,1);\n    ByteArray ba2;\n    gchar *data;\n\n    gsize len;\n\n    ba2 = g_byte_array_new();\n    if (ba->len > 1) {\n        data = (gchar*)g_malloc(ba->len + 1);\n        memcpy(data, ba->data, ba->len);\n        data[ba->len] = '\\0';\n\n        g_base64_decode_inplace(data, &len);\n        g_byte_array_append(ba2, data, (int)len);\n        g_free(data);\n    }\n\n    pushByteArray(L,ba2);\n    WSLUA_RETURN(1); /* The created <<lua_class_ByteArray,`ByteArray`>>. */\n}",
        "start": 254,
         "end": 278
       },
    "xbps-1": {
        "buggy":"static int\ncollect_file(struct xbps_handle *xhp, const char *file, size_t size,\n\t\tconst char *pkgname, const char *pkgver, unsigned int idx,\n\t\tconst char *sha256, enum type type, bool update, bool removepkg,\n\t\tbool preserve, bool removefile, const char *target)\n{\n\tstruct item *item;\n\n\tassert(file);\n\n\tif ((item = lookupItem(file)) == NULL) {\n\t\titem = addItem(file);\n\t\tif (item == NULL)\n\t\t\treturn ENOMEM;\n\t\titem->deleted = false;\n\t\tgoto add;\n\t}\n\n\tif (removefile) {\n\t\tif (item->old.type == 0) {\n\t\t\t/*\n\t\t\t * File wasn't removed before.\n\t\t\t */\n\t\t} else if (type == TYPE_DIR && item->old.type == TYPE_DIR) {\n\t\t\t/*\n\t\t\t * Multiple packages removing the same directory.\n\t\t\t * Record the last package to remove this directory.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Multiple packages removing the same file.\n\t\t\t * Shouldn't happen, but its not fatal.\n\t\t\t */\n\t\t\txbps_dbg_printf(xhp, \"[files] %s: file already removed\"\n\t\t\t    \" by package `%s': %s\\n\", pkgver, item->old.pkgver, file);\n\n\t\t\t/*\n\t\t\t * Check if `preserve` is violated.\n\t\t\t */\n\t\t\tif (item->old.preserve && !preserve) {\n\t\t\t\txbps_set_cb_state(xhp, XBPS_STATE_FILES_FAIL,\n\t\t\t\t    EPERM, item->old.pkgver,\n\t\t\t\t    \"%s: preserved file `%s' removed by %s.\",\n\t\t\t\t    item->old.pkgver, file, pkgver);\n\t\t\t\treturn EPERM;\n\t\t\t} else if (preserve && !item->old.preserve) {\n\t\t\t\txbps_set_cb_state(xhp, XBPS_STATE_FILES_FAIL,\n\t\t\t\t    EPERM, pkgver,\n\t\t\t\t    \"%s: preserved file `%s' removed by %s.\",\n\t\t\t\t    pkgver, file, item->old.pkgver);\n\t\t\t\treturn EPERM;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tgoto add;\n\t} else {\n\t\t/*\n\t\t * Multiple packages creating the same directory.\n\t\t */\n\t\tif (item->new.type == 0) {\n\t\t\t/*\n\t\t\t * File wasn't created before.\n\t\t\t */\n\t\t} else if (type == TYPE_DIR && item->new.type == TYPE_DIR) {\n\t\t\t/*\n\t\t\t * Multiple packages creating the same directory.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Multiple packages creating the same file.\n\t\t\t * This should never happen in a transaction.\n\t\t\t */\n\t\t\txbps_set_cb_state(xhp, XBPS_STATE_FILES_FAIL,\n\t\t\t    EEXIST, pkgver,\n\t\t\t    \"%s: file `%s' already installed by package %s.\",\n\t\t\t    pkgver, file, item->new.pkgver);\n\t\t\tif (xhp->flags & XBPS_FLAG_IGNORE_FILE_CONFLICTS)\n\t\t\t\treturn 0;\n\n\t\t\treturn EEXIST;\n\t\t}\n\t\tgoto add;\n\t}\n\n\treturn 0;\nadd:\n\tif (removefile) {\n\t\titem->old.pkgname = pkgname;\n\t\titem->old.pkgver = pkgver;\n\t\titem->old.type = type;\n\t\titem->old.size = size;\n\t\titem->old.index = idx;\n\t\titem->old.preserve = preserve;\n\t\titem->old.update = update;\n\t\titem->old.removepkg = removepkg;\n\t\titem->old.target = target;\n\t\tif (sha256)\n\t\t\titem->old.sha256 = strdup(sha256);\n\t} else {\n\t\titem->new.pkgname = pkgname;\n\t\titem->new.pkgver = pkgver;\n\t\titem->new.type = type;\n\t\titem->new.size = size;\n\t\titem->new.index = idx;\n\t\titem->new.preserve = preserve;\n\t\titem->new.update = update;\n\t\titem->new.removepkg = removepkg;\n\t\titem->new.target = target;\n\t}\n\tif (item->old.type && item->new.type) {\n\t\t/*\n\t\t * The file was removed by one package\n\t\t * and installed by another package.\n\t\t */\n\t\tif (strcmp(item->new.pkgname, item->old.pkgname) != 0) {\n\t\t\tif (removefile) {\n\t\t\t\txbps_dbg_printf(xhp, \"[files] %s: %s moved to\"\n\t\t\t\t    \" package `%s': %s\\n\", pkgver, typestr(item->old.type),\n\t\t\t\t    item->new.pkgver, file);\n\t\t\t} else {\n\t\t\t\txbps_dbg_printf(xhp, \"[files] %s: %s moved from\"\n\t\t\t\t    \" package `%s': %s\\n\", pkgver, typestr(item->new.type),\n\t\t\t\t    item->old.pkgver, file);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "start": 420,
         "end": 550
       },
    "xbps-3": {
        "buggy":"bool HIDDEN\nxbps_transaction_check_revdeps(struct xbps_handle *xhp, xbps_array_t pkgs)\n{\n\txbps_array_t mdeps;\n\tbool error = false;\n\n\tmdeps = xbps_dictionary_get(xhp->transd, \"missing_deps\");\n\n\tfor (unsigned int i = 0; i < xbps_array_count(pkgs); i++) {\n\t\txbps_array_t pkgrdeps, rundeps;\n\t\txbps_dictionary_t revpkgd;\n\t\txbps_object_t obj;\n\t\txbps_trans_type_t ttype;\n\t\tconst char *pkgver = NULL, *revpkgver = NULL;\n\t\tchar pkgname[XBPS_NAME_SIZE] = {0};\n\n\t\tobj = xbps_array_get(pkgs, i);\n\t\t/*\n\t\t * If pkg is on hold, pass to the next one.\n\t\t */\n\t\tttype = xbps_transaction_pkg_type(obj);\n\t\tif (ttype == XBPS_TRANS_HOLD) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!xbps_dictionary_get_cstring_nocopy(obj, \"pkgver\", &pkgver)) {\n\t\t\terror = true;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!xbps_pkg_name(pkgname, sizeof(pkgname), pkgver)) {\n\t\t\terror = true;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * if pkg in transaction is not installed,\n\t\t * pass to next one.\n\t\t */\n\t\tif (xbps_pkg_is_installed(xhp, pkgname) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If pkg is installed but does not have revdeps,\n\t\t * pass to next one.\n\t\t */\n\t\tpkgrdeps = xbps_pkgdb_get_pkg_revdeps(xhp, pkgname);\n\t\tif (!xbps_array_count(pkgrdeps)) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If pkg is ignored, pass to the next one.\n\t\t */\n\t\tif (xbps_pkg_is_ignored(xhp, pkgver)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Time to validate revdeps for current pkg.\n\t\t */\n\t\tfor (unsigned int x = 0; x < xbps_array_count(pkgrdeps); x++) {\n\t\t\tconst char *curpkgver = NULL;\n\t\t\tchar curdepname[XBPS_NAME_SIZE] = {0};\n\t\t\tchar curpkgname[XBPS_NAME_SIZE] = {0};\n\t\t\tbool found = false;\n\n\t\t\tif (!xbps_array_get_cstring_nocopy(pkgrdeps, x, &curpkgver)) {\n\t\t\t\terror = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!xbps_pkg_name(pkgname, sizeof(pkgname), curpkgver)) {\n\t\t\t\terror = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif ((revpkgd = xbps_find_pkg_in_array(pkgs, pkgname, 0))) {\n\t\t\t\tttype = xbps_transaction_pkg_type(revpkgd);\n\t\t\t\tif (ttype == XBPS_TRANS_REMOVE)\n\t\t\t\t\trevpkgd = NULL;\n\t\t\t}\n\t\t\tif (revpkgd == NULL)\n\t\t\t\trevpkgd = xbps_pkgdb_get_pkg(xhp, curpkgver);\n\n\n\t\t\txbps_dictionary_get_cstring_nocopy(revpkgd, \"pkgver\", &revpkgver);\n\t\t\t/*\n\t\t\t * If target pkg is being removed, all its revdeps\n\t\t\t * will be broken unless those revdeps are also in\n\t\t\t * the transaction.\n\t\t\t */\n\t\t\tif (ttype == XBPS_TRANS_REMOVE) {\n\t\t\t\tif (xbps_dictionary_get(obj, \"replaced\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (xbps_find_pkg_in_array(pkgs, pkgname, XBPS_TRANS_REMOVE)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbroken_pkg(mdeps, curpkgver, pkgver);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * First try to match any supported virtual package.\n\t\t\t */\n\t\t\tif (check_virtual_pkgs(mdeps, obj, revpkgd)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Try to match real dependencies.\n\t\t\t */\n\t\t\trundeps = xbps_dictionary_get(revpkgd, \"run_depends\");\n\t\t\t/*\n\t\t\t * Find out what dependency is it.\n\t\t\t */\n\t\t\tif (!xbps_pkg_name(curpkgname, sizeof(curpkgname), pkgver)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (unsigned int j = 0; j < xbps_array_count(rundeps); j++) {\n\t\t\t\tconst char *curdep;\n\n\t\t\t\txbps_array_get_cstring_nocopy(rundeps, j, &curdep);\n\t\t\t\tif ((!xbps_pkgpattern_name(curdepname, sizeof(curdepname), curdep)) &&\n\t\t\t\t    (!xbps_pkg_name(curdepname, sizeof(curdepname), curdep))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (strcmp(curdepname, curpkgname) == 0) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (xbps_match_pkgdep_in_array(rundeps, pkgver)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Installed package conflicts with package\n\t\t\t * in transaction being updated, check\n\t\t\t * if a new version of this conflicting package\n\t\t\t * is in the transaction.\n\t\t\t */\n\t\t\tif (xbps_find_pkg_in_array(pkgs, pkgname, XBPS_TRANS_UPDATE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbroken_pkg(mdeps, curpkgver, pkgver);\n\t\t}\n\t}\nout:\n\tif (!error) {\n\t\tmdeps = xbps_dictionary_get(xhp->transd, \"missing_deps\");\n\t\tif (xbps_array_count(mdeps) == 0)\n\t\t\txbps_dictionary_remove(xhp->transd, \"missing_deps\");\n\t}\n\treturn error ? false : true;\n}",
        "start": 103,
         "end": 258
       },
    "xbps-5": {
        "buggy":"void HIDDEN\nxbps_transaction_revdeps(struct xbps_handle *xhp, xbps_array_t pkgs)\n{\n\txbps_array_t mdeps;\n\n\tmdeps = xbps_dictionary_get(xhp->transd, \"missing_deps\");\n\n\tfor (unsigned int i = 0; i < xbps_array_count(pkgs); i++) {\n\t\txbps_array_t pkgrdeps;\n\t\txbps_object_t obj;\n\t\tconst char *pkgver, *tract;\n\t\tchar *pkgname;\n\n\t\tobj = xbps_array_get(pkgs, i);\n\t\t/*\n\t\t * if pkg in transaction is not installed,\n\t\t * pass to next one.\n\t\t */\n\t\txbps_dictionary_get_cstring_nocopy(obj, \"pkgver\", &pkgver);\n\t\txbps_dictionary_get_cstring_nocopy(obj, \"transaction\", &tract);\n\n\t\t/*\n\t\t * If pkg is on hold, pass to the next one.\n\t\t */\n\t\tif (strcmp(tract, \"hold\") == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpkgname = xbps_pkg_name(pkgver);\n\t\tassert(pkgname);\n\t\tif (xbps_pkg_is_installed(xhp, pkgname) == 0) {\n\t\t\tfree(pkgname);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If pkg is installed but does not have revdeps,\n\t\t * pass to next one.\n\t\t */\n\t\tpkgrdeps = xbps_pkgdb_get_pkg_revdeps(xhp, pkgname);\n\t\tif (!xbps_array_count(pkgrdeps)) {\n\t\t\tfree(pkgname);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If pkg is ignored, pass to the next one.\n\t\t */\n\t\tfree(pkgname);\n\t\tif (xbps_pkg_is_ignored(xhp, pkgver)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Time to validate revdeps for current pkg.\n\t\t */\n\t\tfor (unsigned int x = 0; x < xbps_array_count(pkgrdeps); x++) {\n\t\t\txbps_array_t rundeps;\n\t\t\txbps_dictionary_t revpkgd;\n\t\t\tconst char *curpkgver = NULL, *revpkgver, *curdep = NULL, *curtract;\n\t\t\tchar *curpkgname, *curdepname;\n\t\t\tbool found = false;\n\n\t\t\txbps_array_get_cstring_nocopy(pkgrdeps, x, &curpkgver);\n\t\t\tpkgname = xbps_pkg_name(curpkgver);\n\t\t\tassert(pkgname);\n\t\t\tif ((revpkgd = xbps_find_pkg_in_array(pkgs, pkgname, NULL))) {\n\t\t\t\txbps_dictionary_get_cstring_nocopy(revpkgd, \"transaction\", &curtract);\n\t\t\t\tif (strcmp(curtract, \"remove\") == 0)\n\t\t\t\t\trevpkgd = NULL;\n\t\t\t}\n\t\t\tif (revpkgd == NULL)\n\t\t\t\trevpkgd = xbps_pkgdb_get_pkg(xhp, curpkgver);\n\n\t\t\txbps_dictionary_get_cstring_nocopy(revpkgd, \"pkgver\", &revpkgver);\n\t\t\t/*\n\t\t\t * If target pkg is being removed, all its revdeps\n\t\t\t * will be broken unless those revdeps are also in\n\t\t\t * the transaction.\n\t\t\t */\n\t\t\tif (strcmp(tract, \"remove\") == 0) {\n\t\t\t\tif (xbps_dictionary_get(obj, \"replaced\")) {\n\t\t\t\t\tfree(pkgname);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (xbps_find_pkg_in_array(pkgs, pkgname, \"remove\")) {\n\t\t\t\t\tfree(pkgname);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree(pkgname);\n\t\t\t\tbroken_pkg(mdeps, curpkgver, pkgver, tract);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * First try to match any supported virtual package.\n\t\t\t */\n\t\t\tif (check_virtual_pkgs(mdeps, obj, revpkgd)) {\n\t\t\t\tfree(pkgname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Try to match real dependencies.\n\t\t\t */\n\t\t\trundeps = xbps_dictionary_get(revpkgd, \"run_depends\");\n\t\t\t/*\n\t\t\t * Find out what dependency is it.\n\t\t\t */\n\t\t\tcurpkgname = xbps_pkg_name(pkgver);\n\t\t\tassert(curpkgname);\n\n\t\t\tfor (unsigned int j = 0; j < xbps_array_count(rundeps); j++) {\n\t\t\t\txbps_array_get_cstring_nocopy(rundeps, j, &curdep);\n\t\t\t\tif (((curdepname = xbps_pkg_name(curdep)) == NULL) &&\n\t\t\t\t    ((curdepname = xbps_pkgpattern_name(curdep)) == NULL))\n\t\t\t\t\tabort();\n\n\t\t\t\tif (strcmp(curdepname, curpkgname) == 0) {\n\t\t\t\t\tfree(curdepname);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(curdepname);\n\t\t\t}\n\t\t\tfree(curpkgname);\n\n\t\t\tif (!found) {\n\t\t\t\tfree(pkgname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (xbps_match_pkgdep_in_array(rundeps, pkgver)) {\n\t\t\t\tfree(pkgname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Installed package conflicts with package\n\t\t\t * in transaction being updated, check\n\t\t\t * if a new version of this conflicting package\n\t\t\t * is in the transaction.\n\t\t\t */\n\t\t\tfree(pkgname);\n\t\t\tbroken_pkg(mdeps, curpkgver, pkgver, tract);\n\t\t}\n\n\t}\n}",
        "start": 104,
         "end": 246
       },
    "yara-1": {
        "buggy":"int yr_parser_reduce_rule_declaration_phase_1(\n    yyscan_t yyscanner,\n    int32_t flags,\n    const char* identifier,\n    YR_RULE** rule)\n{\n  YR_FIXUP *fixup;\n  YR_INIT_RULE_ARGS *init_rule_args;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  *rule = NULL;\n\n  if (yr_hash_table_lookup(\n        compiler->rules_table,\n        identifier,\n        compiler->current_namespace->name) != NULL ||\n      yr_hash_table_lookup(\n        compiler->objects_table,\n        identifier,\n        compiler->current_namespace->name) != NULL)\n  {\n    // A rule or variable with the same identifier already exists, return the\n    // appropriate error.\n\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    return ERROR_DUPLICATED_IDENTIFIER;\n  }\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->rules_arena,\n      sizeof(YR_RULE),\n      (void**) rule,\n      offsetof(YR_RULE, identifier),\n      offsetof(YR_RULE, tags),\n      offsetof(YR_RULE, strings),\n      offsetof(YR_RULE, metas),\n      offsetof(YR_RULE, ns),\n      EOL))\n\n  (*rule)->g_flags = flags;\n  (*rule)->ns = compiler->current_namespace;\n\n  #ifdef PROFILING_ENABLED\n  rule->time_cost = 0;\n  #endif\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      (char**) &(*rule)->identifier));\n\n  FAIL_ON_ERROR(yr_parser_emit(\n      yyscanner,\n      OP_INIT_RULE,\n      NULL));\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->code_arena,\n      sizeof(YR_INIT_RULE_ARGS),\n      (void**) &init_rule_args,\n      offsetof(YR_INIT_RULE_ARGS, rule),\n      offsetof(YR_INIT_RULE_ARGS, jmp_addr),\n      EOL));\n\n  init_rule_args->rule = *rule;\n\n  // jmp_addr holds the address to jump to when we want to skip the code for\n  // the rule. It is iniatialized as NULL at this point because we don't know\n  // the address until emmiting the code for the rule's condition. The address\n  // is set in yr_parser_reduce_rule_declaration_phase_2.\n  init_rule_args->jmp_addr = NULL;\n\n  // Create a fixup entry for the jump and push it in the stack\n  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n  if (fixup == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  fixup->address = (void*) &(init_rule_args->jmp_addr);\n  fixup->next = compiler->fixup_stack_head;\n  compiler->fixup_stack_head = fixup;\n\n  // Clean strings_table as we are starting to parse a new rule.\n  yr_hash_table_clean(compiler->strings_table, NULL);\n\n  FAIL_ON_ERROR(yr_hash_table_add(\n      compiler->rules_table,\n      identifier,\n      compiler->current_namespace->name,\n      (void*) *rule));\n\n  compiler->current_rule = *rule;\n\n  return ERROR_SUCCESS;\n}",
        "start": 714,
         "end": 808
       },
    "yara-2": {
        "buggy":"static int _yr_scan_wicompare(\n    const uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  const uint8_t* s1 = data;\n  const uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1] == yr_lowercase[*s2])\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}",
        "start": 185,
         "end": 207
       },
    "zsh-1": {
        "buggy":"LinkList\ngetoutput(char *cmd, int qt)\n{\n    Eprog prog;\n    int pipes[2];\n    pid_t pid;\n    char *s;\n\n    int onc = nocomments;\n    nocomments = (interact && unset(INTERACTIVECOMMENTS));\n    prog = parse_string(cmd, 0);\n    nocomments = onc;\n\n    if (!prog)\n\treturn NULL;\n\n    if ((s = simple_redir_name(prog, REDIR_READ))) {\n\t/* $(< word) */\n\tint stream;\n\tLinkList retval;\n\tint readerror;\n\n\tsingsub(&s);\n\tif (errflag)\n\t    return NULL;\n\tuntokenize(s);\n\tif ((stream = open(unmeta(s), O_RDONLY | O_NOCTTY)) == -1) {\n\t    zwarn(\"%e: %s\", errno, s);\n\t    lastval = cmdoutval = 1;\n\t    return newlinklist();\n\t}\n\tretval = readoutput(stream, qt, &readerror);\n\tif (readerror) {\n\t  zwarn(\"error when reading %s: %e\", s, readerror);\n\t  lastval = cmdoutval = 1;\n\t}\n\treturn retval;\n    }\n    if (mpipe(pipes) < 0) {\n\terrflag |= ERRFLAG_ERROR;\n\tcmdoutpid = 0;\n\treturn NULL;\n    }\n    child_block();\n    cmdoutval = 0;\n    if ((cmdoutpid = pid = zfork(NULL)) == -1) {\n\t/* fork error */\n\tzclose(pipes[0]);\n\tzclose(pipes[1]);\n\terrflag |= ERRFLAG_ERROR;\n\tcmdoutpid = 0;\n\tchild_unblock();\n\treturn NULL;\n    } else if (pid) {\n\tLinkList retval;\n\n\tzclose(pipes[1]);\n\tretval = readoutput(pipes[0], qt, NULL);\n\tfdtable[pipes[0]] = FDT_UNUSED;\n\twaitforpid(pid, 0);\t\t/* unblocks */\n\tlastval = cmdoutval;\n\treturn retval;\n    }\n    /* pid == 0 */\n    child_unblock();\n    zclose(pipes[0]);\n    redup(pipes[1], 1);\n    entersubsh(ESUB_PGRP|ESUB_NOMONITOR, NULL);\n    cmdpush(CS_CMDSUBST);\n    execode(prog, 0, 1, \"cmdsubst\");\n    cmdpop();\n    close(1);\n    _realexit();\n    zerr(\"exit returned in child!!\");\n    kill(getpid(), SIGKILL);\n    return NULL;\n}",
        "start": 4616,
         "end": 4692
       },
    "zsh-3": {
        "buggy":"static int\npar_cond_2(void)\n{\n    char *s1, *s2, *s3;\n    int dble = 0;\n    int n_testargs = (condlex == testlex) ? arrlen(testargs) + 1 : 0;\n\n    if (n_testargs) {\n\t/* See the description of test in POSIX 1003.2 */\n\tif (tok == NULLTOK)\n\t    /* no arguments: false */\n\t    return par_cond_double(dupstring(\"-n\"), dupstring(\"\"));\n\tif (n_testargs == 1) {\n\t    /* one argument: [ foo ] is equivalent to [ -n foo ] */\n\t    s1 = tokstr;\n\t    condlex();\n\t    /* ksh behavior: [ -t ] means [ -t 1 ]; bash disagrees */\n\t    if (unset(POSIXBUILTINS) && check_cond(s1, \"t\"))\n\t\treturn par_cond_double(s1, dupstring(\"1\"));\n\t    return par_cond_double(dupstring(\"-n\"), s1);\n\t}\n\tif (n_testargs > 2) {\n\t    /* three arguments: if the second argument is a binary operator, *\n\t     * perform that binary test on the first and the third argument  */\n\t    if (!strcmp(*testargs, \"=\")  ||\n\t\t!strcmp(*testargs, \"==\") ||\n\t\t!strcmp(*testargs, \"!=\") ||\n\t\t(IS_DASH(**testargs) && get_cond_num(*testargs + 1) >= 0)) {\n\t\ts1 = tokstr;\n\t\tcondlex();\n\t\ts2 = tokstr;\n\t\tcondlex();\n\t\ts3 = tokstr;\n\t\tcondlex();\n\t\treturn par_cond_triple(s1, s2, s3);\n\t    }\n\t}\n\t/*\n\t * We fall through here on any non-numeric infix operator\n\t * or any other time there are at least two arguments.\n\t */\n    } else\n\twhile (COND_SEP())\n\t    condlex();\n    if (tok == BANG) {\n\t/*\n\t * In \"test\" compatibility mode, \"! -a ...\" and \"! -o ...\"\n\t * are treated as \"[string] [and] ...\" and \"[string] [or] ...\".\n\t */\n\tif (!(n_testargs > 1 && (check_cond(*testargs, \"a\") ||\n\t\t\t\t check_cond(*testargs, \"o\"))))\n\t{\n\t    condlex();\n\t    ecadd(WCB_COND(COND_NOT, 0));\n\t    return par_cond_2();\n\t}\n    }\n    if (tok == INPAR) {\n\tint r;\n\n\tcondlex();\n\twhile (COND_SEP())\n\t    condlex();\n\tr = par_cond();\n\twhile (COND_SEP())\n\t    condlex();\n\tif (tok != OUTPAR)\n\t    YYERROR(ecused);\n\tcondlex();\n\treturn r;\n    }\n    s1 = tokstr;\n    dble = (s1 && IS_DASH(*s1)\n\t    && (!n_testargs\n\t\t|| strspn(s1+1, \"abcdefghknoprstuvwxzLONGS\") == 1)\n\t    && !s1[2]);\n    if (tok != STRING) {\n\t/* Check first argument for [[ STRING ]] re-interpretation */\n\tif (s1 /* tok != DOUTBRACK && tok != DAMPER && tok != DBAR */\n\t    && tok != LEXERR && (!dble || n_testargs)) {\n\t    do condlex(); while (COND_SEP());\n\t    return par_cond_double(dupstring(\"-n\"), s1);\n\t} else\n\t    YYERROR(ecused);\n    }\n    condlex();\n    if (n_testargs == 2 && tok != STRING && tokstr && IS_DASH(s1[0])) {\n\t/*\n\t * Something like \"test -z\" followed by a token.\n\t * We'll turn the token into a string (we've also\n\t * checked it does have a string representation).\n\t */\n\ttok = STRING;\n    } else\n\twhile (COND_SEP())\n\t    condlex();\n    if (tok == INANG || tok == OUTANG) {\n\tenum lextok xtok = tok;\n\tdo condlex(); while (COND_SEP());\n\tif (tok != STRING)\n\t    YYERROR(ecused);\n\ts3 = tokstr;\n\tdo condlex(); while (COND_SEP());\n\tecadd(WCB_COND((xtok == INANG ? COND_STRLT : COND_STRGTR), 0));\n\tecstr(s1);\n\tecstr(s3);\n\treturn 1;\n    }\n    if (tok != STRING) {\n\t/*\n\t * Check second argument in case semantics e.g. [ = -a = ]\n\t * mean we have to go back and fix up the first one\n\t */\n\tif (tok != LEXERR) {\n\t    if (!dble || n_testargs)\n\t\treturn par_cond_double(dupstring(\"-n\"), s1);\n\t    else\n\t\treturn par_cond_multi(s1, newlinklist());\n\t} else\n\t    YYERROR(ecused);\n    }\n    s2 = tokstr;\n    if (!n_testargs)\n\tdble = (s2 && IS_DASH(*s2) && !s2[2]);\n    incond++;\t\t\t/* parentheses do globbing */\n    do condlex(); while (COND_SEP());\n    incond--;\t\t\t/* parentheses do grouping */\n    if (tok == STRING && !dble) {\n\ts3 = tokstr;\n\tdo condlex(); while (COND_SEP());\n\tif (tok == STRING) {\n\t    LinkList l = newlinklist();\n\n\t    addlinknode(l, s2);\n\t    addlinknode(l, s3);\n\n\t    while (tok == STRING) {\n\t\taddlinknode(l, tokstr);\n\t\tdo condlex(); while (COND_SEP());\n\t    }\n\t    return par_cond_multi(s1, l);\n\t} else\n\t    return par_cond_triple(s1, s2, s3);\n    } else\n\treturn par_cond_double(s1, s2);\n}",
        "start": 2463,
         "end": 2608
       },
    "zsh-5": {
        "buggy":"static void\nprintstylenode(HashNode hn, int printflags)\n{\n    Style s = (Style)hn;\n    Stypat p;\n    char **v;\n\n    if (printflags == ZSLIST_BASIC) {\n\tquotedzputs(s->node.nam, stdout);\n\tputchar('\\n');\n    }\n\n    for (p = s->pats; p; p = p->next) {\n\tif (zstyle_contprog && !pattry(zstyle_contprog, p->pat))\n\t    continue;\n\tif (printflags == ZSLIST_BASIC)\n\t    printf(\"%s  %s\", (p->eval ? \"(eval)\" : \"      \"), p->pat);\n\telse {\n\t    printf(\"zstyle %s\", (p->eval ? \"-e \" : \"\"));\n\t    quotedzputs(p->pat, stdout);\n\t    printf(\" %s\", s->node.nam);\n\t}\n\tfor (v = p->vals; *v; v++) {\n\t    putchar(' ');\n\t    quotedzputs(*v, stdout);\n\t}\n\tputchar('\\n');\n    }\n}",
        "start": 183,
         "end": 210
       }
}