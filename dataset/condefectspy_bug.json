{
    "abc221_f_40898300": {
        "buggy": "from collections import deque\nimport sys\nipt = sys.stdin.readline\n\ndef calcDiameter(g):\n    '''\n    g := \u6728\u3001\u96a3\u63a5\u30ea\u30b9\u30c8\u8868\u8a18\n    '''\n    n = len(g)\n    inf = 10**9\n    dst1,dst2 = [inf]*n, [inf]*n\n    \n    d = deque()\n    d.append(0)\n    visited = [0]*n\n    visited[0] = 1\n    \n    while d:\n        cur = d.popleft()\n        for nxt in g[cur]:\n            if visited[nxt]:\n                continue\n            visited[nxt] = 1\n            d.append(nxt)\n\n    d = deque()\n    d.append((cur,0))\n    visited = [0]*n\n    visited[cur] = 1\n\n    while d:\n        cur,dist = d.popleft()\n        dst1[cur] = dist\n        for nxt in g[cur]:\n            if visited[nxt]:\n                continue\n            visited[nxt] = 1\n            d.append((nxt,dist+1))\n\n    d = deque()\n    d.append((cur,0))\n    visited = [0]*n\n    visited[cur] = 1\n\n    while d:\n        cur,dist = d.popleft()\n        dst2[cur] = dist\n        for nxt in g[cur]:\n            if visited[nxt]:\n                continue\n            visited[nxt] = 1\n            d.append((nxt,dist+1))\n\n    return dist,dst1,dst2\n\nN = int(ipt())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u,v = map(int,ipt().split())\n    u,v = u-1,v-1\n    G[u].append(v)\n    G[v].append(u)\n\nD,dst1,dst2 = calcDiameter(G)\nT = []\n\nvisited = [0]*N\nif D%2:\n    for i in range(N):\n        if dst1[i] == D//2 and dst2[i] == D//2+1:\n            T.append(i)\n            visited[i] = 1\n        if dst2[i] == D//2 and dst1[i] == D//2+1:\n            T.append(i)\n            visited[i] = 1\nelse:\n    cen = None\n    for i in range(N):\n        if dst1[i] == D//2 and dst2[i] == D//2:\n            cen = i\n            break\n    for nxt in G[cen]:\n        T.append(nxt)\n        visited[i] = 1\n    visited[cen] = 1\n\nU = []\n\nfor t in T:\n    cnt = 0\n    dq = deque()\n    dq.append((t,0))\n\n    while dq:\n        cur,dist = dq.popleft()\n        if dist == (D-1)//2:\n            cnt += 1\n        for nxt in G[cur]:\n            if visited[nxt]:\n                continue\n            visited[nxt] = 1\n            dq.append((nxt,dist+1))\n    U.append(cnt)\n\ndp = [0]*3\ndp[0] = 1\n\nMOD = 998244353\nfor c in U:\n    ndp = [0]*3\n    ndp[0] = dp[0]\n    ndp[1] = (dp[1] + dp[0]*c%MOD)%MOD\n    ndp[2] = (dp[2] + dp[2]*c%MOD + dp[1]*c%MOD)%MOD\n    dp = ndp\n\nprint(dp[2])",
        "length": 116,
        "loc": 84
    },
    "abc221_g_26339941": {
        "buggy": "n,a,b,*D = map(int,open(0).read().split())\ns = sum(D)\np,q = abs(a),abs(b)\nif p+q>s or (s+p+q)%2:\n  print(\"No\")\n  exit()\nx,y = (s+p+q)//2,(s+p-q)//2\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(n):\n  dp[i+1] = dp[i]|dp[i]<<D[i]\nif not dp[n]>>x&dp[n]>>y&1:\n  print(\"No\")\n  exit()\nL = []\nfor i in range(n)[::-1]:\n  s,t = (dp[i]>>x&1)^1,(dp[i]>>y&1)^1\n  L.append(\"DLRU\"[s*2+t])\n  if s:\n    x -= D[i]\n  if t:\n    y -= D[i]\nans = \"\".join(L[::-1])\nif a < 0:\n  ans = ans.translate(str.maketrans({\"L\":\"R\",\"R\":\"L\"}))\nif b < 0:\n  ans = ans.translate(str.maketrans({\"U\":\"D\",\"D\":\"U\"}))\nprint(\"Yes\")\nprint(ans)",
        "length": 29,
        "loc": 18
    },
    "abc223_a_45813374": {
        "buggy": "n=int(input())\n\nif n<100:\n    print(\"No\")\nelse:\n    print(\"Yes\")",
        "length": 6,
        "loc": 3
    },
    "abc223_b_52785305": {
        "buggy": "s = list(input())\nans = []\nfor i in range(len(s)):\n  ans.append(s[i:len(s)]+s[0:i])\nprint(min(ans))\nprint(max(ans))",
        "length": 6,
        "loc": 1
    },
    "abc223_d_45783590": {
        "buggy": "from collections import defaultdict\nimport heapq\nN,M = map(int, input().split())\n\nin_edges = [0]*(N+1)\nG = defaultdict(list)\nfor _ in range(M):\n    A,B = map(int, input().split())\n    G[A].append(B)\n    in_edges[B] += 1\n\nH = []\nfor i in range(1,N+1):\n    if in_edges[i] == 0:\n        heapq.heappush(H, i)\n\nheapq.heapify(H)\nans = []\nwhile H:\n    v = heapq.heappop(H)\n    ans.append(v)\n    for u in G[v]:\n        in_edges[u] -= 1\n        if in_edges[u] == 0:\n            heapq.heappush(H, u)\n\nif ans:\n    print(*ans)\nelse:\n    print(-1)",
        "length": 30,
        "loc": 27
    },
    "abc223_e_53250614": {
        "buggy": "from itertools import permutations\nfrom sys import stdin\n\n\nclass FastIO:\n    def __init__(self):\n        self.random_seed = 0\n        self.flush = False\n        self.inf = 1 << 32\n        return\n\n    @staticmethod\n    def read_int():\n        return int(stdin.readline().rstrip())\n\n    @staticmethod\n    def read_float():\n        return float(stdin.readline().rstrip())\n\n    @staticmethod\n    def read_list_ints():\n        return list(map(int, stdin.readline().rstrip().split()))\n\n    @staticmethod\n    def read_list_ints_minus_one():\n        return list(map(lambda x: int(x) - 1, stdin.readline().rstrip().split()))\n\n    @staticmethod\n    def read_str():\n        return stdin.readline().rstrip()\n\n    @staticmethod\n    def read_list_strs():\n        return stdin.readline().rstrip().split()\n\n    def get_random_seed(self):\n        import random\n        self.random_seed = random.randint(0, 10 ** 9 + 7)\n        return\n\n    def st(self, x):\n        return print(x, flush=self.flush)\n\n    def yes(self, s=None):\n        self.st(\"Yes\" if not s else s)\n        return\n\n    def no(self, s=None):\n        self.st(\"No\" if not s else s)\n        return\n\n    def lst(self, x):\n        return print(*x, flush=self.flush)\n\n    def flatten(self, lst):\n        self.st(\"\\n\".join(str(x) for x in lst))\n        return\n\n    @staticmethod\n    def max(a, b):\n        return a if a > b else b\n\n    @staticmethod\n    def min(a, b):\n        return a if a < b else b\n\n    @staticmethod\n    def ceil(a, b):\n        return a // b + int(a % b != 0)\n\n    @staticmethod\n    def accumulate(nums):\n        n = len(nums)\n        pre = [0] * (n + 1)\n        for i in range(n):\n            pre[i + 1] = pre[i] + nums[i]\n        return pre\n\n\nclass Solution:\n    def __init__(self):\n        return\n\n    @staticmethod\n    def main(ac=FastIO()):\n        \"\"\"\n        url: url of the problem\n        tag: algorithm tag\n        \"\"\"\n\n        def ceil(xxx, yyy):\n            return xxx / yyy + int(xxx % yyy != 0)\n\n        x, y, a, b, c = ac.read_list_ints()\n        for perm in permutations([a, b, c], 3):\n            aa, bb, cc = perm\n            yy = ceil(aa, x)\n            rest = y - yy\n            if rest > 0 and ceil(bb, rest) + ceil(cc, rest) <= x:\n                ac.yes()\n                return\n\n            if ceil(aa, x) + ceil(bb, x) + ceil(cc, x) <= y:\n                ac.yes()\n                return\n\n            if ceil(aa, y) + ceil(bb, y) + ceil(cc, y) <= x:\n                ac.yes()\n                return\n\n            xx = ceil(aa, y)\n            rest = x - xx\n            if rest > 0 and ceil(bb, rest) + ceil(cc, rest) <= y:\n                ac.yes()\n                return\n        ac.no()\n        return\n\n\nSolution().main()\n",
        "length": 120,
        "loc": 92
    },
    "abc223_g_45319303": {
        "buggy": "from heapq import heappop, heappush\n\nN = int(input())\ntree = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    u -= 1; v -= 1\n    tree[u].append(v)\n    tree[v].append(u)\n\nroot = 0\nparent = [-1] * N\nparent[root] = root\nnum_children = [0] * N\nstack = [root]\nleaf = set(range(N))\nwhile stack:\n    node = stack.pop()\n    for nex in tree[node]:\n        if parent[nex] != -1:\n            continue\n        parent[nex] = node\n        num_children[node] += 1\n        stack.append(nex)\n        leaf.discard(node)\n\ndp1 = [[0, 0] for _ in range(N)] # dp1[node][0/1] := node \u3092\u4f7f\u308f\u306a\u3044/\u4f7f\u3046\nhq = [[] for _ in range(N)]\nleaf = list(leaf)\nwhile leaf:\n    node = leaf.pop()\n    min_diff = 10**6\n    have_child = False\n    for nex in tree[node]:\n        if nex == parent[node]:\n            continue\n        have_child = True\n        dp1[node][0] += max(dp1[nex])\n        heappush(hq[node], dp1[nex][1]-dp1[nex][0])\n        min_diff = min(min_diff, dp1[nex][1]-dp1[nex][0]) \n    \n    if have_child:\n        dp1[node][1] = dp1[node][0] - min_diff + 1\n    par = parent[node]\n    num_children[par] -= 1\n    if num_children[par] == 0:\n        leaf.append(par)\n\ndp2 = [[0, 0] for _ in range(N)]\nstack = [root]\nwhile stack:\n    node = stack.pop()\n    par = parent[node]\n    for nex in tree[node]:\n        if nex == par:\n            continue\n        stack.append(nex)\n    \n    if node == par:\n        continue\n        \n    dp2[node][1] = dp2[par][0] + dp1[par][0] - max(dp1[node]) + 1\n    if hq[par][0] == dp1[node][1] - dp1[node][0]:\n        escape = heappop(hq[par])\n        if hq[par]:\n            match = dp2[par][0] + dp1[par][0] - hq[par][0] + 1\n        else:\n            match = dp2[par][0]\n        heappush(hq[par], escape)\n    else:\n        match = dp2[par][0] + dp1[par][1] - max(dp1[node])\n    dp2[node][0] = max(\n        dp2[node][1] - 1,\n        dp2[par][1] + dp1[par][0] - max(dp1[node]),\n        match\n    )\n    \n    \n\n\nans = 0\nmax_match = max(dp1[root])\nfor node in range(N):\n    if dp1[node][0] + dp2[node][0] == max_match:\n        ans += 1\n\nprint(ans)\n",
        "length": 87,
        "loc": 66
    },
    "abc224_a_46029165": {
        "buggy": "s=input()\nif s[-2] == \"er\":\n  print(\"er\")\nelse:\n  print(\"ist\")",
        "length": 5,
        "loc": 2
    },
    "abc224_b_46150770": {
        "buggy": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(H)]\n\nFlag = True\nfor a in range(H-1):\n\tfor b in range(a+1, H):\n\t\tfor c in range(W-1):\n\t\t\tfor d in range(b+1, W):\n\t\t\t\tif A[a][c] + A[b][d] > A[b][c] + A[a][d]:\n\t\t\t\t\tFlag = False\nif Flag:\n\tprint('Yes')\nelse:\n\tprint('No')",
        "length": 14,
        "loc": 8
    },
    "abc224_c_44477761": {
        "buggy": "N=int(input())\nXY=[]\nfor i in range(N):\n  XY.append(list(map(int, input().split())))\n#print(N)\n#print(XY)\n\ncount=0\nfor i in range(N):\n  for j in range(i+1,N):\n    for k in range(j+1,N):\n      #print(i,j,k)\n      if (XY[k][1]-XY[i][1])*(XY[j][0]-XY[i][0])!=(XY[j][0]-XY[i][0])*(XY[k][0]-XY[i][0]):\n        count+=1\nprint(count)",
        "length": 15,
        "loc": 13
    },
    "abc224_f_51168884": {
        "buggy": "import io\nimport sys\nimport bisect\nimport math\nfrom itertools import permutations, combinations\nfrom heapq import heappush, heappop\nfrom collections import deque\nfrom collections import defaultdict as dd\nsys.setrecursionlimit(10**7+10)\n\nmod = 998244353\n\n_INPUT = \"\"\"\\\n31415926535897932384626433832795\n\n\"\"\"\n\n\n\ndef main():\n    S = input()\n    n = len(S)\n    dp1 = [0]*(n+1)\n    # dp2 = [0]*(n+1)\n    dp1[n] = 1\n    dp1[n-1] = 1\n    for i in range(n-2, 0, -1):\n        dp1[i] = pow(2, n-1-i, mod)\n    temp = 0\n    for i in range(1, n+1):\n        temp += dp1[i]*pow(10, i-1, mod)\n        temp %= mod\n    ans = 0\n    for i in range(n, 0, -1):\n        x = int(S[n-i])\n        ans += x * temp\n        temp -= dp1[i]*pow(10, i-1, mod)\n        if i>1:\n            temp += dp1[i]*pow(10, i-2, mod)\n            dp1[i-1] += dp1[i]\n        temp %= mod\n        ans %= mod\n    print(ans)\n\nif __name__ == \"__main__\":\n    sys.stdin = io.StringIO(_INPUT)\n    main()\n",
        "length": 47,
        "loc": 46
    },
    "abc224_g_28236524": {
        "buggy": "N, S, T, A, B = map(int, input().split())\n\n\ndef value(k):\n    if k < S <= T:\n        return A*(T-S)/2\n    elif k >= T:\n        return float('inf')\n    else:\n        return B*N/(T-k)+A*(T-k-1)/2\n\n\nl, r = 0, T\nif r-l == 1:\n    print(min(value(0), value(1)))\n    exit()\nif r-l == 2:\n    print(min(value(0), value(1), value(2)))\n    exit()\nwhile r-l > 2:\n    m1 = l+(r-l)//3\n    m2 = r-(r-l)//3\n    if value(m1) >= value(m2):\n        l = m1\n    else:\n        r = m2\nprint(min(value(l), value(l+1), value(r)))\n",
        "length": 27,
        "loc": 6
    },
    "abc225_c_44146392": {
        "buggy": "N, M = map(int, input().split())\nB = [ list(map(int, input().split())) for _ in range(N) ]\nflag = True\nlim = 10**100*7+7\nj0 = (B[0][0]-1)%7\nif j0 + M-1 >= 7:\n    flag = False\ni0 = (B[0][0])//7\nfor i in range(N):\n    for j in range(M):\n        if B[i][j] != (i+i0)*7 + j + j0 +1 or B[i][j] > lim:\n            flag = False\nif flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "length": 16,
        "loc": 11
    },
    "abc225_e_45312408": {
        "buggy": "from fractions import Fraction\n\ninf = float(\"inf\")\nN = int(input())\nX = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    \n    a1 = x\n    b1 = y - 1\n    t1 = Fraction(b1, a1)\n    \n    a2 = x-1\n    b2 = y\n    if a2 == 0:\n        t2 = inf\n    else:\n        t2 = Fraction(b2, a2)\n    X.append((t1, t2))\n\nX.sort(key=lambda x:x[1])\nans = 0\nR = -inf\nfor l, r in X:\n    if r > R:\n        ans += 1\n        R = r\n        \n\nprint(ans)\n    \n    ",
        "length": 32,
        "loc": 2
    },
    "abc226_a_45900046": {
        "buggy": "\ns = float(input())\n\nprint(round(s))\n\n        \n        \n    \n    ",
        "length": 9,
        "loc": 4
    },
    "abc226_b_45483175": {
        "buggy": "import sys\nfrom collections import deque,defaultdict\nimport itertools\nimport heapq\nimport bisect\nimport queue\nimport math\n\n#sys.setrecursionlimit(10 ** 9)\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nli_st = lambda: list(map(str, input().split()))\nlli = lambda n: [li() for _ in range(n)]\nmod = 998244353\n\nN = ii()\n\ncheck = set()\nfor i in range(N):\n    s = li_st()\n    s = \"\".join(s)\n    check.add(s)\n\nprint(len(check))\n",
        "length": 26,
        "loc": 23
    },
    "abc226_c_45490771": {
        "buggy": "N = int(input())\ntime = [0] * (N+1)\nneed = [[] for _ in range(N+1)]\nfor i in range(1, N+1):\n    t, k, *A = list(map(int, input().split()))\n    time[i] = t\n    need[i] = A\n\nans = 0\ngot = set()\nstack = [N]\nwhile stack:\n    node = stack.pop()\n    got.add(node)\n    ans += time[node]\n    for n in need[node]:\n        if n in got:\n            continue\n        stack.append(n)\n\nprint(ans)",
        "length": 21,
        "loc": 14
    },
    "abc226_e_53676492": {
        "buggy": "MOD=998244353\nn,m=map(int,input().split())\ngraph=[[] for _ in range(n)]\nfor _ in range(m):\n    u,v=map(lambda x:int(x)-1,input().split()) \n    graph[u].append(v)\n    graph[v].append(u)\nvisited=[0]*n\nfrom collections import deque\ndef dfs(s):\n    if visited[s]:\n        return []\n    visited[s]=1\n    q=deque([s])\n    link=[s]\n    while q:\n        v=q.popleft()\n        for u in graph[v]:\n            if visited[u]:\n                continue\n            visited[u]=1\n            q.append(u)\n            link.append(u)\n    return link\n\nans=1\nfor i in range(n):\n    link=dfs(i)\n    num_edge=0\n    if len(link)<2:\n        continue\n    for l in link:\n        num_edge+=len(graph[l])\n    if num_edge==len(link)*2:\n        ans*=2\n        ans%=MOD\n    else:\n        ans=0\nprint(ans)",
        "length": 39,
        "loc": 30
    },
    "abc226_g_48936036": {
        "buggy": "Q=int(input())\nfor _ in range(Q):\n  A=list(map(int,input().split()))\n  v=list(map(int,input().split()))\n  if v[4]<A[4]:\n    print('No')\n    continue\n  v[4]-=A[4]\n  A[4]=0\n  if v[3]+v[4]<A[3]:\n    print('No')\n    continue\n  if v[3]>=A[3]:\n    v[3]-=A[3]\n    A[3]=0\n  else:\n    A[3]-=v[3]\n    v[3]=0\n  v[0]+=A[3]\n  v[4]-=A[3]\n  A[3]=0\n  if v[2]+v[3]+v[4]<A[2]:\n    print('No')\n    continue\n  if v[2]>=A[2]:\n    v[2]-=A[2]\n    A[2]=0\n  else:\n    A[2]-=v[2]\n    v[2]=0\n  if v[4]>=A[2]:\n    v[1]+=A[2]\n    v[4]-=A[2]\n    A[2]=0\n  else:\n    v[1]+=v[4]\n    A[2]-=v[4]\n    v[4]=0\n  v[0]+=A[2]\n  v[3]-=A[2]\n  A[2]=0\n  n=2*(v[4]+v[3])+v[2]+v[1]\n  m=5*v[4]+4*v[3]+3*v[2]+2*v[1]+v[0]\n  if n>=A[1] and m>=A[0]:\n    print('Yes')\n  else:\n    print('No')",
        "length": 47,
        "loc": 44
    },
    "abc229_a_46216070": {
        "buggy": "\ns1 = input()\ns2 = input()\n\nif [s1, s2]==[\"#.\",\".#\"] or[\".#\",\"#.\"]:\n    print('No')\n    exit()\nelse:\n    print('Yes')\n    ",
        "length": 10,
        "loc": 5
    },
    "abc229_b_45280624": {
        "buggy": "a, b = map(int, input().split())\n\nwhile a > 0 and b > 0:\n    if (a % 10) + (b % 10) >= 10:\n        print(\"Hard\")\n        break\n    a //= 10\n    b //= 10\n\nprint(\"Easy\")",
        "length": 10,
        "loc": 6
    },
    "abc229_d_45424479": {
        "buggy": "S = input()\nK = int(input())\nN = len(S)\nX = [0]*N\n\nif N==1:\n  if (S[0]=='.' and K==1) or (S[0]=='X' and K==0):\n    print(1)\n    exit()\n\nif K==0:\n  ans = 0\n  for i in range(N):\n    if S[i]=='X':\n      if i!=N-1:\n        for j in range(i+1,N):\n          if S[j]!='X':\n            break\n        ans = max(ans,j-i+1)\n      else:\n        ans = max(ans,1)\n  print(ans)\n  exit()\n\n  \nfor i in range(N):\n  if S[i]=='.':\n    X[i]+=1\nfor i in range(1,N):\n  X[i] = X[i] + X[i-1]\nX = [0] + X\n#print(X)\nans = 0\nfor i in range(1,N):\n  ok,ng =i,N+1\n  while abs(ok-ng)>1:\n    ic = (ok+ng)//2\n    #print(ok,ic,ng)\n    if X[ic]-X[i-1]<=K:\n      ok = ic\n    else:\n      ng = ic\n  #print(ok,ok-i+1)\n  ans = max(ans,ok-i+1)\nprint(ans)",
        "length": 45,
        "loc": 19
    },
    "abc229_e_44646979": {
        "buggy": "N, M = map(int, input().split())\n\nif M == 0:\n    for i in range(N, 0, -1):\n        print(i)\n    exit()\n\nfrom collections import defaultdict, deque\nAB = [list(map(int, input().split())) for _ in range(M)]\nfor i in range(M):\n    AB[i] = sorted(AB[i], reverse=True)\nAB.sort(key = lambda x: (x[1], x[0]), reverse=True)\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        #\u89aa\u3092\u63a2\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            #\u89aa\u304c\u540c\u3058\u3000\u4f55\u3082\u3057\u306a\u3044\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        # x \u304c\u5c5e\u3057\u3066\u3044\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        # \u89aa\u304c\u540c\u3058\u304b\u3069\u3046\u304b True or False\n        return self.find(x) == self.find(y)\n \n    def roots(self):\n        # \u6839\u306e\u8981\u7d20\u3092\u51fa\u529b\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        # \u9023\u7d50\u3057\u3066\u3044\u308b\u8981\u7d20\u306e\u6570\n        return len(self.roots())\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\nans = [0] * N\ng = UnionFind(N)\nvisit = set(range(N))\nnow = N - 1\nleng = M\ncount = 0\nwhile True:\n    for i in range(count, leng):\n        if AB[i][0] >= now + 1 and AB[i][1] >= now + 1:\n            if now != N - 1 and not g.same(AB[i][0] - 1, AB[i][1] - 1):\n                result -= 1\n            g.union(AB[i][0] - 1, AB[i][1] - 1)\n            visit.discard(AB[i][0] - 1)\n            visit.discard(AB[i][1] - 1)\n            count += 1\n        else:\n            break\n\n    visit.discard(now)\n    if now == N - 1:\n        result = g.group_count()\n    ans[now - 1] = result - len(visit)\n    now -= 1\n    if now == 0:\n        break\n\nfor i in range(N):\n    print(ans[i])\n",
        "length": 90,
        "loc": 4
    },
    "abc230_a_45690200": {
        "buggy": "n = int(input())\nx = n\nif n >= 42:\n    x += 1\nprint(f\"AGC0{x}\")\n",
        "length": 5,
        "loc": 5
    },
    "abc230_b_45318112": {
        "buggy": "s = input()\nif (len(s) == 2 and s == 'oo'):\n    print('No')\n    exit()\nelse:\n    print('Yes')\n    exit()\nif (len(s) == 1):\n    print('Yes')\n    exit()\nif (s[0] == 'x'):\n    s = s[1:]\nif (s[0] == 'x'):\n    s = s[1:]\nif (s[0] == 'x'):\n    print('No')\n    exit()\nm = ['o','x','x']\nfor i in range(len(s)):\n    if (s[i] != m[i%3]):\n        print('No')\n        exit()\nprint('Yes')",
        "length": 23,
        "loc": 5
    },
    "abc230_c_54240175": {
        "buggy": "N,A,B = map(int,input().split())\nP,Q,R,S = map(int,input().split())\n\nk1_min = max(1-A,1-B)\nk1_max = min(N-A,N-B)\nk2_min = max(1-A,B-N)\nk2_max = min(N-A,B-1)\n\nZ = [['.' for _ in range(S-R+1)] for _ in range(Q-P+1)]\n\nif A<B:\n  for i in range(P,Q+1):\n    for j in range(R,S+1):\n      if i == j-(B+k1_min)+1:\n        Z[i-P][j-R] = '#'\n      if i+j == A+B:\n        Z[i-P][j-R] = '#'\nelse:\n  for i in range(P,Q+1):\n    for j in range(R,S+1):\n      if i-(A+k1_min)+1 == j:\n        Z[i-P][j-R] = '#'\n      if i+j == A+B:\n        Z[i-P][j-R] = '#'\n  \n\nfor i in Z:\n  print(*i)",
        "length": 28,
        "loc": 28
    },
    "abc230_d_45013914": {
        "buggy": "from collections import deque\n\nn, d = map(int, input().split())\nwall = [list(map(int, input().split())) for _ in range(n)]\n\nwall.sort()\nq = deque(wall)\nans = 0\nnow = 0\nwhile q:\n    nex = q.popleft()\n    if nex[0] <= now:\n        continue\n    now = nex[1] + d - 1\n    ans += 1\n\nprint(ans)",
        "length": 17,
        "loc": 6
    },
    "abc230_e_45074707": {
        "buggy": "n = int(input())\n\nans = 0\n\nfor i in range(1, int(n**0.5)+1):\n    ans += n//i\n\nans = ans*2 - n\nprint(ans)\n",
        "length": 9,
        "loc": 8
    },
    "abc232_b_45920866": {
        "buggy": "S=input()\nT=input()\ncnt=set()\nN=len(S)\nfor i in range(N):\n    cnt.add(ord(S[i])-ord(T[i]))\n    \nif len(cnt)==1:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "length": 11,
        "loc": 6
    },
    "abc232_d_45266728": {
        "buggy": "# import pypyjit;pypyjit.set_param(\"max_unroll_recursion=-1\")\n# from bisect import *\n# from collections import *\n# from heapq import *\n# from itertools import *\n# from math import *\n# from datetime import *\n# from decimal import *  # PyPy\u3060\u3068\u9045\u3044\n# from string import ascii_lowercase,ascii_uppercase\n# import numpy as np\nimport sys\n\n# sys.setrecursionlimit(10**6) # PyPy\u3060\u3068\u9045\u3044\nINF = 1 << 61\nMOD = 998244353\n# MOD = 10**9 + 7\nFile = sys.stdin\n\n\ndef input():\n    return File.readline()[:-1]\n\n\n# ///////////////////////////////////////////////////////////////////////////\n\n\nH, W = map(int, input().split())\nC = [list(input()) for _ in range(H)]\n\ndp = [[0] * W for _ in range(H)]\ndp[0][0] = 1\nfor i in range(H):\n    for j in range(W):\n        if j < W - 1 and C[i][j + 1] == \".\":\n            dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + 1)\n        if i < H - 1 and C[i + 1][j] == \".\":\n            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1)\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        ans = max(ans, dp[i][j])\n\nprint(ans)\n",
        "length": 44,
        "loc": 34
    },
    "abc232_f_54006538": {
        "buggy": "(n,x,y),a,b=[[*map(int,s.split())]for s in open(0)]\nINF=1<<60\ndp=[INF]*(1<<n)\ndp[0]=0\nfor s in range(1<<n):\n  c=s.bit_count()\n  for i in range(n):\n    if s>>i&1:\n      continue\n    d=str(bin(s)[i+2:]).count('1')\n    dp[s|(1<<i)]=min(dp[s|(1<<i)],dp[s]+(i+d-c)*y+abs(a[i]-b[c])*x)\nprint(dp[-1])",
        "length": 12,
        "loc": 10
    },
    "abc232_h_28235852": {
        "buggy": "import sys\n\n# sys.setrecursionlimit(200005)\nint1 = lambda x: int(x)-1\npDB = lambda *x: print(*x, end=\"\\n\", file=sys.stderr)\np2D = lambda x: print(*x, sep=\"\\n\", end=\"\\n\\n\", file=sys.stderr)\ndef II(): return int(sys.stdin.readline())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline().rstrip()\n# dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n# dij = [(0, 1), (-1, 0), (0, -1), (1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\ninf = 18446744073709551615\n# inf = 4294967295\nmd = 10**9+7\n# md = 998244353\n\ndef two(i0, j0, s, t):\n    i, j = i0, j0\n    di = dj = 1\n    if i > s: di = -1\n    if j > t: dj = -1\n    l, r = i, j\n    if l > r: l, r = r, l\n    res = []\n    while l <= j <= r:\n        res.append((i, j))\n        if i == i0:\n            i += di\n        else:\n            i -= di\n            j += dj\n    return res\n\ndef move(i0, j0, s, t):\n    i, j = i0, j0\n    l, r = min(j0, t), max(j0, t)\n    di = dj = 1\n    if i > s: di = -1\n    if j > t: dj = -1\n    res = []\n    if i & 1 != s & 1:\n        res += two(i, j, s, t)\n        if abs(i-s) == 1: return res\n        i += di*2\n        j = t\n        while l <= j <= r:\n            res.append((i, j))\n            j -= dj\n        i, j = i+di, j0\n    while 1:\n        res.append((i, j))\n        if (i, j) == (s, t): break\n        if l <= j+dj <= r:\n            j += dj\n        else:\n            i += di\n            dj = -dj\n    return res\n\nh, w, a, b = LI()\nif a == h and b == w:\n    ans = move(1, 1, a, b)\nelif a == 1 and b == w:\n    ans = move(1, 1, h, w-1)+move(h, w, 1, w)\nelif a == h and b == 1:\n    ans = move(1, 1, h-1, w)+move(h, w, h, 1)\nelif a == 1:\n    ans = move(1, 1, h, b-1)+move(h, b, h, w)+move(h-1, w, a, b)\nelif a == h:\n    ans = move(1, 1, h, b-1)+move(a-1, b, 1, b)+move(1, b+1, h-1, w)+move(h, w, a, b)\nelif b == 1:\n    ans = move(1, 1, a-1, w)+move(a, w, h, w)+move(h, w-1, a, b)\nelif b == w:\n    ans = move(1, 1, a-1, w)+move(a, w-1, a, 1)+move(a+1, 1, h, w-1)+move(h, w, a, b)\nelse:\n    ans = move(1, 1, a-1, w)+move(a, w, h, b+1)+move(h, b, a+1, 1)+move(a, 1, a, b)\n\nfor i, j in ans: print(i, j)\n",
        "length": 81,
        "loc": 25
    },
    "abc233_a_45939689": {
        "buggy": "import math\nx,y = map(int,input().split())\nprint(math.ceil((y-x)/10))",
        "length": 3,
        "loc": 3
    },
    "abc233_b_46206186": {
        "buggy": "l,r = map(int, input().split())\n\ns = input()\n\nprint(s[:l] + s[l:r+1][::-1] + s[r+1:])",
        "length": 5,
        "loc": 5
    },
    "abc233_e_45254335": {
        "buggy": "from collections import *\nimport heapq\nimport bisect\n\nINF = float(\"inf\")\nMOD = 998244353\nmod = 998244353\n\n\nX = list(input())\nnum = [0]\nfor x in X:\n    num.append(num[-1] + int(x))\nnum.reverse()\nL = len(num)\nans = []\nfor i in range(L - 1):\n    k = num[i]\n    p, r = divmod(k, 10)\n    ans.append(str(r))\n    num[i + 1] += p\nans.reverse()\nprint(\"\".join(ans))",
        "length": 23,
        "loc": 22
    },
    "abc233_h_53067892": {
        "buggy": "import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    points = []\n    offset = 100_001\n    for i in range(n):\n        x = inp[i * 2 + 1]\n        y = inp[i * 2 + 2]\n        X = x + y\n        Y = x - y + offset\n        points.append((X, 1, Y))\n\n    inp_offset = n * 2 + 1\n    q = inp[inp_offset]\n    xxx_ = inp[inp_offset + 1::3]\n    yyy_ = inp[inp_offset + 2::3]\n    query_xs = xxx_ + yyy_\n    query_ys = xxx_ - yyy_ + offset\n    query_ks = inp[inp_offset + 3::3]\n\n    # === Fenwick Tree \u5b9a\u7fa9 ====\n    fenwick_n = 200_200  # CUSTOM\n    fenwick_table = np.zeros(fenwick_n + 1, np.int64)\n\n    def fenwick_add(i, x):\n        i += 1\n        while i <= fenwick_n:\n            fenwick_table[i] += x\n            i += i & -i\n\n    def fenwick_sum(i):\n        s = 0\n        i += 1\n        while i > 0:\n            s += fenwick_table[i]\n            i -= i & -i\n        return s\n\n    # === / \u3053\u3053\u307e\u3067 Fenwick Tree \u5b9a\u7fa9 ====\n\n    lo_list = np.full(q, -1, np.int64)\n    hi_list = np.full(q, 200_000, np.int64)\n    mid_list = np.zeros(q, np.int64)\n    res_list = np.zeros(q, np.int64)\n\n    for _ in range(18):\n        events = points.copy()\n        for i in range(q):\n            lo = lo_list[i]\n            hi = hi_list[i]\n            mid_list[i] = mid = (lo + hi) >> 1\n            x = query_xs[i]\n            events.append((x - mid, 0, i))\n            events.append((x + mid, 2, i))\n        events.sort()\n\n        fenwick_table.fill(0)\n\n        for x, op, i in events:\n            if op == 0:\n                y1 = query_ys[i] - mid_list[i]\n                y2 = query_ys[i] + mid_list[i]\n                res = fenwick_sum(min(fenwick_n - 1, y2))\n                if y1 > 0:\n                    res -= fenwick_sum(y1 - 1)\n                res_list[i] = -res\n            elif op == 1:\n                y1 = i\n                fenwick_add(y1, 1)\n            elif op == 2:\n                y1 = query_ys[i] - mid_list[i]\n                y2 = query_ys[i] + mid_list[i]\n                res = fenwick_sum(min(fenwick_n - 1, y2))\n                if y1 > 0:\n                    res -= fenwick_sum(y1 - 1)\n                res_list[i] += res\n                if res_list[i] < query_ks[i]:\n                    lo_list[i] = mid_list[i]\n                else:\n                    hi_list[i] = mid_list[i]\n\n    return hi_list\n\n\nSIGNATURE = '(i8[:],)'\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', SIGNATURE)(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit(SIGNATURE, cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint('\\n'.join(map(str, ans)))\n",
        "length": 110,
        "loc": 56
    },
    "abc234_a_45030219": {
        "buggy": "def f(n):\n  return n**2+2*n+3\nn=int(input())\nprint(f(f(f(n)+n))+f(f(n)))",
        "length": 4,
        "loc": 4
    },
    "abc234_b_45754993": {
        "buggy": "import math\n\ndef distance_2d(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nn = int(input())\nl = [0]*n\nans = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    l[i]=list(map(int, input().split()))\n    \nfor i in range(n):\n    for j in range(n):\n        ans[i][j] = distance_2d(l[i][0], l[i][1], l[j][0], l[j][1])\n        \nmax_value = max(max(row) for row in ans)\n",
        "length": 16,
        "loc": 16
    },
    "abc234_e_45285849": {
        "buggy": "X=int(input())\nnumbers=[]\n\nfor k in range(1,18):\n    for d in range(1,10):\n        for l in range(-8,10):\n            number=d\n            digits=[str(d)]\n            for _ in range(k):\n                number+=l\n                digits.append(str(number))\n            if 0<=int(digits[-1])<10:\n                numbers.append(int(''.join(digits)))\n\nnumbers.sort()\n\nfor number in numbers:\n    if number>=X:\n        print(number)\n        exit()",
        "length": 20,
        "loc": 4
    },
    "abc234_f_53824155": {
        "buggy": "S = input()\n\ndef inverse(n, d):\n    return n * pow(d, -1, MOD) % MOD\n\nMOD = 998244353\ncomb = [[0]*len(S) for _ in range(len(S))]\nfor i in range(len(S)):\n    for j in range((i+1)//2+1):\n        if j == 0:\n            comb[i][j] = i+1\n        else:\n            comb[i][j] = comb[i][j-1]\n            comb[i][j] *= inverse(i+1-j, j+1)\n            comb[i][j] %= MOD\n\ncnt = [0]*26\nfor i in range(len(S)):\n    cnt[ord(S[i])-ord(\"a\")] += 1\n\ndp = [[0]*(len(S)+1) for _ in range(27)]\ndp[0][0] = 1\nSUM = cnt[0]\nfor i in range(1, 27):\n    for j in range(SUM+1):\n        dp[i][j] += dp[i-1][j]\n        dp[i][j] %= MOD\n        for k in range(1, min(j+1, cnt[i-1]+1)):\n            J, K = j, k\n            if J == K:\n                dp[i][j] += dp[i-1][j-k]\n                dp[i][j] %= MOD\n            else:\n                if j % 2 == 0 and K > j//2:\n                    K -= (K-j//2)*2\n                elif j & 2 == 1 and K > j//2:\n                    K -= (K-j//2-1)*2+1\n                dp[i][j] += comb[J-1][K-1]*dp[i-1][j-k]\n                dp[i][j] %= MOD\n    if i < 26:\n        SUM += cnt[i]\n\nans = 0\nfor i in range(1, len(S)+1):\n    ans += dp[-1][i]\n    ans %= MOD\n\nprint(ans)",
        "length": 48,
        "loc": 36
    },
    "abc235_b_44832943": {
        "buggy": "N = int(input())\nH = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, N):\n    if H[i] > H[i-1]:\n        ans = H[i]\n    else:\n        break\nprint(ans)",
        "length": 10,
        "loc": 4
    },
    "abc235_d_46231153": {
        "buggy": "a,n = map(int,input().split())\nnums =[-1]*(10**6)\nfrom collections import deque\nq = deque()\nq.append(a)\nnums[a] = 1\nwhile q:\n    x = q.popleft()\n    y = x*a\n    if y<10**6 and nums[y] ==-1:\n        nums[y] = nums[x]+1\n        q.append(y)\n    if x>9:\n        X = str(x)\n        Z = X[-1]+X[:-1]\n        z = int(Z)\n        if z<10**6 and nums[z] ==-1:\n            nums[z] = nums[x]+1\n            q.append(z)\nprint(nums[n])\n\n",
        "length": 21,
        "loc": 13
    },
    "abc236_a_45439657": {
        "buggy": "s=input()\na,b=map(int,input().split())\nprint(s[:a-1]+s[b-1]+s[a:b-2]+s[a-1]+s[b:])",
        "length": 3,
        "loc": 3
    },
    "abc236_b_45474387": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\nB = list(set(A))\nA.sort()\nB.sort()\n\nfor i in range(4*N-1):\n\tif A[i] != B[i//4]:\n\t\tprint(A[i])\n\t\texit()\nprint(A[-1])",
        "length": 11,
        "loc": 9
    },
    "abc236_h_28807713": {
        "buggy": "from math import gcd\n\nimport os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    m = inp[1]\n    ddd = inp[2:]\n    MOD = 998244353\n    n2 = 1 << n\n    INF = 1 << 60\n\n    def pop_count_32(n):\n        c = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        c = (c & 0x33333333) + ((c >> 2) & 0x33333333)\n        c = (c & 0x0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f)\n        c = (c & 0x00ff00ff) + ((c >> 8) & 0x00ff00ff)\n        c = (c & 0x0000ffff) + ((c >> 16) & 0x0000ffff)\n        return c\n\n    def bit_length(n):\n        l = 0\n        while n:\n            n >>= 1\n            l += 1\n        return l\n\n    lcms = np.ones(n2, np.int64)\n    all_same = np.ones(n2, np.int64)\n    pop_count = np.zeros(n2, np.int64)\n\n    for i in range(1, n2):\n        lsb = i & -i\n        ot = lcms[i ^ lsb]\n        if ot == INF:\n            lcms[i] = INF\n        else:\n            d = ddd[bit_length(lsb) - 1]\n            g = gcd(ot, d)\n            if INF // ot <= d // g:\n                lcms[i] = INF\n            else:\n                lcms[i] = d // g * ot\n        all_same[i] = (m // lcms[i]) % MOD\n        pop_count[i] = pop_count_32(i)\n\n    facts = np.ones(n + 1, np.int64)\n    for i in range(2, n + 1):\n        facts[i] = facts[i - 1] * i % MOD\n\n    dp = np.zeros(n2, np.int64)\n    dp[0] = 1\n    for i in range(1, n2):\n        lsb = i & -i\n        j = i ^ lsb\n        k = j\n\n        res = all_same[lsb] * dp[j] % MOD\n        while k:\n            p = pop_count[k]\n            if p % 2 == 0:\n                res += all_same[k | lsb] * facts[p] % MOD * dp[j ^ k] % MOD\n                # print(f'+ i:{i:04b} j:{j:04b} k:{k:04b} p:{p}', all_same[k | lsb], facts[p], dp[j ^ k])\n            else:\n                res -= all_same[k | lsb] * facts[p] % MOD * dp[j ^ k] % MOD\n                # print(f'- i:{i:04b} j:{j:04b} k:{k:04b} p:{p}', all_same[k | lsb], facts[p], dp[j ^ k])\n            res %= MOD\n            k = (k - 1) & j\n        dp[i] = res\n        # print(dp)\n\n    return dp[-1]\n\n\nSIGNATURE = '(i8[:],)'\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', SIGNATURE)(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit(SIGNATURE, cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint(ans)\n",
        "length": 99,
        "loc": 44
    },
    "abc237_a_45125955": {
        "buggy": "n=int(input())\nprint('YNeos'[n<-2**31 or n>2**31::2])",
        "length": 2,
        "loc": 2
    },
    "abc237_c_45766174": {
        "buggy": "s = input()\ntmp1 = s.rstrip(\"a\")\nback_a = len(s)-len(tmp1)\ntmp2 = tmp1.lstrip(\"a\")\nfront_a = len(s)-len(tmp2)\nif tmp2==tmp2[::-1] and front_a<=back_a:\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 9,
        "loc": 5
    },
    "abc237_f_35962547": {
        "buggy": "import cProfile\nimport math\nimport sys\nimport io\nimport os\nimport traceback\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque\nfrom functools import lru_cache\nfrom itertools import accumulate\n\n\n# region IO\nBUFSIZE = 8192\n\n\nclass FastIO(io.IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.buffer = io.BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(io.IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\n# endregion\n\n# region local test\nif 'AW' in os.environ.get('COMPUTERNAME', ''):\n    test_no = 1\n    # f = open(os.path.dirname(__file__) + f'\\\\in{test_no}.txt', 'r')\n    file = open('inputs')\n    def input():\n        return file.readline().rstrip(\"\\r\\n\")\n# endregion\n\nMOD = 998244353\n\ndef solve():\n    n, m = read_int_tuple()\n    p = m + 1\n    pp = p * p\n    ppp = pp * p\n\n    dp = [0] * ppp\n    dp[-1] = 1\n\n    for _ in range(n):\n        np = [0] * ppp\n        for a in range(p):\n            for b in range(p):\n                for c in range(p):\n                    ft = a * pp + b * p + c\n                    if dp[ft] == 0: continue\n                    for x in range(m):\n                        if x > c: continue\n                        if x <= a:\n                            tt = x * pp + b * p + c\n                        elif x <= b:\n                            tt = a * pp + x * p + c\n                        else:\n                            tt = a * pp + b * p + x\n                        # else:\n                        #     continue\n                        np[tt] += dp[ft]\n                        np[tt] %= MOD\n        dp = np\n    print(sum(dp[a * pp + b * p + c] for a in range(m) for b in range(a + 1, m) for c in range(b + 1, m)))\n\nT = 1\nfor t in range(T):\n    solve()\n\n",
        "length": 141,
        "loc": 136
    },
    "abc238_a_45663153": {
        "buggy": "n = int(input())\nif n == 2 or n == 3:\n  print(\"No\")\nelse:\n  print(\"Yes\")",
        "length": 5,
        "loc": 2
    },
    "abc238_b_45497591": {
        "buggy": "n=int(input())\nA=list(map(int,input().split()))\nans = [0]\nfor i in range(n):\n    for j in range(len(ans)):\n        ans[j] += A[i]\n        ans[j] %= 360\n    ans.append(0)\nans = sorted(ans)\nans.append(360)\nMa = 0\nfor i in range(n):\n    Ma = max(Ma, ans[i+1]-ans[i])\nprint(Ma)\n",
        "length": 14,
        "loc": 12
    },
    "abc238_d_45717530": {
        "buggy": "T = int(input())\na, s = zip(*[map(int, input().split(' ')) for _ in range(T)])\n\nfor i in range(T):\n    A = bin(a[i])[2:]\n    S = bin(s[i])[2:]\n    n = len(A)\n    m = len(S)\n\n    x = a[i]\n    y = a[i]\n    if s[i] < 2*x:\n        print(\"No\")\n        continue\n    elif s[i] == 2*x:\n        print(\"Yes\")\n        continue\n    \n    flg = True\n    for j in range(m):\n        if j <= m-n or A[j-m+n] == \"0\":\n            tmp = 2**(m-j-1)\n            if x + y + tmp == s[i]:\n                flg = False\n                print(\"Yes\")\n                break\n            elif x + y + tmp < s[i]:\n                y += tmp\n    if flg:\n        print(\"No\")",
        "length": 30,
        "loc": 21
    },
    "abc238_f_39396735": {
        "buggy": "n,k = map(int,input().split())\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nmod = 998244353\n\na = [0]*(n)\nfor i in range(n):\n  a[p[i]-1] = q[i]-1\n\n\ndp = [[0]*(n+1) for i in range(k+1)] \ndp[0][n] = 1\nfor i in range(n):\n  ai = a[i]\n  new = [[0]*(n+1) for i in range(k+1)] \n  for j in range(k+1):\n    for mini in range(1, n+1):\n      if mini >= ai and j >= 1:\n        new[j][mini] += dp[j-1][mini]\n      if mini >= ai:\n        new[j][ai] += dp[j][mini]\n      else:\n        new[j][mini] += dp[j][mini]\n      new[j][mini] %= mod\n      new[j][ai] %= mod\n  dp = new\n\nprint(sum(dp[-1])%mod)\n\n\n",
        "length": 30,
        "loc": 17
    },
    "abc239_a_46183850": {
        "buggy": "import math\nC = 12800000\nh = int(input())\n\nprint(math.sqrt(h + (h + C)))",
        "length": 5,
        "loc": 5
    },
    "abc239_c_44818357": {
        "buggy": "import sys\n\nsys.setrecursionlimit(10**9)\n\n\ndef main():\n    x1, y1, x2, y2 = map(int, input().split())\n\n    if abs(x1 - x2) <= 4 and abs(y1 - y2) <= 4:\n        if abs(x1 - x2) == 1 and abs(y1 - y2) in [1, 3]:\n            print(\"Yes\")\n        elif abs(x1 - x2) == 0 and abs(y1 - y2) in [2, 4]:\n            print(\"Yes\")\n        elif abs(x1 - x2) == 2 and abs(y1 - y2) in [0, 4]:\n            print(\"Yes\")\n        elif abs(x1 - x2) == 3 and abs(y1 - y2) in [1, 3]:\n            print(\"Yes\")\n        elif abs(x1 - x2) == 4 and abs(y1 - y2) == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "length": 27,
        "loc": 18
    },
    "abc239_d_52953499": {
        "buggy": "#2 3 3 4\n#\u7d20\u6570\u5217\u6319\ndef prime(N):\n    primes = []\n    for i in range(2, N + 1):\n        primes.append(i)\n        for p in range(2, i):\n            if i % p == 0:\n                primes.remove(i)\n                break\n    return primes\nsetx=set(prime(100))\n\nA,B,C,D=map(int,input().split())\nfor i in range(A,B+1):\n    q=True\n    for j in range(C,D+1):\n        num=i+j\n        if num in setx:\n            q=False\n            break\n    if q==True:\n        print(\"Takahashi\")\n        exit()\nprint(\"Aoki\")\n        ",
        "length": 26,
        "loc": 12
    },
    "abc239_g_45950802": {
        "buggy": "from atcoder.maxflow import MFGraph\n\nINF = 1 << 60\nN, M = map(int, input().split())\ng = MFGraph(N * 2)\nfor _ in range(M):\n    A, B = map(lambda x: int(x)-1, input().split())\n    g.add_edge(A+N, B, INF)  # A_out -> B_in\n    g.add_edge(B+N, A, INF)  # B_out -> A_in\n\nC = list(map(int, input().split()))\nfor i, c in enumerate(C):\n    cap = INF if i in [0, N-1] else c\n    g.add_edge(i, i+N, cap)  # i_in -> i_out\n\nans = g.flow(0, N-1)\nmc = g.min_cut(0)\nvs = []\nfor i in range(N):\n    if mc[i] and not mc[i+1]:\n        vs.append(i+1)\n\nprint(ans)\nprint(len(vs))\nprint(*vs)\n",
        "length": 25,
        "loc": 20
    },
    "abc240_a_45813906": {
        "buggy": "a,b=map(int,input().split())\nif abs(a-b)== 1 or 9:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "length": 5,
        "loc": 2
    },
    "abc240_d_45435904": {
        "buggy": "from collections import deque\nN = int(input())\nA = list(map(int, input().split()))\n\nQ = deque()\nans = 0\n\nfor a in A:\n    ans += 1\n    if len(Q) == 0:\n        Q.append([a,1])\n    if Q[-1][0] != a:\n        Q.append([a,1])\n    else:\n        Q[-1][1] += 1\n        if Q[-1][1] == a:\n            Q.pop()\n            ans -= a\n    print(ans)\n    \n",
        "length": 20,
        "loc": 12
    },
    "abc240_g_35075785": {
        "buggy": "MOD = 998244353\n\nn, x, y, z = map(int, input().split())\nx = abs(x)\ny = abs(y)\nz = abs(z)\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    ifact = [0] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    ifact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        ifact[i-1] = ifact[i] * i % MOD\n    return fact, ifact\n\nfact, ifact = factorial(n)\ndef comb(n, r):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * ifact[r] % MOD * ifact[n-r] % MOD\n\ndef f(a, b):\n    b = abs(b)\n    if a < b or (a - b) % 2:\n        return 0\n    return comb(a, (a - b) // 2)\n\nans = 0\nfor i in range(x, n, 2):\n    t = comb(n, i) * f(i, x) % MOD\n    t = t * f(n - i, y + z) % MOD\n    t = t * f(n - i, y - z) % MOD\n    ans = (ans + t) % MOD\nprint(ans)",
        "length": 36,
        "loc": 31
    },
    "abc241_b_45708346": {
        "buggy": "n,m=list(map(int,input().split()))\nl=[int(x) for x in input().split()]\nd=dict()\nfor i in l:\n    if i in d:\n        d[i]+=1\n    else :\n        d[i]=1\nyes=True\nnl=[int(x) for x in input().split()]\nfor i in nl:\n    if i not in d or d[i]==0:\n        yes=False\n        break\n\nprint(\"Yes\"if yes else \"No\")",
        "length": 16,
        "loc": 16
    },
    "abc241_c_45443856": {
        "buggy": "N = int(input())\nS = [input() for _ in range(N)]\n\ndx = [1,0,1,-1]\ndy = [0,1,1,1]\n\nfor h in range(N):\n    for w in range(N):\n        for i in range(4):\n            cnt = 0\n            for j in range(6):\n                nh = h + dy[i]*j\n                nw = w + dx[i]*j\n                if not (0 <= nh < N and 0 <= nw < N):\n                    continue\n                if S[nh][nw] == \"#\":\n                    cnt += 1\n            else:\n                if cnt >= 4:\n                    print('Yes')\n                    exit()\nprint('No')\n\n\n",
        "length": 24,
        "loc": 15
    },
    "abc242_a_45438303": {
        "buggy": "A,B,C,X = map(int,input().split())\nif X <= A:\n  print(1.000000000000)\nelif X < B:\n  print(C/(B-A))\nelse:\n  print(0.000000000000)",
        "length": 7,
        "loc": 4
    },
    "abc242_b_45803292": {
        "buggy": "def func():\n    # \u5165\u529b\u3092\u53d6\u5f97\n    S = input()\n    \n    print(sorted(S))\n\nif __name__ == '__main__':\n    func()",
        "length": 8,
        "loc": 5
    },
    "abc242_g_52939949": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\nfrom math import ceil, sqrt\nclass Mo():\n    def __init__(self, A):\n        self.M = 202020\n        self.M2 = self.M**2\n        self.A = A\n        self.N = len(A)\n        self.B = ceil(sqrt(self.N))\n        self.K = self.N // self.B + 1\n        self.Query = [[] for i in range(self.K)]\n        self.nowL = 0\n        self.nowR = 0\n        self.ans = None\n\n        #------------------------------------------\n        self.data = [0] * self.M\n\n\n    def encode(self, r, l, ind):\n        return ind + l * self.M + r * self.M2\n\n    def decode(self, v):\n        ind = v % self.M\n        v //= self.M\n        r, l = divmod(v, self.M)\n        return r, l, ind\n\n    def add(self, i):\n        val = self.data[self.A[i]]\n        self.data[self.A[i]] ^= 1\n        return val        \n\n    def delete(self, i):\n        val = self.data[self.A[i]]\n        self.data[self.A[i]] ^= 1\n        return 1 - val        \n\n    def solve(self, query):\n        Q = len(query)\n        self.ans = [0] * Q\n        for i in range(Q):\n            l, r = query[i]\n            l -= 1\n            self.Query[l//self.B].append(self.encode(r, l, i))\n\n        for i in range(self.K):\n            self.Query[i].sort()\n\n        val = 0\n        for i in range(self.K):\n            for v in self.Query[i]:\n                r, l, ind = self.decode(v)\n                while self.nowR < r:\n                    val += self.add(self.nowR)\n                    self.nowR += 1\n                while self.nowR > r:\n                    self.nowR -= 1\n                    val -= self.delete(self.nowR)\n                while self.nowL < l:\n                    val -= self.delete(self.nowL)\n                    self.nowL += 1\n                while self.nowL > l:\n                    self.nowL -= 1\n                    val += self.add(self.nowL)\n\n                self.ans[ind] = val\n\n        return self.ans\n    \nN = int(input())\nA = list(map(int, input().split()))\nQ = int(input())\nquery = []\nfor _ in range(Q):\n    query.append(list(map(int, input().split())))\n\nmo = Mo(A)\nfor a in mo.solve(query):\n    print(a)",
        "length": 82,
        "loc": 7
    },
    "abc243_c_45235100": {
        "buggy": "n = int(input())\nxy = []\nfor i in range(n):\n    i, j = map(int, input().split())\n    xy.append((i, j))\ns = input()\nfrom collections import defaultdict\nr_ok = defaultdict(bool)\nl_ok = defaultdict(bool)\n\nfor i in range(n):\n    x, y = xy[i]\n\n    if s[i] == \"R\":\n        if not r_ok[y]:\n            r_ok[y] = x\n        else:\n            r_ok[y] = min(r_ok[y], x)\n    else:\n        if not l_ok[y]:\n            l_ok[y] = x\n        else:\n            l_ok[y] = max(l_ok[y], x)\n\nfor x, y in xy:\n    if r_ok[y] < l_ok[y]:\n        print(\"Yes\")\n        exit()\nprint(\"No\")",
        "length": 29,
        "loc": 26
    },
    "abc243_d_45981948": {
        "buggy": "import sys\nfrom collections import deque,defaultdict\nimport heapq\nimport math\nimport collections\nimport itertools\n\n#sys.setrecursionlimit(10 ** 9)\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nlli = lambda n: [li() for _ in range(n)]\n\nN,X = mi()\nS = input()\nq = deque()\nfor s in S:\n    if q:\n        if s == \"U\":\n            q.pop()\n        else:\n            q.append(s)\n    else:\n        q.append(s)\n\nfor s in q:\n    if s == \"U\":\n        X = X // 2\n    elif s == \"L\":\n        X = 2 *X\n    else:\n        X = 2 * X + 1\n\nprint(X)\n",
        "length": 35,
        "loc": 20
    },
    "abc244_b_45713633": {
        "buggy": "class Motion:\n    def __init__(self) -> None:\n        self.dx = 1\n        self.dy = 0\n        self.x = 0\n        self.y = 0\n\n    def rotate(self) -> None:\n        self.dx, self.dy = self.y, -self.dx\n\n    def move(self) -> None:\n        self.x += self.dx\n        self.y += self.dy\n\n    @property\n    def get_x(self) -> int:\n        return self.x\n\n    @property\n    def get_y(self) -> int:\n        return self.y\n\n\nn = int(input())\nt = input()\n\nmotion = Motion()\nfor c in t:\n    if c == \"S\":\n        motion.move()\n    else:\n        motion.rotate()\n\nprint(f\"{motion.get_x} {motion.get_y}\")\n",
        "length": 34,
        "loc": 9
    },
    "abc244_e_45970204": {
        "buggy": "n,m,k,s,t,x = map(int, input().split())\nuvl = [list(map(int, input().split())) for _ in range(m)]\nmod = 998244353\nfrom collections import defaultdict\ngd = defaultdict(set)\nfor u,v in uvl:\n    gd[u-1].add(v-1)\n    gd[v-1].add(u-1)\n\ndp =  [[[0] * 2 for i in range(n)] for j in range(k+1)]\ndp[0][s-1][0] = 1\nfor i in range(1,k+1):\n    for u, vs in gd.items():\n        for v in vs: \n            if v == x-1:\n                dp[i][v][0] += dp[i-1][u][1]%mod\n                dp[i][v][1] += dp[i-1][u][0]%mod\n            else:\n                dp[i][v][0] += dp[i-1][u][0]%mod\n                dp[i][v][1] += dp[i-1][u][1]%mod\nprint(dp[k][t-1][0])       \n",
        "length": 21,
        "loc": 21
    },
    "abc244_g_32985131": {
        "buggy": "from collections import deque\n\nN, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n  u, v = map(int, input().split())\n  E[u - 1].append(v - 1)\n  E[v - 1].append(u - 1)\n\nS = tuple(map(int, input()))\n\nstack = deque([(0, None, True)])\nvisited = [False] * N\nP = []\nwhile stack:\n  q, p, first = stack.pop()\n  if visited[q]:\n    if not first and P[-1] != q: P.append(q)\n    continue\n  visited[q] = True\n  P.append(q)\n\n  if first:\n    for e in E[q]:\n      if e == p: continue\n      stack.append((q, None, False))\n      stack.append((e, q, True))\n\nL = [None] * N\nfor i, p in enumerate(P):\n  L[p] = i\n\nC = [0] * N\nans = []\nfor i, p in enumerate(P[1:], 1):\n  pprev = P[i - 1]\n\n  ans.append(p)\n  C[p] += 1\n  C[p] %= 2\n\n  if C[pprev] != S[pprev] and L[pprev] == i - 1:\n    ans.append(pprev)\n    C[pprev] += 1\n    C[pprev] %= 2\n\n    ans.append(p)\n    C[p] += 1\n    C[p] %= 2\n\nif C[0] != S[0]:\n  ans = ans[:-1]\n\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n",
        "length": 55,
        "loc": 55
    },
    "abc245_a_45115746": {
        "buggy": "a,b,c,d=map(int,input().split())\nif a<c:\n    print(\"Takahashi\")\nif a==c:\n    if b<=d:\n        print(\"Takahashi\")\n    else:\n        print(\"Aoki\")\nelse:\n    print(\"Aoki\")",
        "length": 10,
        "loc": 4
    },
    "abc245_b_45497244": {
        "buggy": "n = int(input())\n\nA = list(map(int, input().split()))\n\nfor i in range(2000):\n    if i not in A:\n        print(i)\n        break",
        "length": 8,
        "loc": 5
    },
    "abc246_g_33284569": {
        "buggy": "from collections import defaultdict\nimport sys\nimport os\n\nsys.setrecursionlimit(int(1e9))\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef main() -> None:\n    def check(mid: int) -> bool:\n        def dfs(cur: int, pre: int) -> int:\n            \"\"\"(\u5bf9\u65b9\u6700\u4f18\u64cd\u4f5c\u4e0b)\u5b50\u6811\u4e2d\u6743\u503c>=mid\u7684\u70b9\u7684\u4e2a\u6570\"\"\"\n            subtree = 0\n            for next in adjMap[cur]:\n                if next == pre:\n                    continue\n                subtree += dfs(next, cur)\n            subtree = max(0, subtree - 1)  # \u88ab\u5bf9\u65b9\u79fb\u9664\u4e86\u4e00\u4e2a\n            subtree += int(values[cur] >= mid)  # \u6839\u8282\u70b9\u662f\u5426\u53ef\u4ee5\n            return subtree\n\n        return dfs(0, -1) >= 1\n\n    n = int(input())\n    values = [-1] + list(map(int, input().split()))\n    adjMap = defaultdict(set)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u, v = u - 1, v - 1\n        adjMap[u].add(v)\n        adjMap[v].add(u)\n\n    # !\u6ce8\u610f\u8fd9\u91cc\u8981\u79bb\u6563\u5316\u6743\u503c \u4e0d\u7136python\u8fc7\u4e0d\u53bb\n    # left, right = 1, int(1e9 + 7)\n    # while left <= right:\n    #     mid = (left + right) // 2\n    #     if check(mid):\n    #         left = mid + 1\n    #     else:\n    #         right = mid - 1\n\n    allValues = sorted(set(values))\n    left, right = 0, len(allValues) - 1  # !\u4e8c\u5206\u7b54\u6848 allValues\u91cc\u7684\u7b2c\u51e0\u4e2a\u503c\u662f\u7b54\u6848\n    while left <= right:\n        mid = (left + right) // 2\n        if check(allValues[mid]):\n            left = mid + 1\n        else:\n            right = mid - 1\n    print(allValues[right])\n\n\nif __name__ == \"__main__\":\n    if os.environ.get(\"USERNAME\", \" \") == \"caomeinaixi\":\n        while True:\n            main()\n    else:\n        main()\n",
        "length": 58,
        "loc": 25
    },
    "abc247_b_46187946": {
        "buggy": "# import pypyjit;pypyjit.set_param(\"max_unroll_recursion=-1\")\n# from bisect import *\nfrom collections import *\n\n# from heapq import *\n# from itertools import *\n# from sortedcontainers import *\n# from math import gcd, lcm\n# from datetime import *\n# from decimal import *  # PyPy\u3060\u3068\u9045\u3044\n# from string import ascii_lowercase,ascii_uppercase\n# import numpy as np\n# from atcoder.dsu import *\n# from atcoder.segtree import *\n# from sortedcontainers import *\n# from random import *\nimport sys\nimport os\n\nis_test = os.getenv(\"ATCODER\", 0)\n# sys.setrecursionlimit(10**6) # PyPy\u306f\u546a\u6587\u3092\u4ed8\u3051\u308b\nINF = 1 << 61\nMOD = 998244353\n# MOD = 10**9 + 7\nFile = sys.stdin\n\n\ndef input():\n    return File.readline()[:-1]\n\n\n# ///////////////////////////////////////////////////////////////////////////\n\n\nN = int(input())\nnames = [input().split() for _ in range(N)]\n\ncounter = Counter()\nfor i, j in names:\n    counter[i] += 1\n    counter[j] += 1\n\nfor i, j in names:\n    if counter[i] > 1 and counter[j] > 1:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")\n",
        "length": 48,
        "loc": 45
    },
    "abc247_e_45540952": {
        "buggy": "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n\nN, X, Y, *A = map(int, read().split())\n\nindex_X = -1\nindex_Y = -1\nindex_ng = -1\nans = 0\n\nfor i in range(N):\n    if A[i] == X:\n        index_X = i\n    elif A[i] == Y:\n        index_Y = i\n    elif A[i] > X or A[i] < Y:\n        index_ng = i\n    ans += max(0, min(index_X, index_Y) - index_ng)\n\nprint(ans)\n",
        "length": 24,
        "loc": 18
    },
    "abc248_a_45470045": {
        "buggy": "s = input()\n\nA = [int(x) for x in s]\n\nfor i in range(1, 10):\n    if i not in A:\n        print(i)\n        exit()\n",
        "length": 8,
        "loc": 5
    },
    "abc248_c_45110543": {
        "buggy": "M=998244353\nn,m,k=map(int,input().split())\nq=[0]*(k+1)\nq[0]=1\nfor i in range(n):\n  nq=[0]*(k+1)\n  for j in range(k):\n    nq[j+1]+=q[j]\n  for j in range(k):\n    nq[j+1]+=nq[j]\n    nq[j+1]%=M\n  q=nq\nprint(sum(q)%M)",
        "length": 13,
        "loc": 9
    },
    "abc248_f_53199737": {
        "buggy": "N, mod = map(int, input().split())\n\ncon = [[0]*N for _ in range(N)]\nsep = [[0]*(N+1) for _ in range(N)]\ncon[0][0] = 1\nsep[0][1] = 1\nfor n in range(N)[1:]:\n    con[n][0] = 1\n    for m in range(n+1)[1:]:\n        con[n][m] = con[n-1][m] + con[n-1][m-1]*3 + sep[n-1][m]\n        con[n][m] %= mod\n    for m in range(n+2)[2:]:\n        sep[n][m] = con[n-1][m-2]*2 + sep[n-1][m-1]\n        sep[n][m] %= mod\n\nprint(*con[-1])\n",
        "length": 16,
        "loc": 16
    },
    "abc249_a_45229228": {
        "buggy": "a,b,c,d,e,f,x=map(int,input().split())\nta=(x//(a+c))*a*b+min(x%(a+c),a)*b\nao=(x//(d+f))*d*e+min(x%(d+f),d)*e\nif ta>ao:\n  print(\"takahashi\")\nelif ao>ta:\n  print(\"Aoki\")\nelse:\n  print(\"Draw\")",
        "length": 9,
        "loc": 5
    },
    "abc249_b_45037515": {
        "buggy": "S=input()\nif S.upper()!=S and S.lower()!=S and set(list(S))==len(S):\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 5,
        "loc": 2
    },
    "abc249_d_44452633": {
        "buggy": "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nfrom collections import defaultdict\nd = defaultdict(int)\n\nn=int(input())\na=list(map(int,input().split()))\nm=200005\n\nfor i in range(n):\n  d[a[i]]+=1\n  \nans=0\n\nfor i in range(1,m):\n  for j in range((m-1)//i):\n    k=i*j\n    ans+=d[k]*d[i]*d[j]\n      \nprint(ans)    ",
        "length": 21,
        "loc": 17
    },
    "abc249_f_45465070": {
        "buggy": "import heapq\ninf = float(\"inf\")\nN, K = map(int, input().split())\n\nA = [0]\nB = []\nT = []\nfor _ in range(N):\n    t, y = map(int, input().split())\n    if t == 1:\n        A.append(y)\n        B.append(T)\n        T = []\n    else:\n        T.append(y)\nB.append(T)\n\n\nans = -float(\"inf\")\nhq = []\nS = 0\nsute = []\nwhile A:\n    a = A.pop()\n    X = B.pop()\n    for x in X:\n        S += x\n        heapq.heappush(hq, x)\n    \n    while len(sute) < K + 100 and hq and hq[0] < 0:\n        t = heapq.heappop(hq)\n        S -= t\n        heapq.heappush(sute, -t)\n    \n    while sute and hq and -sute[0] > hq[0]:\n        a = -heapq.heappop(sute)\n        b = heapq.heappop(hq)\n        \n        S += a - b\n        \n        heapq.heappush(hq, a)\n        heapq.heappush(sute, -b)\n    \n    \n    while len(sute) > K:\n        t = -heapq.heappop(sute)\n        S += t\n        heapq.heappush(hq, t)\n    \n    \n    ans = max(ans, a + S)\n    \n    \n    K -= 1\n    if K < 0:\n        break\n\nprint(ans)",
        "length": 58,
        "loc": 30
    },
    "abc250_a_54768832": {
        "buggy": "h, w = map(int, input().split())\nr, c = map(int, input().split())\nans = 4\nif r == 1:\n  ans -= 1\nif r == h:\n  ans -= 1\nif w == 1:\n  ans -= 1\nif w == c:\n  ans -= 1\nprint(ans)",
        "length": 12,
        "loc": 8
    },
    "abc250_c_45205318": {
        "buggy": "import sys\nimport copy\nfrom collections import deque,defaultdict\nimport math\nimport heapq\nfrom itertools import accumulate\nimport itertools \nfrom functools import reduce\n#import pypyjit\n#pypyjit.set_param('max_unroll_recursion=-1')\nsys.setrecursionlimit(10**8)\nmod = 10**9 + 7\nINF = math.inf\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nfrom functools import lru_cache #@lru_cache(maxsize=None)\n\ndef main():\n    N,Q = mi()\n    tbl = [i for i in range(N)] #tbl[i] := \u30dc\u30fc\u30ebi\u306eindex\n    index = [i for i in range(N)] #index[i] := index i \u306e\u30dc\u30fc\u30eb\n    for _ in range(Q):\n        x = ii()-1\n        if tbl[x] == N-1:\n            y = index[tbl[x]-1]\n            i,j = tbl[x],tbl[x]-1\n            tbl[x],tbl[y] = j,i\n            index[j],index[i] = x,y\n        else:\n            y = index[tbl[x]+1]\n            i,j = tbl[x],tbl[x]+1\n            tbl[x],tbl[y] = j,i\n            index[j],index[i] = x,y\n\n    print(*map(lambda x:x+1,tbl),sep=\" \")\n    \nif __name__==\"__main__\":\n    main()",
        "length": 40,
        "loc": 37
    },
    "abc250_d_44996552": {
        "buggy": "n = int(input())\nprl = [0] *(10**6)\ndef pr_jg(p):\n    pr = int(p ** (1/2)) + 1\n    m = 2\n    while m <= pr:\n        if p % m == 0:\n            return(False)\n        m += 1\n    return True\n\nk = int((n//2) ** (1/3))\nprl[0] = 2\ncur = 1\nfor i in range(3,k+1):\n    if pr_jg(i):\n        prl[cur] = i\n        cur += 1\nmaxv = cur-1\nans = 0\nfor i in range(cur):\n    for j in range(maxv,i,-1):\n        if prl[i] * (prl[j]**3) <= n:\n            maxv = j\n            ans += j - i\n            break\n \nprint(ans)",
        "length": 28,
        "loc": 15
    },
    "abc250_e_46017900": {
        "buggy": "from collections import defaultdict\n\nn=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nans=[[0,-1] for _ in range(n)]\n\nnowa=set()\nnowb=set()\nnotcheck=set()\n\nd=defaultdict(int)\n\ncnt=0\n\nfor i in range(n):\n  if a[i] in notcheck:\n    notcheck.remove(a[i])\n  if notcheck:\n    ans[i][0]=ans[i-1][0]\n  if a[i] in nowa:\n    ans[i]=ans[i-1]\n    continue\n  if a[i] in nowb:\n    ans[i][0]=max(ans[i-1][0],d[a[i]])\n    if not notcheck:\n      ans[i][1]=cnt-1\n    nowa.add(a[i])\n    continue\n  nowa.add(a[i])\n  bool=False\n  while cnt<n:\n    if b[cnt] not in nowa:\n      notcheck.add(b[cnt])\n    if b[cnt] in nowb:\n      cnt+=1\n      continue\n    else:\n      d[b[cnt]]=cnt\n      nowb.add(b[cnt])\n    if b[cnt]==a[i]:\n      bool=True\n      ans[i][0]=cnt\n      cnt+=1\n      while cnt<n:\n        if b[cnt]!=a[i]:\n          break\n        cnt+=1\n      if not notcheck:\n        ans[i][1]=cnt-1\n    if bool:\n      break\n    cnt+=1\n  if not bool:\n    break\n    \nq=int(input())\n\nfor i in range(q):\n  x,y=map(int,input().split())\n  x-=1\n  y-=1\n  if ans[x][0]<=y<=ans[x][1]:\n    print('Yes')\n  else:\n    print('No')",
        "length": 67,
        "loc": 47
    },
    "abc251_a_45011950": {
        "buggy": "S = input()\nfor i in range(6):\n    SS = S*i\n    if len(SS) == 6:\n        print(SS)\n        break\n",
        "length": 6,
        "loc": 2
    },
    "abc251_b_45515530": {
        "buggy": "from itertools import combinations\n\ndef ans_count(num_list, num, W, ans):\n    result = 0\n    combinations_list = list(combinations(num_list, num))\n    for combination in combinations_list:\n        # print(combination)\n        if sum(combination) < W:\n            ans.append(sum(combination))\n\n    return ans\n\n\nN,W = map(int,input().split())\nnum_map = map(int,input().split())\nnum_list = list(num_map)\nans = []\n\nif len(num_list) >= 1:\n    ans = ans_count(num_list,1,W,ans)\n    # print(str(1) + str(ans))\nif len(num_list) >= 2:\n    ans = ans_count(num_list,2,W,ans)\n    # print(str(2) + str(ans))\nif len(num_list) >= 3:\n    ans = ans_count(num_list,3,W,ans)\n    # print(str(3) + str(ans))\n    \nnum_set = set(ans)\nprint(len(num_set))",
        "length": 30,
        "loc": 8
    },
    "abc251_c_44644261": {
        "buggy": "n_strings = int(input())\ndata = []\nfor i in range(n_strings):\n    info = input().split()\n    data.append((info[0], int(info[1])))\n\nmax_strings = set()\nmax_score = 0\nmax_index = 0\n\nfor i in range(n_strings):\n    string, score = data[i]\n    if score > max_score and string not in max_strings:\n        max_score = score\n        max_strings.add(string)\n        max_index = i\n\nprint(max_index + 1)",
        "length": 18,
        "loc": 17
    },
    "abc251_d_44691668": {
        "buggy": "w=int(input())\nprint(299)\nA=[i for i in range(1,100)]+[100*i for i in range(1,100)]+[10000*i for i in range(1,101)]\nprint(*A)",
        "length": 4,
        "loc": 2
    },
    "abc251_f_47833391": {
        "buggy": "from collections import *\nimport sys\nimport heapq\nimport bisect\nimport itertools\nfrom functools import lru_cache\nimport math\nimport copy\n\nsys.setrecursionlimit(int(1e7))\n\ndxdy1 = ((0, 1), (0, -1), (1, 0), (-1, 0))\ndxdy2 = ((0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1))\ndxdy3 = ((0, 1), (1, 0))\ndxdy4 = ((1, 1), (1, -1), (-1, 1), (-1, -1))\nINF = float(\"inf\")\nMOD = 998244353\nmod = 998244353\nMOD2 = 10**9 + 7\nmod2 = 10**9 + 7\n# memo : len([a,b,...,z])==26\n\ninput = lambda: sys.stdin.readline().rstrip()\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nN, M = mi()\nadj = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v = mi()\n    u -= 1\n    v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\n\nans1 = []\nq = deque()\nvisited = [0] * N\nq.append((-1, 0))\nwhile q:\n    pre, node = q.pop()\n    if pre >= 0:\n        ans1.append((pre + 1, node + 1))\n    visited[node] = 1\n    for nxt in adj[node]:\n        if visited[nxt] == 1:\n            continue\n        q.append((node, nxt))\nfor z, w in ans1:\n    print(z, w)\n\nans2 = []\nvisited = [0] * N\nq.append(0)\nwhile q:\n    node = q.popleft()\n    visited[node] = 1\n    for nxt in adj[node]:\n        if visited[nxt] == 1:\n            continue\n        visited[nxt] = 1\n        q.append(nxt)\n        ans2.append((node + 1, nxt + 1))\nfor z, w in ans2:\n    print(z, w)\n",
        "length": 65,
        "loc": 42
    },
    "abc251_g_31757947": {
        "buggy": "import sys\nimport numpy as np\n\n\nreadline = sys.stdin.readline\n\nN = int(input())\nxy = np.array([list(map(int, readline().split())) for _ in range(N)])\ndxdy = np.diff(xy, axis=0, append=[xy[0]])\ncoef = np.array([dxdy[:, 1], -dxdy[:, 0]]).T\ncons = np.sum(coef * xy, axis=1, keepdims=True)\n\nM = int(input())\nuv = np.array([list(map(int, readline().split())) for _ in range(M)])\ndist = np.max(coef @ uv.T + cons, axis=1)\n\nQ = int(input())\nab = np.array([list(map(int, readline().split())) for _ in range(Q)])\nans = np.all(ab @ coef.T <= dist, axis=1)\n\nprint(*np.where(ans, \"Yes\", \"No\"), sep='\\n')",
        "length": 21,
        "loc": 15
    },
    "abc252_a_45686937": {
        "buggy": "abc=\"abcdefghijklnmopqrstuvwxyz\"\nprint(abc[int(input())-97])",
        "length": 2,
        "loc": 1
    },
    "abc252_b_45243368": {
        "buggy": "import sys\nimport copy\nfrom collections import deque,defaultdict\nimport math\nimport heapq\nfrom itertools import accumulate\nimport itertools \nfrom functools import reduce\n#import pypyjit\n#pypyjit.set_param('max_unroll_recursion=-1')\nsys.setrecursionlimit(10**8)\nmod = 10**9 + 7\nINF = math.inf\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nfrom functools import lru_cache #@lru_cache(maxsize=None)\n\ndef main():\n    N,K = mi()\n    A = [(j,i) for i,j in enumerate(li())]\n    B = set(li())\n    A.sort(reverse=True)\n    M = A[0][0]\n    for i in range(N):\n        if A[i][0] == M:\n            if A[i][1] in B:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\n\nif __name__==\"__main__\":\n    main()",
        "length": 35,
        "loc": 28
    },
    "abc252_c_45002861": {
        "buggy": "n=int(input())\ncount=[[0]*10 for _ in range(10)]\ntime=[[] for _ in range(10)]\nfor i in range(n):\n    s=input()\n    for x in range(10):\n        s_x=int(s[x])\n        count[s_x][x]+=1\n        time[s_x].append(i+(count[s_x][x]-1)*10)\nans=10**100\nfor i in range(10):\n    ans=min(ans,max(time[i]))\nprint(ans)",
        "length": 13,
        "loc": 9
    },
    "abc252_d_45497724": {
        "buggy": "N = int(input())\nA = list(map(int,input().split()))\nB=[]\nfor i in range(1000000):\n  B.append(0)\nfor i in A:\n  B[i]+=1\nans = N*(N-1)*(N-2)/6\nfor i in B:\n  ans -= i*(i-1)/2*(N-i)\n  ans -= i*(i-1)*(i-2)/6\nprint(ans)",
        "length": 12,
        "loc": 12
    },
    "abc252_e_45066699": {
        "buggy": "import heapq\nN,M=map(int,input().split())\nG=[[] for i in range(N+1)]\nH=[[0,0]]\nfor i in range(M):\n    a,b,c=map(int,input().split())\n    G[a].append(i+1)\n    G[b].append(i+1)\n    H.append([a+b,c])\n    \nQ=[]\ninf=10**9+10\nD=[inf for i in range(N+1)]\nmemo=[-1 for i in range(N+1)]\nD[1]=0\nheapq.heappush(Q,[0,1])\nwhile Q:\n    cost,cur=heapq.heappop(Q)\n    if D[cur]<cost:\n        continue\n    for i in G[cur]:\n        dst=H[i][0]-cur\n        w=H[i][1]\n        if D[dst]>D[cur]+w:\n            D[dst]=D[cur]+w\n            memo[dst]=i\n            heapq.heappush(Q,[D[dst],dst])\n            \n\nans=[]\nfor i in range(N+1):\n    if memo[i]!=-1:\n        ans.append(memo[i])\nprint(*ans)",
        "length": 34,
        "loc": 12
    },
    "abc253_a_45510646": {
        "buggy": "a, b, c = map(int, input().split())\n\nif (a + c) // 2 == b:\n    print('Yes')\nelse:\n    print('No')\n",
        "length": 6,
        "loc": 3
    },
    "abc253_b_45785764": {
        "buggy": "h, w = map(int, input().split())\ns = []\no = []\nfor _ in range(h):\n    s.append(input())\nfor row in range(h):\n    for col in range(w):\n        if s[row][col] == \"o\":\n            o.append([row,col])\nhirai = abs(o[0][0]- o[1][0]) + abs(o[1][0]-o[1][1])\nprint(hirai)",
        "length": 11,
        "loc": 10
    },
    "abc253_d_46046758": {
        "buggy": "n,a,b=map(int,input().split())\nif a>b:\n  a,b=b,a\nax,bx=a,b\nwhile ax>0:\n  ax,bx=bx%ax,ax\ng=bx\nans=0\nconst=a*b//g\nrui=n//const\nza=n%const\nans+=(rui*const*2+za+1)*za//2-(rui*const*2+za//a*a+a)*(za//a)//2-(rui*const*2+za//b*b+b)*(za//b)//2\nans+=rui*const*(const+1)//2*(const-const//a-const//b+1)\nans+=rui*(const*(const+1)//2-const*(1+const//a)//2-const*(1+const//b)//2+const)\nprint(ans)",
        "length": 15,
        "loc": 13
    },
    "abc253_e_45941559": {
        "buggy": "from itertools import accumulate\nmod = 998244353\nN, M, K = map(int, input().split())\ndp = [[0]*(M+1) for _ in range(N)]\nfor a in range(1, M+1):\n    dp[0][a] = 1\nfor i in range(1, N):\n    ac0 = list(accumulate(dp[i-1]))\n    ac1 = list(accumulate(reversed(dp[i-1])))\n    ac1.reverse()\n    for a in range(1, M-K+1):\n        dp[i][a+K] = ac0[a] % mod\n    for a in range(K+1, M+1):\n        dp[i][a-K] = (dp[i][a-K] + ac1[a]) % mod\nprint(sum(dp[N-1]) % mod)",
        "length": 15,
        "loc": 13
    },
    "abc254_a_45547154": {
        "buggy": "print(int(input())%100)",
        "length": 1,
        "loc": 1
    },
    "abc254_c_44995126": {
        "buggy": "n,k=map(int,input().split())\na=list(map(int,input().split()))\nasort=sorted(a)\n\nak=[[] for _ in range(k)]\nfor i in range(n):\n  ak[i%k].append(a[i])\n\naksort=[0]*k\nfor i in range(k):\n  aksort[i] = sorted(ak[i])\n\nprint(aksort)\nprint(asort)\nfor i in range(n):\n  if asort[i] != aksort[i%k][i//k]:\n    print(\"No\")\n    exit()\nprint('Yes')",
        "length": 19,
        "loc": 0
    },
    "abc254_d_51493507": {
        "buggy": "n=int(input())\ndef pf(n):\n a,f={},2\n while f*f<=n:\n  if n%f:f+=1\n  else:a[f]=a.get(f,0)+1;n//=f\n if n>1:a[n]=a.get(n,0)+1\n return a\ns=[i*i for i in range(1,n)if i*i<=n]\nans=0\nfor i in range(1,n+1):\n  a=1\n  for k,v in pf(i).items():\n    if v%2:\n      a*=k\n  for j in s:\n    if a*j<=n:\n      ans+=1\n    else:\n      break\nprint(ans)",
        "length": 21,
        "loc": 9
    },
    "abc254_f_48945628": {
        "buggy": "from collections import *\nimport sys\nimport heapq\nimport bisect\nimport itertools\nfrom functools import lru_cache\nfrom types import GeneratorType\nfrom fractions import Fraction\nimport math\nimport copy\n\nsys.setrecursionlimit(int(1e7))\n# @lru_cache(maxsize=None) # CPython\u7279\u5316\n# @bootstrap # PyPy\u7279\u5316(\u3053\u3063\u3061\u306e\u307b\u3046\u304c\u901f\u3044) yield dfs(), yield None\u3092\u5fd8\u308c\u305a\u306b\n\n\ndef bootstrap(f, stack=[]):  # yield\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\ndxdy1 = ((0, 1), (0, -1), (1, 0), (-1, 0))  # \u4e0a\u4e0b\u5de6\u53f3\ndxdy2 = ((0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1))  # 8\u65b9\u5411\u3059\u3079\u3066\ndxdy3 = ((0, 1), (1, 0))  # \u53f3 or \u4e0b\ndxdy4 = ((1, 1), (1, -1), (-1, 1), (-1, -1))  # \u659c\u3081\nINF = float(\"inf\")\n_INF = 1 << 60\nMOD = 998244353\nmod = 998244353\nMOD2 = 10**9 + 7\nmod2 = 10**9 + 7\n# memo : len([a,b,...,z])==26\n# memo : 2^20 >= 10^6\n# \u5c0f\u6570\u306e\u8a08\u7b97\u3092\u907f\u3051\u308b : x/y -> (x*big)//y  ex:big=10**9\n# @:\u5c0f\u3055\u3044\u6587\u5b57, ~:\u5927\u304d\u3044\u6587\u5b57,None: \u7a7a\u306e\u6587\u5b57\u5217\n# \u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\uff1agcd(x,y)=gcd(x,y-x)\n\ninput = lambda: sys.stdin.readline().rstrip()\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nii = lambda: int(input())\npy = lambda: print(\"Yes\")\npn = lambda: print(\"No\")\npf = lambda: print(\"First\")\nps = lambda: print(\"Second\")\n\n\n# https://raw.githubusercontent.com/shakayami/ACL-for-python/master/segtree.py\nclass segtree:\n    n = 1\n    size = 1\n    log = 2\n    d = [0]\n    op = None\n    e = 10**15\n\n    def __init__(self, V, OP, E):\n        self.n = len(V)\n        self.op = OP\n        self.e = E\n        self.log = (self.n - 1).bit_length()\n        self.size = 1 << self.log\n        self.d = [E for i in range(2 * self.size)]\n        for i in range(self.n):\n            self.d[self.size + i] = V[i]\n        for i in range(self.size - 1, 0, -1):\n            self.update(i)\n\n    def set(self, p, x):\n        assert 0 <= p and p < self.n\n        p += self.size\n        self.d[p] = x\n        for i in range(1, self.log + 1):\n            self.update(p >> i)\n\n    def get(self, p):\n        assert 0 <= p and p < self.n\n        return self.d[p + self.size]\n\n    def prod(self, l, r):\n        assert 0 <= l and l <= r and r <= self.n\n        sml = self.e\n        smr = self.e\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                sml = self.op(sml, self.d[l])\n                l += 1\n            if r & 1:\n                smr = self.op(self.d[r - 1], smr)\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return self.op(sml, smr)\n\n    def all_prod(self):\n        return self.d[1]\n\n    def max_right(self, l, f):\n        assert 0 <= l and l <= self.n\n        assert f(self.e)\n        if l == self.n:\n            return self.n\n        l += self.size\n        sm = self.e\n        while 1:\n            while l % 2 == 0:\n                l >>= 1\n            if not (f(self.op(sm, self.d[l]))):\n                while l < self.size:\n                    l = 2 * l\n                    if f(self.op(sm, self.d[l])):\n                        sm = self.op(sm, self.d[l])\n                        l += 1\n                return l - self.size\n            sm = self.op(sm, self.d[l])\n            l += 1\n            if (l & -l) == l:\n                break\n        return self.n\n\n    def min_left(self, r, f):\n        assert 0 <= r and r <= self.n\n        assert f(self.e)\n        if r == 0:\n            return 0\n        r += self.size\n        sm = self.e\n        while 1:\n            r -= 1\n            while r > 1 and (r % 2):\n                r >>= 1\n            if not (f(self.op(self.d[r], sm))):\n                while r < self.size:\n                    r = 2 * r + 1\n                    if f(self.op(self.d[r], sm)):\n                        sm = self.op(self.d[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.op(self.d[r], sm)\n            if (r & -r) == r:\n                break\n        return 0\n\n    def update(self, k):\n        self.d[k] = self.op(self.d[2 * k], self.d[2 * k + 1])\n\n    def __str__(self):\n        return str([self.get(i) for i in range(self.n)])\n\n    def get_list(self):\n        return [self.get(i) for i in range(self.n)]  # \u30aa\u30ea\u30b8\u30ca\u30eb\u3067\u8ffd\u52a0\n\n\nN, Q = mi()\nA = li()\nB = li()\nAA = []\nBB = []\n\nfor i in range(N - 1):\n    AA.append(A[i + 1] - A[i])\n    BB.append(B[i + 1] - B[i])\nseg1 = segtree(AA, math.gcd, 0)  # V\u306e\u8981\u7d20\u3068E\u306e\u5024\u306f\u540c\u3058\u306b\u3059\u308b #10**9 -> INF\nseg2 = segtree(BB, math.gcd, 0)\nfor _ in range(Q):\n    h1, h2, w1, w2 = mi()\n    h1 -= 1\n    h2 -= 1\n    w1 -= 1\n    w2 -= 1\n    print(math.gcd(A[h1] + B[w1]), seg1.prod(h1, h2), seg2.prod(w1, w2))\n",
        "length": 188,
        "loc": 188
    },
    "abc255_c_45259199": {
        "buggy": "x, a, d, n = map(int, input().split())\n\nif d == 0:\n    print(abs(x - a))\n    exit(0)\n\nm = (x - a) // d + 1\n\nif m > n:\n    m = n - 5\n\nif m <= 6:\n    m = 6\n\n# +-5\u500b\u8abf\u3079\u308b\nans = -1\nfor i in range(-5, 6):\n    an = a + d * (m + i - 1)\n\n    # INF\u8a2d\u5b9a\u304c\u3081\u3093\u3069\u304f\u3055\u3044\n    if ans == -1:\n        ans = abs(x - an)\n\n    ans = min(ans, abs(x - an))\n\nprint(ans)\n",
        "length": 26,
        "loc": 18
    },
    "abc256_b_44471761": {
        "buggy": "n=int(input())\na=list(map(int,input().split()))\n\nfor i in range(n):\n  for j in range(i):\n    a[j]+=a[i]\nans=0\nfor i in range(n):\n  ans+= a[i]>=5\nprint(ans)",
        "length": 10,
        "loc": 9
    },
    "abc256_f_41932099": {
        "buggy": "def extgcd(a, b):\n    if b:\n        d, y, x = extgcd(b, a % b)\n        y -= (a // b) * x\n        return d, x, y\n    return a, 1, 0\n\n# V = [(X_i, Y_i), ...]: X_i (mod Y_i)\ndef remainder(V):\n    x = 0; d = 1\n    for X, Y in V:\n        g, a, b = extgcd(d, Y)\n        x, d = (Y*b*x + d*a*X) // g, d*(Y // g)\n        x %= d\n    return x, d\n\n#\u4ee5\u4e0bmodinv\ndef mod_inv(a, m):\n    g, x, y = extgcd(a, m)\n\n    if g != 1:\n        raise Exception(\"a and m are not coprime.\")\n\n    if x < 0:\n        x += m\n\n    return x\n\n        \n#####segfunc#####\ndef Sum(x, y):\n    return x+y\n#################\n\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n        \n    def setValue(self,x,i):\n        self.update(x-1,i)\n        \n    def getMax(self,i,j):\n        return self.query(i-1,j)\n\nimport sys\ninput=sys.stdin.readline\nN,Q=map(int,input().split())\nA=list(map(int,input().split()))\nAi=[]\nAii=[]\nfor i in range(N):\n    Ai.append(A[i]*(i+1))\n    Aii.append(A[i]*(i+1)*(i+1))\nsta=SegTree(A,Sum,0)\nstai=SegTree(Ai,Sum,0)\nstaii=SegTree(Aii,Sum,0)\np=998244353\nfor _ in range(Q):\n    q=list(map(int,input().split()))\n    if q[0]==1:\n        q,x,v=q\n        sta.update(x-1,v)\n        stai.update(x-1,v*x)\n        staii.update(x-1,v*x*x)\n    else:\n        q,x=q\n        print((sta.getMax(0,x-1)*(x+1)*(x+2)-stai.getMax(0,x-1)*(2*x+3)+staii.getMax(0,x-1))*mod_inv(2,p)%p)",
        "length": 123,
        "loc": 123
    },
    "abc257_a_46189766": {
        "buggy": "from string import ascii_uppercase\n\nN, X = map(int, input().split())\n\nprint(ascii_uppercase[X // N - 1])\n",
        "length": 5,
        "loc": 5
    },
    "abc257_c_45044587": {
        "buggy": "\"\"\"\n\u6bce\u56dehat\u306e\u30d3\u30c3\u30c8\u5217\u3092\u751f\u6210\u3057\u3066\u78ba\u304b\u3081\u308b\u3063\u3066\u3044\u3046\u306e\u304c\u3060\u3081\n\u5883\u76ee\u3092\u52d5\u304b\u3057\u3066\u3044\u3063\u3066\u3001\u5883\u76ee\u4ed8\u8fd1\u3092\u898b\u308c\u3070\u3044\u3044\n\"\"\"\n\nn = int(input())\ns = list(input())\nw = list(map(int, input().split()))\n\npeople = []\n# \u6b63\u89e3\u6570\n# \u6700\u521d\u30010\u756a\u76ee\u306e\u4eba\u3088\u308a\u5de6\u306b\u3042\u3063\u3066\u3001\u5168\u30661\u3068\u4e88\u6e2c\u3059\u308b\u306e\u30671\u306e\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u304a\u304f\ncnt = 0\nfor i in range(n):\n    people.append((w[i], s[i]))\n    if s[i] == '1':\n        cnt += 1\npeople.sort()\n\nans = cnt\nfor i in range(n):  # \u5de6\u304b\u3089\u4ed5\u5207\u308a\u3092\u3054\u304b\u3059\n    w, s = people[i]\n\n    # 0\u306e\u4eba\u3092\u98db\u3073\u8d8a\u3048\u305f\u30891\u8db3\u3059\n    if s == '0':\n        cnt += 1\n    # 1\u306e\u4eba\u3092\u98db\u3073\u8d8a\u3048\u305f\u30891\u6e1b\u3089\u3059\n    if s == '1':\n        cnt -= 1\n\n    # \u96a3\u306e\u4eba\u3068\u4f53\u91cd\u304c\u540c\u3058\u306a\u3089\u305d\u308c\u306f\u5883\u754c\u3068\u306f\u3044\u3048\u306a\u3044\n    # ans\u306e\u66f4\u65b0\u3092\u884c\u308f\u306a\u3044(cnt\u306e\u8a08\u7b97\u3060\u3051\u3057\u3066\u304a\u3044\u3066\u30b9\u30ad\u30c3\u30d7)\n    if i+1 >= n or w != people[i+1]:\n        ans = max(ans, cnt)\n\nprint(ans)\n",
        "length": 36,
        "loc": 33
    },
    "abc257_d_46215877": {
        "buggy": "n=int(input())\npp=[]\nfor i in range(n):\n    x,y,p=map(int,input().split())\n    pp.append((x,y,p))\n\nfrom collections import deque\ndef bfs(node,s):\n    used=[False]*n\n    d=deque()\n    d.append(node)\n    used[node]=True\n    while d:\n        tmp=d.popleft()\n        p=s*pp[tmp][2]\n        for i in range(n):\n            if i==tmp:\n                continue\n            dist=abs(pp[tmp][0]-pp[i][0])+abs(pp[tmp][1]-pp[i][1])\n            if not(used[i]) and p>=dist:\n                used[i]=True\n                d.append(i)\n        \n    return all(used)\n\nl=1\nr=4*10**9\nwhile r-l>1:\n    frag=True\n    mid=(l+r)//2\n    for i in range(n):\n        if bfs(i,mid):\n            r=mid\n            frag=False\n            break\n    if frag:\n        l=mid\nprint(r)",
        "length": 38,
        "loc": 26
    },
    "abc257_e_45047426": {
        "buggy": "import sys\nfrom functools import lru_cache\nfrom collections import defaultdict\n\n\nsys.setrecursionlimit(10**9)\ndef I(): return input()\ndef IS(): return input().split()\ndef II(): return int(input())\ndef LI(): return list(input())\ndef MI(): return map(int,input().split())\ndef LMI(): return list(map(int,input().split()))\ndef LLMI(number): return [list(map(int,input().split())) for _ in range(number)]\n\ndef generate_input()->list:\n    import random\n    inputdata = []\n    n = random.randint(0, 100)\n    inputdata.append(n)\n    return inputdata\n\n\ndef simple_solve(n):\n    ans = 0\n    return ans\n\n\ndef solve(n, c):\n    min_cost = min(c)\n    digits = n // min_cost\n    new_c = []\n    for v in c:\n        new_c.append(v - min_cost)\n    remain_cash = n - (digits * min_cost)\n    new_c.reverse()\n    ans = []\n    for i, v in enumerate(new_c):\n        if remain_cash >= v:\n            if v == 0:\n                cnt = digits - len(ans)\n            else:\n                cnt = remain_cash // v\n                remain_cash -= cnt * v\n            for j in range(cnt):\n                ans.append(str(9-i))\n        else:\n            continue\n\n    return ''.join(ans)\n\n\nif __name__=='__main__':\n    test = False\n    if test:\n        inputdata = generate_input()\n        a = simple_solve(*inputdata)\n        b = solve(*inputdata)\n        if a != b:\n            print(*inputdata)\n            print(a, b)\n            exit(1)\n    else:\n        inputdata = []\n        inputdata.append(II())\n        inputdata.append(LMI())\n        print(solve(*inputdata))",
        "length": 66,
        "loc": 48
    },
    "abc258_a_44904869": {
        "buggy": "# https://atcoder.jp/contests/abc258/tasks/abc258_a\n\nK = int(input())\n\nif K > 69:\n    print(f\"22:{K - 60}\")\nelif K > 59:\n    print(f\"22:0{K - 60}\")\nelse:\n    print(f\"21:{K}\")",
        "length": 10,
        "loc": 9
    },
    "abc258_b_44828873": {
        "buggy": "n = int(input())\nA = [input() for _ in range(n)]\n\nD = [(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1),(0,1),(1,1)]\n\nans = []\nfor r in range(n):\n    for c in range(n):\n        for dr,dc in D:\n            tmp = []\n            for i in range(n):\n                tmp.append(A[(r+dr*i)%n][(c+dc*i)%n])\n        ans.append(\"\".join(tmp))\n\nans.sort()\nprint(ans[-1])",
        "length": 16,
        "loc": 13
    },
    "abc258_f_54437029": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\ndef dist(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef push(x, y, B, K):\n    if x % B == 0 or y % B == 0:\n        return [(x, y, 0)]\n    dx, ux = x//B*B, (x+B-1)//B*B\n    L = []\n    L.append((dx, y, K * abs(x - dx)))\n    L.append((ux, y, K * abs(x - ux)))\n    dy, uy = y//B*B, (y+B-1)//B*B\n    L.append((x, dy, K * abs(y - dy)))\n    L.append((x, uy, K * abs(y - uy)))\n    return L\n\ndef push2(x, y, B):\n    L = []\n    if y % B != 0:\n        dy, uy = y//B*B, (y+B-1)//B*B\n        L.append((x, dy, abs(y - dy)))\n        L.append((x, uy, abs(y - uy)))\n    else:\n        dx, ux = x//B*B, (x+B-1)//B*B\n        L.append((dx, y, abs(x - dx)))\n        L.append((ux, y, abs(x - ux)))\n    return L\n        \n\nT = int(input())\nfor _ in range(T):\n    B, K, sx, sy, gx, gy = map(int, input().split())\n    start = push(sx, sy, B, K)\n    goal = push(gx, gy, B, K)\n    ans = dist(sx, sy, gx, gy) * K\n    for sx, sy, sc in start:\n        for gx, gy, gc in goal:\n            if sx == gx or sy == gy:\n                ans = min(ans, sc + gc + dist(sx, sy, gx, gy))\n                continue\n            start2 = push2(sx, sy, B)\n            goal2 = push2(gx, gy, B)\n            for sx2, sy2, sc2 in start2:\n                for gx2, gy2, gc2 in goal2:\n                    ans = min(ans, sc + gc + sc2 + gc2 + dist(sx2, sy2, gx2, gy2))\n    \n    print(ans)",
        "length": 49,
        "loc": 40
    },
    "abc259_a_46054994": {
        "buggy": "N, M, X, T, D = map(int, input().split())\nh = T\n\nif M >= X:\n    print(T)\nelse:\n    print(T + (X - M) * D)",
        "length": 7,
        "loc": 7
    },
    "abc259_c_45350488": {
        "buggy": "s = input()\nt = input()\nk = 0\nl = []\nm = []\nfor i in range(1,len(s)):\n  if s[i-1]!=s[i]:\n    l.append(s[k:i])\n    k = i\nl.append(s[k:])\nk = 0\nfor j in range(1,len(t)):\n  if t[j-1]!=t[j]:\n    m.append(t[k:j])\n    k = j\nm.append(t[k:])\nif len(m)!=len(l):\n  print(\"No\")\n  exit()\nfor o in range(len(l)):\n  if l[o]==m[o]:\n    continue\n  elif list(l[o])<list(m[o]) and len(l[o])>=2:\n    continue\n  else:\n    print(\"No\")\n    exit()\nprint(\"Yes\")",
        "length": 28,
        "loc": 23
    },
    "abc259_d_52382935": {
        "buggy": "class UnionFind:\n    def __init__(self, n:int) -> None:\n        self.parents = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x:int) -> int:\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x] \n\n    def union(self, x:int, y:int) -> None:\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x == root_y:\n            return\n        if self.rank[root_x] < self.rank[root_y]:\n            root_x, root_y = root_y, root_x\n        self.parents[root_y] = root_x\n\n        if self.rank[root_x] == self.rank[root_y]:\n            self.rank[root_x] += 1\n\n    def same(self, x:int, y:int) -> bool:\n        return self.find(x) == self.find(y)\n\ndef diff(x, y, v, w):\n    return (x-v)**2+(v-w)**2\n\nN = int(input())\nuf = UnionFind(N+2)\nma = {}\nradius = [0 for i in range(N+2)]\nsx, sy, tx, ty = map(int, input().split())\n\nfor i in range(N):\n    x, y, r = map(int, input().split())\n    radius[i] = r\n    ma[(x, y)] = i\n\nma[(sx, sy)] = N\nma[(tx, ty)] = N+1\n\nfor x, y in ma.keys():\n    for v, w in ma.keys():\n        numxy = ma[(x, y)]\n        numvw = ma[(v, w)]\n        if x == v and y == w:\n            continue\n        d2 = diff(x, y, v, w)\n        if (radius[numxy]-radius[numvw])**2 <= d2 <= (radius[numxy]+radius[numvw])**2:\n            uf.union(numxy, numvw)\n\nif uf.same(ma[(sx, sy)], ma[(tx, ty)]):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "length": 57,
        "loc": 28
    },
    "abc260_a_45791402": {
        "buggy": "S = input()\n\nif len(set(S)) == 1:\n    print(-1)\nelif len(set(S)) == 3:\n    print(list(S)[0])\nelif len(set(S)) == 2:\n    S = list(S)\n    s = S.count(S[0])\n    if s == 1:\n        print(S[0])\n    else:\n        print(S[1])\n\n",
        "length": 14,
        "loc": 12
    },
    "abc260_b_53041244": {
        "buggy": "n, x, y, z = map(int, input().split())\na = [(ai, -i - 1) for i, ai in enumerate(map(int, input().split()))]\nb = [(bi, -i - 1) for i, bi in enumerate(map(int, input().split()))]\n\ntotal = sorted([(ai[0] + bi[0], ai[1]) for ai, bi in zip(a, b)], reverse=True)\na.sort(reverse=True)\nb.sort(reverse=True)\n\nans = set()\n\nfor i in range(x):\n    ans.add(-a[i][1])\n\nj = 0\nfor i in range(n):\n    if j == y:\n        break\n    if -b[i][1] in ans:\n        continue\n    j += 1\n    ans.add(-b[i][1])\n\nj = 0\nfor i in range(n):\n    if j == z:\n        break\n    if -total[i][1] in ans:\n        continue\n    j += 1\n    ans.add(-total[i][1])\n\nprint(*ans, sep='\\n')\n",
        "length": 32,
        "loc": 32
    },
    "abc260_d_51017696": {
        "buggy": "from atcoder.dsu import DSU\nfrom atcoder.segtree import SegTree\n\nN, K = map(int, input().split())\nP = list(map(int, input().split()))\nans = [-1] * (N + 1)\nif K == 1:\n    for i,p in enumerate(P,start= 1):\n        ans[p] = i\n    print(*ans)        \n    exit()\n    \ndsu = DSU(N + 1)\nst = SegTree(max, 0, [0] * (N + 1))\ndic = {}\nfor i, p in enumerate(P, start=1):\n    x = st.max_right(p, lambda v: v == 0)\n    if x > N or x < p:\n        st.set(p, 1)\n    elif x > p:\n        st.set(x, 0)\n        dsu.merge(x, p)\n        if dsu.size(x) == K:\n            dic[dsu.leader(x)] = i\n        else:\n            st.set(p, 1)\n\nfor i in range(N + 1):\n    x = dsu.leader(i)\n    if x in dic:\n        ans[i] = dic[x]\nprint(*ans[1:])\n",
        "length": 32,
        "loc": 10
    },
    "abc260_f_46046400": {
        "buggy": "s,t,m=map(int,input().split())\ndp=[[-1]*t for i in range(t)]\ng=[[] for i in range(s)]\nfor i in range(m):\n  a,b=map(int,input().split())\n  g[a-1].append(b-s-1)\nfor i in range(s):\n  if not g[i]:\n    continue\n  for x in g[i]:\n    for y in g[i]:\n      if x==y:\n        continue\n      if dp[x][y]!=-1:\n        exit(print(x+t,y+t,dp[x][y]+1,i+1))\n      else:\n        dp[x][y]=i\nprint(-1)",
        "length": 18,
        "loc": 15
    },
    "abc260_g_33361937": {
        "buggy": "import bisect, collections, copy, heapq, itertools, math, string\nimport random\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int, sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nfrom collections import deque\nfrom collections import Counter\nfrom collections import defaultdict\nimport bisect\nfrom functools import reduce\n\ndef main():\n    N,M = MI()\n    imos_grid = [[0 for _ in range(max(N + M + 3, N + 3))] for _ in range(max(N + 2 * M + 3, 3 * N + 3))]\n    look_cnt_dic = defaultdict(int)\n\n    def imos_dist(x,y):\n        imos_grid[y][x] += 1\n        imos_grid[y + 2][x - 1] -= 1\n        imos_grid[y + 2 * M + 2][x - 1] += 1\n        imos_grid[y + 2 * M + 2][x] -= 1\n        imos_grid[y + 2][x + M] += 1\n        imos_grid[y][x + M] -= 1\n\n\n\n    for i in range(N):\n        T = S()\n        for j,t in enumerate(T):\n            if t == 'O':\n                imos_dist(i + 1, j + 1)\n\n    # for grid in imos_grid:\n    #     print(grid)\n\n    for i in range(3 * N + 3):\n        for j in range(N + 3):\n            if i - 2 >= 0 and j + 1 <= N + M + 2:\n                imos_grid[i][j] += imos_grid[i - 2][j + 1]\n    #print('a')\n    for j in range(N + 3):\n        for i in range(1, 3 * N + 3):\n            imos_grid[i][j] += imos_grid[i - 1][j]\n    for i in range(3 * N + 3):\n        for j in range(1, N + 3):\n            imos_grid[i][j] += imos_grid[i][j - 1]\n\n    # for grid in imos_grid:\n    #     print(grid)\n    Q = I()\n    for i in range(Q):\n        x, y = MI()\n        print(imos_grid[y][x])\n\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "length": 61,
        "loc": 40
    },
    "abc261_a_45791113": {
        "buggy": "L1,R1,L2,R2 = map(int,input().split())\nif L1 <= L2 <= R1 <= R2:\n    print(R1-L2)\nelif L2 <= L1 <= R2 <= R1:\n    print(R2-L1)\nelif L2 <= L1 <= R1 <= R2:\n    print(R1-L1)\nelif L1 <= L2 <= R2 <= R1:\n    print(R2-L2)",
        "length": 9,
        "loc": 10
    },
    "abc261_b_45282531": {
        "buggy": "N = int(input())\nA = [list(input()) for _ in range(N)]\n\nfor i in range(N):\n  for j in range(N):\n    if A[i][j] == 'W' and A[j][i] =='W' or A[i][j] == 'L' and A[j][i] =='L':\n      print('incorrect')\n      exit()\nprint('correct')",
        "length": 9,
        "loc": 6
    },
    "abc261_d_45285878": {
        "buggy": "n,m = map(int, input().split())\nxl = list(map(int, input().split()))\ncyl = [list(map(int, input().split())) for _ in range(m)]\nyl = [0] * n  \nfor c,y in cyl:\n    yl[c-1] = y\n\ndp = [[0] * (n) for i in range(n)]\n\nfor i in range(n):\n    if i == 0:\n        dp[i][0] = xl[0] + yl[0]\n    else:\n        for j in range(1,i+1):\n            dp[i][j] = dp[i-1][j-1] + xl[i] + yl[j]\n        if i != 1:\n            dp[i][0] = max(dp[i-2]) + xl[i] + yl[j]\nprint(max(dp[n-1]))",
        "length": 18,
        "loc": 17
    },
    "abc262_a_45968075": {
        "buggy": "a = int(input())\n# a, b = map(int, input().split())\n\nif a % 4 == 2:\n    print(a)\nelif a % 4 == 1:\n    print(a + 1)\nelif a % 4 == 3:\n    print(a + 3)\n",
        "length": 9,
        "loc": 10
    },
    "abc262_c_44821687": {
        "buggy": "n = int(input())\nA = list(map(int,input().split()))\ncount1 = 0\ncount2 = 0\nfor i in range(n):\n    a = A[i]\n    if (a == i+1):\n        count1 += 1\n    elif (A[a-1] == i+1):\n        count2 += 1\nif (count1 >= 2):\n    print(count1 * (count1-1) // 2 + count2//2)\nelse:\n    print(count2)",
        "length": 14,
        "loc": 14
    },
    "abc262_d_44381954": {
        "buggy": "import sys\n\n# import math\n# from bisect import *\n# from collections import *\n# from functools import *\n# from heapq import *\n# from itertools import *\n# from random import *\n# from string import *\n# from types import GeneratorType\n\n# region fastio\ninput = lambda: sys.stdin.readline().rstrip()\nsint = lambda: int(input())\nmint = lambda: map(int, input().split())\nints = lambda: list(map(int, input().split()))\n# print = lambda d: sys.stdout.write(str(d) + \"\\n\")\n# endregion fastio\n\n# # region interactive\n# def printQry(a, b) -> None:\n#     sa = str(a)\n#     sb = str(b)\n#     print(f\"? {sa} {sb}\", flush = True)\n\n# def printAns(ans) -> None:\n#     s = str(ans)\n#     print(f\"! {s}\", flush = True)\n# # endregion interactive\n\n# # region dfsconvert\n# def bootstrap(f, stack=[]):\n#     def wrappedfunc(*args, **kwargs):\n#         if stack:\n#             return f(*args, **kwargs)\n#         else:\n#             to = f(*args, **kwargs)\n#             while True:\n#                 if type(to) is GeneratorType:\n#                     stack.append(to)\n#                     to = next(to)\n#                 else:\n#                     stack.pop()\n#                     if not stack:\n#                         break\n#                     to = stack[-1].send(to)\n#             return to\n#     return wrappedfunc\n# # endregion dfsconvert\n\nMOD = 998244353\n# MOD = 10 ** 9 + 7\n# DIR = ((-1, 0), (0, 1), (1, 0), (0, -1))\n\ndef solve() -> None:\n    n = sint()\n    nums = ints()\n    ans = 0\n    for i in range(1, n + 1):   # \u9009\u62e9i\u4e2a\u6570\n        dp = [[0] * n for _ in range(n + 1)]\n        dp[0][0] = 1\n        for x in nums:  # \u679a\u4e3e\u6240\u6709\u6570\u5b57\n            for j in range(i, 0, -1):   # \u524d\u9762\u9009\u62e9\u4e86j\u4e2a\u6570\n                for k in range(i):  # \u6a21i\u4f59\u4e3ak\n                    dp[j][(k + x) % i] = (dp[j][(k + x) % i] + dp[j - 1][k]) % MOD\n        ans += dp[i][0]\n    print(ans)\n\nsolve()",
        "length": 70,
        "loc": 67
    },
    "abc263_a_45002191": {
        "buggy": "x=list(map(int,input().split()))\nif len(set(x))==2:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "length": 5,
        "loc": 2
    },
    "abc263_b_45056655": {
        "buggy": "n = int(input())\nli = list(map(int,input().split()))\n\ncnt = 0\nper = n-2\n\nfor i in range(n-1):\n  li[i] -= 1\n\n  \nwhile(True):\n  if(li[per] == 0):\n    cnt += 1\n    print(cnt)\n    break\n  else:\n    cnt += 1\n    per = li[per-1]\n",
        "length": 18,
        "loc": 18
    },
    "abc263_c_45092514": {
        "buggy": "N,M=map(int,input().split())\n\nimport itertools\n\nfor p in itertools.combinations(range(1,N+1),M):\n  print(*p)",
        "length": 6,
        "loc": 5
    },
    "abc263_d_46128003": {
        "buggy": "class Input_kyopro:\n    def II(self): return int(input())\n    def MI(self): return map( int,input().split())\n    def MS(self): return map(str,input().split())\n    def LMI(self): return list(self.MI())\n    def LMS(self): return list(self.MS())\n    def LLI(self,N): return [self.LMI() for _ in range(N)]\n    def LLS(self,N): return [self.LMS() for _ in range(N)]\n    def LS(self,N): return [input() for _ in range(N)]\n    def LSL(self,N): return [list(input()) for _ in range(N)]\n    def LI(self,N): return [self.II() for _ in range(N)]\nI=Input_kyopro()\n#\u5165\u529b\nN,L,R=I.MI()\nA=I.LMI()\nruiseki_l=[0]*(N+1)\ns=sum(A)\nfor i in range(N):\n    ruiseki_l[i+1]=ruiseki_l[i]+L-A[i]\nfor i in range(N):\n    ruiseki_l[i+1]=min(ruiseki_l[i+1],ruiseki_l[i])\nruiseki_r=[0]*(N+1)\nfor i in range(N):\n    ruiseki_r[i+1]=ruiseki_r[i]+R-A[-i-1]\nfor i in range(N):\n    ruiseki_r[i+1]=min(ruiseki_r[i+1],ruiseki_r[i])\nans=float('inf')\nfor i in range(N):\n    ans=min(ans,ruiseki_l[i]+ruiseki_r[-i-1]+s)\nprint(ans)\n\n    ",
        "length": 32,
        "loc": 1
    },
    "abc263_e_44902374": {
        "buggy": "n = int(input())\na = [0]+list(map(int, input().split()))\ne = [0]*(n+2)\nrui = [0]*(n+2)\nmod = 998244353\n#e[n]=0\nfor i in reversed(range(1,n)):\n  A = a[i]\n  e[i]=rui[i+1]-rui[i+A+1]+(A+1)*pow(A,mod-2,mod)\n  e[i]%=mod\n  rui[i]=e[i]+rui[i+1]\n  rui[i]%=mod\nprint(e[1])",
        "length": 13,
        "loc": 9
    },
    "abc264_a_46142360": {
        "buggy": "c = \"atcorder\"\n\nx, y = map(int, input().split())\n\nprint(c[x-1:y])",
        "length": 5,
        "loc": 1
    },
    "abc264_b_45507078": {
        "buggy": "R,C=map(int,input().split())\ndist=min(R-8,C-8)\nif dist%2==1: print(\"black\")\nelse: print(\"white\")",
        "length": 4,
        "loc": 2
    },
    "abc265_a_45305147": {
        "buggy": "x,y,n = map(int,input().split())\nyn = n//3\nxn = n - yn*3\nprint(xn*x +  yn*y)",
        "length": 4,
        "loc": 4
    },
    "abc265_b_45288123": {
        "buggy": "from collections import defaultdict\n\nN, M, T = map(int, input().split())\nA = list(map(int, input().split()))\nXY = [list(map(int, input().split())) for _ in range(M)]\n\nd = defaultdict(int)\nfor x, y in XY:\n    d[x] = y\n\nnow = 1\nwhile now != N:\n    T -= A[now-1]\n    now += 1\n\n    if T < 0:\n        print('No')\n        exit()\n    \n    T += d[now]\n    # print(T)\n\nprint('Yes')",
        "length": 23,
        "loc": 16
    },
    "abc265_g_46700668": {
        "buggy": "class segtreelazy3:\n    # \u8981\u7d20\u6570\u3001\u4e57\u305b\u308b\u6f14\u7b97\u3001\u5358\u4f4d\u5143\u3001\u4f5c\u7528\u3001\u4f5c\u7528\u7d20\u306e\u6f14\u7b97\u3001\u6052\u7b49\u5199\u50cf\u306b\u306a\u308b\u4f5c\u7528\u7d20\n    def __init__(self, N, op, e, act, comp, identity, A = []):\n        self.N = N\n        self.op = op\n        self.e = e\n        self.act = act\n        self.comp = comp\n        self.identity = identity\n        self.dat = [self.e] * (2 * self.N)\n        self.lazy = [self.identity] * (2 * self.N)\n        for i in range(len(A)):\n            self.dat[i + self.N] = A[i]\n        for i in range(self.N - 1, 0, -1):\n            self.dat[i] = self.op(self.dat[i << 1], self.dat[i << 1 | 1])\n    \n    def _getidx1(self, i):\n        i >>= 1\n        while i:\n            yield i\n            i >>= 1\n    \n    def _getidx2(self, l, r):\n        l0 = l // (l & -l)\n        r0 = r // (r & -r)\n        while l < r:\n            if l < l0:\n                yield l\n            if r < r0:\n                yield r\n            l >>= 1\n            r >>= 1\n        while l:\n            yield l\n            l >>= 1\n    \n    def eval(self, idx):\n        for i in reversed(idx):\n            x = self.lazy[i]\n            if x == self.identity: continue\n            if i < self.N:\n                self.lazy[i << 1] = self.comp(self.lazy[i << 1], x)\n                self.dat[i << 1] = self.act(self.dat[i << 1], x)\n                self.lazy[i << 1 | 1] = self.comp(self.lazy[i << 1 | 1], x)\n                self.dat[i << 1 | 1] = self.act(self.dat[i << 1 | 1], x)\n            self.lazy[i] = self.identity\n\n    def apply(self, l, r, x):\n        l += self.N\n        r += self.N\n        *idx, = self._getidx2(l, r)\n        self.eval(idx)\n        while l < r:\n            if l & 1:\n                self.lazy[l] = self.comp(self.lazy[l], x)\n                self.dat[l] = self.act(self.dat[l], x)\n                l += 1\n            if r & 1:\n                r -= 1\n                self.lazy[r] = self.comp(self.lazy[r], x)\n                self.dat[r] = self.act(self.dat[r], x)\n            l >>= 1\n            r >>= 1\n        for i in idx:\n            self.dat[i] = self.op(self.dat[i << 1], self.dat[i << 1 | 1])\n    \n    def prod(self, l, r):\n        l += self.N\n        r += self.N\n        *idx, = self._getidx2(l, r)\n        self.eval(idx)\n        lres = self.e\n        rres = self.e\n        while l < r:\n            if l & 1:\n                lres = self.op(lres, self.dat[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rres = self.op(rres, self.dat[r])\n            l >>= 1\n            r >>= 1\n        return self.op(lres, rres)\n    \n    def set(self, i, a):\n        i += self.N\n        *idx, = self._getidx1(i)\n        self.eval(idx)\n        self.dat[i] = a\n        self.lazy[i] = self.identity\n        for i in idx:\n            self.dat[i] = self.op(self.dat[i << 1], self.dat[i << 1 | 1])\n\nN, Q = map(int, input().split())\n# 0, 1, 2, (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)\nA = [\n    (1, 0, 0, 0, 0, 0, 0, 0, 0),\n    (0, 1, 0, 0, 0, 0, 0, 0, 0),\n    (0, 0, 1, 0, 0, 0, 0, 0, 0)\n]\nB = list(map(lambda x: A[int(x)], input().split()))\nidx = [-1, 3, 4, 5, -1, 6, 7, 8, -1]\n\ndef op(A, B):\n    return (\n        A[0] + B[0],\n        A[1] + B[1],\n        A[2] + B[2],\n        A[3] + B[3] + A[0] * B[1],\n        A[4] + B[4] + A[0] * B[2],\n        A[5] + B[5] + A[1] * B[0],\n        A[6] + B[6] + A[1] * B[2],\n        A[7] + B[7] + A[2] * B[0],\n        A[8] + B[8] + A[2] * B[1]\n    )\n\ndef act(A, F):\n    res = [0] * 9\n    for i in range(3): res[F[i]] += A[i]\n    for i, a, b in ((3, 0, 1), (4, 0, 2), (5, 1, 0), (6, 1, 2), (7, 2, 0), (8, 2, 1)):\n        j = idx[F[a] * 3 + F[b]]\n        if j != -1: res[j] += A[i]\n    return tuple(res)\n\ndef comp(F, G):\n    return (G[F[0]], G[F[1]], G[F[2]])\n\ne = (0, 0, 0, 0, 0, 0, 0, 0, 0)\nidentity = (0, 1, 2)\n\ntree = segtreelazy3(N, op, e, act, comp, identity, B)\nfor _ in range(Q):\n    k, *query = map(int, input().split())\n    if k == 1:\n        l, r = query\n        l -= 1\n        res = tree.prod(l, r)\n        print(res[5] + res[7] + res[8])\n    else:\n        l, r, s, t, u = query\n        l -= 1\n        tree.apply(l, r, (s, t, u))",
        "length": 142,
        "loc": 80
    },
    "abc266_b_44372589": {
        "buggy": "# ABC266 B - Modulo Number\nn = int(input())\nprint(n-998244353)",
        "length": 3,
        "loc": 3
    },
    "abc266_g_44683031": {
        "buggy": "num = 3*10**6 + 1\nfrac = [1] * num\ninv_frac = [1] * num\nMOD = 998244353\nfor i in range(2, num):\n    frac[i] = (frac[i-1] * i) % MOD\n\ninv_frac[-1] = pow(frac[-1], MOD-2, MOD)\nfor i in range(num-1, 0, -1):\n    inv_frac[i-1] = (inv_frac[i] * i) % MOD\n\ndef comb(n, r):\n    if r < 0 or r > n:\n        return 0\n    \n    return (frac[n] * (inv_frac[n-r] * inv_frac[r])%MOD) % MOD\n\nR, G, B, K = map(int, input().split())\nR -= K\nG -= K\n\nans = 1\nans *= comb(R+B+K, B)\nans *= comb(R+B, K)\nans %= MOD\nans *= comb(B+K+1+G-1, G)\nans %= MOD\n\nprint(ans)\n\n",
        "length": 30,
        "loc": 24
    },
    "abc267_a_45943869": {
        "buggy": "s=input()\nif s==\"Monday\":\n    print(5)\nif s==\"Tuesday\":\n    print(4)\nif s==\"Wednesday\":\n    print(3)\nif s==\"Thursday\":\n    print(2)\nif s==\"Friay\":\n    print(1)\n",
        "length": 11,
        "loc": 10
    },
    "abc267_b_45233540": {
        "buggy": "s = input()\n\nrow = [1]*7\nif s[0]=='1':\n    print('No')\nelse:\n    if s[6]=='0':\n        row[0]=0\n    if s[3]=='0':\n        row[1]=0\n    if s[1]=='0' and s[7]=='0':\n        row[2]=0\n    if s[4]=='0':\n        row[3]=0\n    if s[2]=='0' and s[8]=='0':\n        row[4]=0\n    if s[5]=='0':\n        row[5]=0\n    if s[9]=='0':\n        row[6]=0\n    f_s, e_s=None, None\n    for i in range(7):\n        if row[i]==1:\n            f_s = i\n            break\n    for i in reversed(range(7)):\n        if row[i]==1:\n            e_s = i\n            break\n    if f_s and e_s and any(row[i]==0 for i in range(f_s, e_s)):\n        print('Yes')\n    else:\n        print('No')",
        "length": 33,
        "loc": 30
    },
    "abc267_c_45068144": {
        "buggy": "# coding: utf-8\n\nfrom random import randint\n\nfrom functools import partial\nimport sys\ntry:\n    dummy = src\n    rl = partial(src.pop, 0)\nexcept NameError:\n    rl = sys.stdin.readline\ndef ints():\n    return list(map(int, rl().rstrip().split(' ')))\ndef int1():\n    return int(rl().rstrip())\n\n#@psecs\ndef main():\n    n, m = ints()\n    aa = ints()\n#    print(locals())\n\n    if False:\n        n = 2 * 10 ** 5\n        m = randint(1, n)\n        aa = [randint(-2 * 10 ** 5, 2 * 10 ** 5) for _ in range(n)]\n    \n    bb = [0] * n\n    s = 0\n    for i in range(n):\n        s += aa[i]\n        bb[i] = s\n    sm_max = 0\n    for i in range(n - m + 1):\n#        pr('i')\n        if i == 0:\n            sm = sum(a * b for a, b in zip(aa[i: i+m], range(1, m+1)))\n        else:\n            sm = sm - aa[i-1] + m * aa[i+m-1] - (bb[i+m-2] - bb[i-1])\n#        pr('sm')\n        if sm_max < sm:\n            sm_max = sm\n    print(sm_max)\n    \nif __name__ == '__main__':\n    main()",
        "length": 46,
        "loc": 33
    },
    "abc267_d_45550363": {
        "buggy": "INT = lambda : int(input())\nMI = lambda : map(int, input().split())\nMI_DEC = lambda : map(lambda x : int(x)-1, input().split())\nLI = lambda : list(map(int, input().split()))\nLI_DEC = lambda : list(map(lambda x : int(x)-1, input().split()))\n\nN, M = MI()\nA = LI()\n\ndp = [[-float('inf')]*(M+1) for i in range(N+1)]\ndp[0][0] = 0\n\nfor i in range(N):\n    for j in range(M+1):\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j])\n\n        if j + 1 > M:\n            continue\n\n        dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + (j+1)*A[i])\n            \n\nans = -1\nfor i in range(N+1):\n    ans = max(ans, dp[i][M])\n\nprint(ans)",
        "length": 27,
        "loc": 23
    },
    "abc267_f_45545460": {
        "buggy": "def dfs(s):\n    time = [-1] * n\n    st = [s]\n    time[s] = 0\n    parent = [-1] * n\n    while st:\n        i = st.pop()\n        ti = time[i]\n        for j in edges[i]:\n            if time[j] > -1:\n                continue\n            parent[j] = i\n            time[j] = ti + 1\n            st.append(j)\n\n    return time, parent\n\n\nn = int(input())\nedges = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ntime, parent = dfs(0)\ns = time.index(max(time))\ntime, parent = dfs(s)\nd = max(time)\nt = time.index(d)\nc = [t]\nwhile t != s:\n    t = parent[t]\n    c.append(t)\nrc = c.copy()\nrc.reverse()\n\nln = len(bin(n)) - 1\nleft = [-1] * (n * ln)\nright = [-1] * (n * ln)\nfor i in range(len(c) - 1):\n    left[rc[i] * ln] = rc[i + 1]\n    right[c[i] * ln] = c[i + 1]\n\n\nfor i in range(n):\n    if right[i * ln] > -1:\n        continue\n    p = parent[i]\n    left[i * ln] = p\n    right[i * ln] = p\n\n\nfor j in range(ln - 1):\n    for i in range(n):\n        lij = left[i * ln + j]\n        if lij > -1:\n            left[i * ln + j + 1] = left[lij * ln + j]\n        rij = right[i * ln + j]\n        if rij > -1:\n            right[i * ln + j + 1] = right[rij * ln + j]\n\n\ndef solve(go, u, k):\n    while k:\n        l = len(bin(k)) - 3\n        u = go[u * ln + l]\n        if u < 0:\n            return -1\n        k -= 1 << l\n    return u + 1\n\n\nq = int(input())\nfor i in range(q):\n    u, k = map(int, input().split())\n    u -= 1\n    print(max(solve(left, u, k), solve(right, u, k)))\n",
        "length": 80,
        "loc": 49
    },
    "abc268_b_45422238": {
        "buggy": "s = input()\nt = input()\nif s[0:3] == t[0:3]:\n    print('Yes')\nelse:\n    print('No')",
        "length": 6,
        "loc": 3
    },
    "abc268_d_45999403": {
        "buggy": "from itertools import permutations\nN,M = map(int,input().split())\nS = [input().rstrip() for n in range(N)]\nT = set([input().rstrip() for m in range(M)])\ndef recc(surp):\n    for i in range(surp+1):\n        temp.append(i)\n        if len(temp)<N-1 :\n            recc(surp-i)\n        else :\n            ans = \"\"\n            for n in range(N-1):\n                ans+=S[ss[n]]+\"_\"*(temp[n]+1)\n            ans+=S[ss[N-1]]\n            if ans not in T:\n                exit(print(ans))\n        temp.pop()\n\nif N==1:\n    if tuple(S) in T or len(S[0])<3 : print(-1)\n    else : print(S[0])\nelse :\n    for ss in permutations(range(N),N):\n        surp = 16-(sum(len(S[s]) for s in ss)+N-1)\n        temp = []\n        recc(surp)\n    else:\n        print(-1)",
        "length": 28,
        "loc": 20
    },
    "abc269_a_45960652": {
        "buggy": "a,b,c,d=map(int,input().split())\nprint((a+b)*(c-d))\nprint('takahashi')# coding: utf-8\n# Your code here!",
        "length": 4,
        "loc": 3
    },
    "abc269_b_45961458": {
        "buggy": "n = 10\ns = [input()for i in range(n)]\n\n\n\na,b,c,d = 100, 0, 100, 0\nfor i in range(n):\n    for j in range(n):\n      if s[i][j]=='#':\n        if a>i : a=i\n        if b<i : B=i\n        if c>j : c=j\n        if d<j : d=j\nprint(a+1,b+1)\nprint(c+1,d+1)",
        "length": 15,
        "loc": 11
    },
    "abc269_c_45092563": {
        "buggy": "n=int(input())\ni=1\nL=[]\nwhile i<n:\n    if i&n:\n        L+=[i]\n    i*=2\nans=[]\ndef f(i):\n    add=[i]\n    for k in ans:\n        add+=[i+k]\n    return add\nfor i in L:\n    ans+=f(i)\nprint(0,*ans,sep=\"\\n\")",
        "length": 16,
        "loc": 4
    },
    "abc269_d_52213061": {
        "buggy": "from collections import defaultdict\nclass UnionFind():\n\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*n\n        self.rank = [0]*n\n\n    def find(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if(x == y):\n            return\n        elif(self.rank[x] > self.rank[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if(self.rank[x] == self.rank[y]):\n                self.rank[y] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root[self.find(x)]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.root) if x < 0]\n\n    def group_size(self):\n        return len(self.roots())\n\n    def group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n        \nN=int(input())\nuf=UnionFind(2003*2003)\nblack=[False]*2003*2003\nfor i in range(N):\n  X,Y=map(int,input().split())\n  X+=1001\n  Y+=1001\n  \n  black[2002*X+Y]=True\n  if black[2002*(X-1)+Y-1]:\n    uf.unite(2002*X+Y,2002*(X-1)+Y-1)\n  if black[2002*(X-1)+Y]:\n    uf.unite(2002*X+Y,2002*(X-1)+Y)\n  if black[2002*(X)+Y-1]:\n    uf.unite(2002*X+Y,2002*(X)+Y-1)\n  if black[2002*(X+1)+Y+1]:\n    uf.unite(2002*X+Y,2002*(X+1)+Y+1)\n  if black[2002*(X+1)+Y]:\n    uf.unite(2002*X+Y,2002*(X+1)+Y)\n  if black[2002*(X)+Y+1]:\n    uf.unite(2002*X+Y,2002*(X)+Y+1)\nprint(uf.group_size()-(2002*2002-sum(black)))\n  ",
        "length": 71,
        "loc": 70
    },
    "abc269_g_43509672": {
        "buggy": "n,m=map(int,input().split())\ns=0\nd={}\nfor i in range(n):\n  a,b=map(int,input().split())\n  s+=a\n  if b-a not in d:\n    d[b-a]=0\n  d[b-a]+=1\np=[]\nfor dd in d:\n  pp=1\n  while pp<=d[dd]:\n    p.append((dd,pp))\n    d[dd]-=pp\n    pp*=2\n  if d[dd]>0:\n    p.append((dd,d[dd]))\nq=[n+1]*(m+1)\nq[s]=0\nfor dd,pp in p:\n  nq=[n+1]*(m+1)\n  for i in range(m+1):\n    if q[i]<n+1:\n      nq[i]=min(nq[i],q[i])\n      if 0<=i+dd*pp<=m and dd>0:\n        nq[i+dd*pp]=min(nq[i+dd*pp],q[i]+pp)\n  q=nq\nfor qq in q:\n  print(qq if qq<n+1 else -1)",
        "length": 30,
        "loc": 26
    },
    "abc270_a_46202213": {
        "buggy": "a,b = map(int, input().split())\n\nct=[[0],[1],[2],[1,2],[4],[1,4],[2,4],[1,2,7]]\n\ntaka=ct[a]\nao=ct[b]\nsu=taka+ao\nans=set(su)\nsim=sum(ans)\nprint(sim)",
        "length": 10,
        "loc": 3
    },
    "abc270_b_46011134": {
        "buggy": "x, y, z = map(int, input().split())\n\nif x*y < 0:\n  print(abs(x))\nelse:\n  if abs(y) > abs(x):\n    print(abs(x))\n  else:\n    if x*z <0:\n      print(abs(x)+2*abs(z))\n    else:\n      if abs(z) < abs(x):\n        print(abs(x))\n      else:\n        print(-1)",
        "length": 15,
        "loc": 12
    },
    "abc271_a_44974304": {
        "buggy": "n = int(input())\n\nprint(hex(n)[2:].upper())\n",
        "length": 3,
        "loc": 3
    },
    "abc271_c_45004566": {
        "buggy": "from collections import deque\n\nN = int(input())\nA = [int(x) for x in input().split()]\n\nA.sort()\n\ndeq = deque()\nse = set()\n\nnon_need = deque()\nfor a in A:\n    if a not in se:\n        se.add(a)\n        deq.append(a)\n    else:\n        non_need.append(a)\n\ndeq = deq + non_need\n\nfor i in range(N):\n    ni = i + 1\n    if deq and deq[0] == ni:\n        deq.popleft()\n    elif len(deq) >= 2:\n        deq.pop()\n        deq.pop()\n    else:\n        print(i)\n        break\n",
        "length": 30,
        "loc": 31
    },
    "abc271_d_46008428": {
        "buggy": "n,s=map(int, input().split())\nc=[0]*n\nd=[]\nfor i in range(n):\n  a,b=map(int, input().split())\n  if a<=b:\n    d.append(b-a)\n    s-=a\n  else:\n    c[i]=1\n    d.append(a-b)\n    s-=b\n\nif s<=0:\n  print(\"No\")\n  exit()\n\ndp=[[0]*(s+1) for _ in range(n+1)]\ndp[0][0]=1\nfor i in range(n):\n  D=d[i]\n  for j in range(s+1):\n    if dp[i][j]==1:\n      dp[i+1][j]=1\n      if j+D<=s:\n        dp[i+1][j+D]=1\n\nif dp[-1][-1]==0:\n  print(\"No\")\n  exit()\n\nans=\"\"\ne=[\"H\",\"T\"]\nnow=s\nfor i in reversed(range(n)):\n  if dp[i][now]==1:\n    ans+=e[c[i]]\n  else:\n    ans+=e[(c[i]+1)%2]\n    now-=d[i]\n\n\n\nans=ans[::-1]\nprint(\"Yes\")\nprint(ans)",
        "length": 46,
        "loc": 14
    },
    "abc271_e_45981596": {
        "buggy": "n,m,k = map(int,input().split())\nl = [list(map(int,input().split())) for i in range(m)]\ne = list(map(int,input().split()))\ndp = [float('inf')] * (n+1)\ndp[1] = 0\n\nfor i in range(k):\n  a,b,c = l[e[i]-1]\n  if dp[a] != float('inf'):\n    dp[b] = min(dp[b],dp[a]+c)\nprint(dp[n])",
        "length": 11,
        "loc": 11
    },
    "abc271_h_54716396": {
        "buggy": "T=int(input())\nfor t in range(T):\n    A,B,S=input().split()\n    A=int(A)\n    B=int(B)\n    S=list(map(int,S))\n    inf=1<<60\n    dx=[1,1,0,-1,-1,-1,0,1]\n    dy=[0,1,1,1,0,-1,-1,-1]\n    def solve(A,B,S):\n        S=S[:]\n        if A<0:\n            A=-A\n            S=[S[4],S[3],S[2],S[1],S[0],S[7],S[6],S[5]]\n        if B<0:\n            B=-B\n            S=[S[0],S[7],S[6],S[5],S[4],S[3],S[2],S[1]]\n        if A<B:\n            A,B=B,A\n            S=[S[2],S[1],S[0],S[7],S[6],S[5],S[4],S[3]]\n        ans=inf\n        if S[0] and B==0:\n            ans=min(ans,A)\n        if S[1] and A==B:\n            ans=min(ans,A)\n        if S[0] and S[1]:\n            ans=min(ans,A)\n        if S[0] and S[2]:\n            ans=min(ans,A+B)\n        if S[0] and S[3]:\n            ans=min(ans,A+2*B)\n        if S[1] and S[6]:\n            ans=min(ans,2*A-B)\n        if S[1] and S[7] and A%2==B%2:\n            ans=min(ans,A)\n        if S[7] and S[2]:\n            ans=min(ans,2*A+B)\n        return ans\n    ans=solve(A,B,S)\n    for i in range(8):\n        if S[i]:\n            ans=min(ans,solve(A-dx[i],B-dy[i],S)+1)\n    if ans==inf:\n        ans=-1\n    print(ans)",
        "length": 45,
        "loc": 11
    },
    "abc272_b_53303936": {
        "buggy": "N, M = map(int, input().split())\nX=[]\nfor _ in range(M):\n  _, *x=map(int, input().split())\n  X.append(set(x))\nflag=False\nfrom itertools import combinations\nfor cmb in combinations(range(1,N+1), 2):\n  for i in X:\n    if cmb[0] in i and cmb[1] in i:\n      flag=True\n      break\n    else:\n      print(\"No\")\n      exit()\nprint(\"Yes\" if flag else \"No\") ",
        "length": 16,
        "loc": 13
    },
    "abc272_c_46144815": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\no = []\ne = []\nfor a in A:\n    if a % 2:\n        o.append(a)\n    else:\n        e.append(a)\nif len(o) < 2 and len(e) < 2:\n    print(-1)\n    exit()\nco = o[-1] + o[-2] if len(o) >= 2 else -1\nce = e[-1] + e[-2] if len(e) >= 2 else -1\nprint(max(co,ce))",
        "length": 15,
        "loc": 13
    },
    "abc272_g_54704821": {
        "buggy": "def Divisors(N):\n    divisors=[]\n    for i in range(1,N+1):\n        if i**2>=N:\n            break\n        elif N%i==0:\n            divisors.append(i)\n    if i**2==N:\n        divisors+=[i]+[N//i for i in divisors[::-1]]\n    else:\n        divisors+=[N//i for i in divisors[::-1]]\n    return divisors\n\nimport random\nN=int(input())\nA=list(map(int,input().split()))\nans=-1\nfor _ in range(100):\n    i=random.randint(0,N-1)\n    j=random.randint(0,N-1)\n    if i==j:\n        continue\n    for M in Divisors(abs(A[i]-A[j])):\n        if M<=2:\n            continue\n        B=[a%M for a in A]\n        B.sort()\n        bound=[0]\n        for i in range(1,N):\n            if B[i-1]!=B[i]:\n                bound.append(i)\n        bound.append(N)\n        for l,r in zip(bound,bound[1:]):\n            if (r-l)*2>=N:\n                ans=M\n    if ans!=-1:\n        break\nprint(ans)",
        "length": 38,
        "loc": 34
    },
    "abc273_b_45010464": {
        "buggy": "x, k = map(int, input().split())\n\nfor i in range(k):\n  p, q = divmod(x, 10**(i+1))\n  if q >= 5:\n    p += 1\n  x = p*10**(i+1)\nprint(x)\n",
        "length": 8,
        "loc": 5
    },
    "abc274_a_45467023": {
        "buggy": "A, B = map(int, input().split())\n\nprint(round(B/A, 3))\n",
        "length": 3,
        "loc": 3
    },
    "abc274_c_52979754": {
        "buggy": "def main() -> None:\n    n: int = int(input())\n    d: dict[int, int] = dict.fromkeys(range(2 * n + 1), 0)\n    a: list[int] = list(map(int, input().split()))\n    for i, ai in enumerate(a):\n        d[(i + 1) * 2] = d[ai] + 1\n        d[(i + 1) * 2 + 1] = d[ai] + 1\n    for i in d.values():\n        print(i)\n\n\nmain()\n",
        "length": 12,
        "loc": 3
    },
    "abc274_d_46033282": {
        "buggy": "\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nX = []\nY = []\n\nfor i in range(n):\n  if i %2 == 0:\n    X.append(a[i])\n  else:\n    Y.append(a[i])\n\ndp_x = [[False for _ in range(4 * (sum(X) + 1))] for _ in range(len(X) + 1)]\ndp_y = [[False for _ in range(4 * (sum(Y) + 1))] for _ in range(len(Y) + 1)]\ndp_x[0][2 * (sum(X) + 1)] = True\ndp_y[0][2 * (sum(Y) + 1)] = True\n\nfor i in range(len(X)):\n  for j in range(4 * (sum(X) + 1)):\n    if dp_x[i][j]:\n      if i != 0:\n        dp_x[i + 1][j + X[i]] = True\n        dp_x[i + 1][j - X[i]] = True\n      else:\n        dp_x[i + 1][j + X[i]] = True  \n\nfor i in range(len(Y)):\n  for j in range(4 * (sum(Y) + 1)):\n    if dp_y[i][j]:\n      dp_y[i + 1][j + Y[i]] = True\n      dp_y[i + 1][j - Y[i]] = True\n\n\nif x > sum(X) or y > sum(Y):\n  print(\"No\")\nelse:\n  if dp_x[-1][x + 2 * (sum(X) + 1)] and dp_y[-1][y + 2 * (sum(Y) + 1)]:\n    print(\"Yes\")\n  else:\n    print(\"No\")  \n",
        "length": 40,
        "loc": 34
    },
    "abc274_f_50475104": {
        "buggy": "N,T=map(int,input().split())\nresult=0\nL=[]\nfor i in range(N):\n  w,x,v=map(int,input().split())\n  L.append((w,x,v))\nfrom collections import defaultdict\nfor q in range(N):\n  R=set()\n  score=0\n  w,x,v=L[q][:]\n  score+=w\n  P=defaultdict(int)\n  for i in range(N):\n    if i==q:\n      continue\n    w2,x2,v2=L[i][:]\n    if x<=x2<=x+T:\n      score+=w2\n    if v2<v:\n      t1=(x2-x)/(v-v2)\n      t2=(x2-x-T)/(v-v2)\n      if t1>-10**(-11):\n        k=int((10**13)*(t1+10**(-11)))\n        R.add(k)\n        P[k]-=w2\n      if t2>10**(-11):\n        k=int(t2*10**13)\n        R.add(k)\n        P[k]-=w2\n    elif v2==v:\n      continue\n    else:\n      t1=(x-x2)/(v2-v)\n      t2=(x-x2+T)/(v2-v)\n      if t1>10**(-11):\n        k=int(t1*10**13)\n        P[k]+=w2\n        R.add(k)\n      if t2>-10**(-11):\n        k=int((10**13)*(t2+10**(-11)))\n        R.add(k)\n        P[k]-=w2\n  R=list(R)\n  R.sort()\n  result=max(result,score)\n  for i in range(len(R)):\n    y=P[R[i]]\n    score+=y\n    result=max(result,score)\nprint(result)",
        "length": 51,
        "loc": 30
    },
    "abc275_b_44663231": {
        "buggy": "\na,b,c,d,e,f=map(int,input().split())\nmod=998244353\na1=a%mod*b%mod*c%mod\na2=d%mod*e%mod*f%mod\nprint(a1-a2)",
        "length": 6,
        "loc": 6
    },
    "abc275_c_44917428": {
        "buggy": "s=[]\nfor i in range(9):\n  s.append(input())\nans=0\nfor k in range(8):\n  for i in range(8-k):\n    for j in range(8-k):\n      if s[i][j]==\"#\" and s[i+k+1][j]==\"#\" and s[i][j+k+1]==\"#\" and s[i+k+1][j+k+1]==\"#\":\n        ans+=1\nfor k in range(4):\n  for i in range(7-2*k):\n    for j in range(7-2*k):\n      if s[i+k+1][j]==\"#\" and s[i][j+k+1]==\"#\" and s[i+1][j+2*(k+1)]==\"#\" and s[i+2*(k+1)][j+k+1]==\"#\":\n        ans+=1\nfor i in range(6):\n  for j in range(6):\n    if s[i+1][j]==\"#\" and s[i][j+2]==\"#\" and s[i+2][j+3]==\"#\" and s[i+3][j+1]==\"#\":\n      ans+=1\n    if s[i][j+1]==\"#\" and s[i+2][j]==\"#\" and s[i+1][j+3]==\"#\" and s[i+3][j+2]==\"#\":\n      ans+=1\nfor i in range(3):\n  for j in range(3):\n    if s[i+4][j]==\"#\" and s[i][j+2]==\"#\" and s[i+6][j+4]==\"#\" and s[i+2][j+6]==\"#\":\n      ans+=1\n    if s[i+2][j]==\"#\" and s[i][j+4]==\"#\" and s[i+6][j+2]==\"#\" and s[i+4][j+6]==\"#\":\n      ans+=1\nfor i in range(5):\n  for j in range(5):\n    if s[i][j+1]==\"#\" and s[i+1][j+4]==\"#\" and s[i+3][j]==\"#\" and s[i+4][j+3]==\"#\":\n      ans+=1\n    if s[i+1][j]==\"#\" and s[i+4][j+1]==\"#\" and s[i][j+3]==\"#\" and s[i+3][j+4]==\"#\":\n      ans+=1\nif s[0][2]==\"#\" and s[2][8]==\"#\" and s[6][0]==\"#\" and s[8][6]==\"#\":\n  ans+=1\nif s[2][0]==\"#\" and s[8][2]==\"#\" and s[0][6]==\"#\" and s[6][8]==\"#\":\n  ans+=1\nfor k in range(4):\n  for i in range(4-k):\n    for j in range(4-k):\n      if s[i][j+1]==\"#\" and s[i+1][j+5+k]==\"#\" and s[i+4+k][j]==\"#\" and s[i+5+k][j+4+k]==\"#\":\n        ans+=1\n      if s[i+1][j]==\"#\" and s[i+5+k][j+1]==\"#\" and s[i][j+4+k]==\"#\" and s[i+4+k][j+5+k]==\"#\":\n        ans+=1\nfor k in [3,5]:\n  for i in range(9-2-k):\n    for j in range(9-2-k):\n      if s[i][j+2]==\"#\" and s[i+2][j+2+k]==\"#\" and s[i+k][j]==\"#\" and s[i+2+k][j+k]==\"#\":\n        ans+=1\n      if s[i+2][j]==\"#\" and s[i+2+k][j+2]==\"#\" and s[i][j+k]==\"#\" and s[i+k][j+2+k]==\"#\":\n        ans+=1\nfor k in [4,5]:\n  for i in range(9-3-k):\n    for j in range(9-3-k):\n      if s[i][j+3]==\"#\" and s[i+3][j+3+k]==\"#\" and s[i+k][j]==\"#\" and s[i+3+k][j+k]==\"#\":\n        ans+=1\n      if s[i+3][j]==\"#\" and s[i+3+k][j+3]==\"#\" and s[i][j+k]==\"#\" and s[i+k][j+3+k]==\"#\":\n        ans+=1\nprint(ans)",
        "length": 58,
        "loc": 13
    },
    "abc276_a_45481761": {
        "buggy": "s=input()\nfor i in range(len(s)):\n  if s[-i-1]==\"a\":\n    print((len(s))-i)\n    break\n    print(-1)\n    break",
        "length": 7,
        "loc": 6
    },
    "abc276_c_52142770": {
        "buggy": "n = int(input())\nP = list(map(int,input().split()))\n\nl = n - 2\nr = n - 1\n\nwhile P[l] < P[r] :\n  l -= 1\n  r -= 1\n\nr = n - 1\n\nwhile P[l] < P[r] :\n  r -= 1\n  \nP[l] , P[r] = P[r] , P[l]\n\nL = P[: l + 1]\nR = P[r - 1 :]\n\nR = sorted(R , reverse = True)\n\nprint(*(L + R))\n",
        "length": 23,
        "loc": 19
    },
    "abc277_a_45949578": {
        "buggy": "N, X = map(int, input().split())\nP = list(map(int, input().split()))\n\nfor i in range(N):\n  if P[i] == X:\n    print(i)\n    break",
        "length": 7,
        "loc": 6
    },
    "abc277_b_45992139": {
        "buggy": "def func():\n    pattern1 = [\"H\",\"D\",\"C\",\"S\"]\n    pattern2 = [\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"T\",\"J\",\"Q\",\"K\"]\n    pat_set = set()\n    \n    # \u5165\u529b\u3092\u53d6\u5f97\n    N = int(input())\n    for n in range(N):\n      s = input()\n      if (not(s[0] in pattern1)) or (not(s[1] in pattern2)) or (not(s in pat_set)):\n        print(\"No\")\n        return\n      \n      pat_set.add(s)\n      \n    \n    print(\"Yes\")\n\nif __name__ == '__main__':\n    func()",
        "length": 20,
        "loc": 10
    },
    "abc277_d_46193940": {
        "buggy": "N, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort()\nsum_a = sum(A)\nans = sum_a\ncnt = A[0]\nflag = False\nzero = 0\nif A[0] == 0:\n    flag = True\nfor i in range(N-1):\n    if A[i] == A[i+1] or A[i] + 1 == A[i+1]:\n        cnt += A[i+1]\n        if flag:\n            zero = cnt\n    else:\n        cnt = A[i+1]\n        flag = False\n    ans = min(ans, sum_a - cnt)\nans = min(ans, sum_a - cnt)\n\nif A[-1] == M - 1:\n    ans = min(ans, sum_a - cnt - zero)\nprint(ans)",
        "length": 25,
        "loc": 25
    },
    "abc278_a_45019575": {
        "buggy": "# 278a\nn, k = map(int, input().split())\nli = list(map(int, input().split()))\n\nfor i in range(k):\n    li.pop(0)\n    li.append(0)\nprint(li)    ",
        "length": 8,
        "loc": 8
    },
    "abc278_b_45484239": {
        "buggy": "h, m = map(int, input().split())\n\ndef check(h, m):\n    b = h % 10\n    c = m // 10\n    newm = (m-c*10)+b*10\n    add = ((m-c*10)+b*10) // 60\n    newh = (h-b)+c+add\n    return 0 <= newm < 60 and 0 <= newh < 23\n\nwhile True:\n    if check(h, m): break\n    m += 1\n    h += m//60\n    m %= 60\n    h %= 24\nprint(h, m)\n    \n",
        "length": 18,
        "loc": 9
    },
    "abc278_c_44900806": {
        "buggy": "user_n, q = map(int, input().split(\" \"))\ndic = {}\n\nfor i in range(q):\n    ope, user1, user2 = map(int, input().split(\" \"))\n    if user1 not in dic:\n        dic[user1] = set()\n    if user2 not in dic:\n        dic[user2] = set()\n    if ope == 1:\n        dic[user1].add(user2)\n    elif ope == 2:\n        if user1 in dic[user2]:\n            dic[user2].remove(user1)\n        if user2 in dic[user1]:\n            dic[user1].remove(user2)\n    else:\n        if user1 in dic[user2] and user2 in dic[user1]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n",
        "length": 21,
        "loc": 0
    },
    "abc279_b_44853654": {
        "buggy": "s = input()\nt = input()\n\nif len(s) > len(t) or (len(s) == len(t) and s != t):\n    print(\"No\")\n    exit()\nelse:\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i+len(t)] == t:\n            print(\"Yes\")\n            exit()\nprint(\"No\")",
        "length": 12,
        "loc": 4
    },
    "abc279_d_44854241": {
        "buggy": "import math\nfrom decimal import Decimal\n\na, b = map(int, input().split())\n\ndef f(x):\n    return Decimal((a / math.sqrt(1 + x)) + (b * x))\n\n# 3\u5206\u63a2\u7d22\u3059\u308b\nl = 0\nr = 10**40\n\nwhile r - l > 1:\n    m1 = (2 * l + r) // 3\n    m2 = (l + 2 * r) // 3\n    # print(m1, m2, l, r, f(m1), f(m2))\n    if f(m1) < f(m2):\n        r = m2\n    else:\n        if l == m1:\n            l += 1\n        else:\n            l = m1\nprint(l, r)\nprint(f(l), f(r))\nprint(min(f(l), f(r)))",
        "length": 26,
        "loc": 0
    },
    "abc280_b_45270301": {
        "buggy": "N = int(input())\nS = list(map(int, input().split()))\nans = [S[0]]\n\nfor i in range(1,N):\n  ans.append(S[i]-S[i-1])\n\nprint(ans)",
        "length": 8,
        "loc": 8
    },
    "abc280_c_46198348": {
        "buggy": "s = input()\nt = input()\nfor i in range(len(s)):\n    if s[i] != t[i]:\n        print(i + 1)\n        exit()\n\nprint(1)\n",
        "length": 8,
        "loc": 8
    },
    "abc280_d_46193678": {
        "buggy": "n=int(input())\nf=[]\ny=n\nfor i in range(2,int(y**0.5)+1):\n    while n%i==0:\n        f.append(i)\n        n//=i\nif n!=1:\n    f.append(n)\nif max(f)>int(y**0.5)+1:\n    print(y)\n\nelse:\n    import math\n    x=2\n    while True:\n        y//=math.gcd(y,x)\n        if y==1:\n            print(x)\n            exit()\n        else:\n            x+=1",
        "length": 22,
        "loc": 11
    },
    "abc281_a_45244769": {
        "buggy": "n = input()\nn = int(n)\nfor i in range(10,-1,-1):\n    print(i)",
        "length": 4,
        "loc": 3
    },
    "abc281_b_45943845": {
        "buggy": "s=input()\nt=s[1:-1]\nans='No'\nif s[0].isupper() and s[-1].isupper():\n  if t.isdigit() and 100000<=int(t)<=999999:\n    ans='Yes'\nprint(ans)",
        "length": 7,
        "loc": 5
    },
    "abc281_d_45212447": {
        "buggy": "n, k, d = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[[-1]* d for _ in range(k+1)] for i in range(n+1)]\ndp[0][0][0] = 0\n\nfor i in range(n):\n    for j in range(k):\n        for l in range(d):\n            if dp[i][j][l] == -1:\n                continue\n            dp[i+1][j][l] = max(dp[i+1][j][l], dp[i][j][l])\n            if j+1 <= k:\n                dp[i+1][j+1][(l+a[i])%d] = max(dp[i+1][j+1][(l+a[i])%d], dp[i][j][l] + a[i])\n\nprint(dp[n][k][0])",
        "length": 16,
        "loc": 8
    },
    "abc282_a_44657009": {
        "buggy": "K = int(input())\n\nfor i in range(K):\n  print(chr(64 + i), end='')",
        "length": 4,
        "loc": 4
    },
    "abc282_c_44818334": {
        "buggy": "n=int(input())\ns=input()\ns=list(s)\ncnt=0\nfor i in range(n):\n    if s[i]=='\"':\n        cnt+=1\n    if s[i]==\",\":\n        if cnt%2==1:\n            s[i]=\".\"\nans=\"\"\nfor i in range(n):\n    ans+=s[i]\nprint(ans)",
        "length": 14,
        "loc": 9
    },
    "abc282_f_45960750": {
        "buggy": "N = int(input())\nlog_table = [0]*(N+1)\na = 1\ncnt = 0\nfor i in range(1,N+1):\n    if i == a*2:\n        a += 2\n        cnt += 1\n    log_table[i] = cnt\nK = log_table[N]\ntable = [[-1]*(K+1) for _ in range(N)]\nM = 0\nfor i in range(N):\n    table[i][0] = M\n    M += 1\nfor k in range(1,K+1):\n    for i in range(N):\n        if i+(1<<k)-1 >= N:\n            continue\n        table[i][k] = M\n        M += 1\nprint(M)\nfor k in range(K+1):\n    for i in range(N):\n        if table[i][k] == -1:\n            continue\n        l,r = i,i+(1<<k)-1\n        print(l+1,r+1)\nQ = int(input())\nfor i in range(Q):\n    l,r = map(int,input().split())\n    l,r = l-1,r-1\n    k = log_table[r-l+1]\n    print(table[l][k]+1,table[r-(1<<k)+1][k]+1)",
        "length": 34,
        "loc": 7
    },
    "abc283_a_44656811": {
        "buggy": "A, B = map(int, input().split())\nprint(A^B)",
        "length": 2,
        "loc": 2
    },
    "abc283_c_45277024": {
        "buggy": "# ansmod = 10 ** 9 + 7\n# ansmod = 998244353\n\nimport sys\n\n\ndef main(f):\n    s = list(map(int, f.readline()[:-1]))\n\n    if len(s) == 1:\n        if s[0] == 0:\n            return 0\n        else:\n            return 1\n\n    ans = 0\n    f = False\n    for c in s:\n        if c == 0:\n            if f:\n                ans += 1\n                f = False\n            else:\n                f = True\n        else:\n            if f:\n                ans += 1\n                f = False\n            ans += 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    print(main(sys.stdin))\n    # print(main(sys.stdin) % ansmod)\n",
        "length": 36,
        "loc": 30
    },
    "abc283_d_45462979": {
        "buggy": "S = input()\nt = set([])\na=[[]]\nfor i in S:\n    if i.isalpha() == True:\n        if i in t:\n            print(\"No\")\n            exit()\n        else:\n            t.add(i)\n            a[-1].append(i)\n    elif i==\")\":\n      #  print(a)\n        for j in a[-1]:\n            print(t)\n            t.remove(j)\n        a.pop(-1)\n    elif i==\"(\":\n        a.append([])\n\n\n  #  print(t)\n  #  print(a)\n\nprint(\"Yes\")",
        "length": 25,
        "loc": 15
    },
    "abc283_f_46910621": {
        "buggy": "import math\nfrom heapq import heapify, heappop, heappush\n# import bisect\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\ndef ipt(num=0):\n    if num==1:return int(input())\n    elif num==2:return map(int, input().split())\n    elif num==3:return input().rstrip()\n    return list(map(int, input().split()))\n# mod = 998244353\n# d = [[] for i in range(n)]\n# for i in range(n):\nn=ipt(1)\na=ipt()\nclass SegTree():\n    def __init__(self,n) -> None:\n        self.N0 = 2**(n-1).bit_length()\n        self.INF = 2**60\n        self.data = [self.INF]*(2*self.N0)\n# a_k \u306e\u5024\u3092 x \u306b\u66f4\u65b0\n    def update(self, k, x):\n        k += self.N0-1\n        self.data[k] = x\n        while k >= 0:\n            k = (k - 1) // 2\n            self.data[k] = min(self.data[2*k+1], self.data[2*k+2])\n    # \u533a\u9593[l, r)\u306e\u6700\u5c0f\u5024\n    def query(self, l, r):\n        L = l + self.N0; R = r + self.N0\n        s = self.INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.data[R-1])\n\n            if L & 1:\n                s = min(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\ninf=1<<40\nl=[inf]*n\nst=SegTree(n+1);st2=SegTree(n+1)\nst.update(a[0],-a[0]-1)\nst2.update(a[0],a[0]-1)\nfor i in range(1,n):\n    s=st.query(0,a[i])+a[i]+i+1\n    ss=st2.query(a[i]+1,n+1)-a[i]+i+1\n    l[i]=min(s,ss)\n    st.update(a[i],-a[i]-i-1)\n    st2.update(a[i],a[i]-i-1)\nst=SegTree(n+1);st2=SegTree(n+1)\nst.update(a[n-1],-a[n-1]+n)\nst.update(a[n-1],a[n-1]+n)\nfor i in range(n-2,-1,-1):\n    s=st.query(0,a[i])+a[i]-i-1\n    ss=st2.query(a[i]+1,n+1)-a[i]-i-1\n    s=min(s,ss);l[i]=min(s,l[i])\n    st.update(a[i],-a[i]+i+1)\n    st2.update(a[i],a[i]+i+1)\nprint(*l)\n",
        "length": 63,
        "loc": 56
    },
    "abc283_g_38648014": {
        "buggy": "n,l,r = map(int,input().split())\na = list(map(int,input().split()))\nv = []\nfor i in range(n):\n\tw = a[i]\n\tfor e in v:\n\t\tw = min(w, e^w)\n\tif w > 0:\n\t\tfor j in range(len(v)):\n\t\t\tv[j] = min(v[j], v[j] ^ w)\n\t\tv.append(w)\nv.sort()\n\n#print(v)\n\nans = []\nl-=1\nr-=1\nfor i in range(l, r+1):\n\ttmp = 0\n\tfor j in range(30):\n\t\tif (i >> j & 1):\n\t\t\ttmp ^= v[j]\n\tans.append(tmp)\nprint(*ans)",
        "length": 25,
        "loc": 21
    },
    "abc283_h_37533124": {
        "buggy": "def floor_sum(n, m, a, b):\n    res = 0\n    if n == 0:\n        return 0\n    \n    if a >= m:\n        res += n*(n-1)//2*(a//m)\n        a %= m\n    \n    if b >= m:\n        res += n*(b//m)\n        b %= m\n\n    if a == 0:\n        return res\n    \n    q = (a*n+b)//m\n    r = (a*n+b)%m\n    res += floor_sum(q, a, m, r)\n    return res\n\n\nT=int(input())\nfor i in range(T):\n  N,M,R=map(int,input().split())\n  ans=0\n  X=(N-R)//M+1\n  d=1\n  while d<N:\n    ans+=floor_sum(X,d,M,R)-floor_sum(X,d*2,M,R)*2\n    d*=2\n  print(ans)\n  \n    \n    ",
        "length": 35,
        "loc": 29
    },
    "abc284_c_54471713": {
        "buggy": "N,M=map(int,input().split())\nG=[[] for _ in range(N)]\nfor _ in range(M):\n    u,v=map(int,input().split())\n    G[u-1].append(v-1)\n    G[v-1].append(u-1)\nseen=set()\ncnt=0\nfor i in range(N):\n    if(i not in seen):\n        stack=[i]\n        cnt+=1\n        while stack:\n            x=stack.pop()\n            if(x in seen):\n                continue\n            seen.add(x)\n            for j in G[i]:\n                if (j not in seen):\n                    stack.append(j)\nprint(cnt)",
        "length": 21,
        "loc": 18
    },
    "abc284_g_37908236": {
        "buggy": "N, M = map(int, input().split())\n \nP = 1\nans = 0\n \nfor y in range(2, N + 1):\n  P = P * (N + 1 - y) % M\n  f = P * pow(N, N - y, M)\n \n  ans += f * (y - 1) * y // 2\n  ans %= M\n  print(ans * N % M)",
        "length": 12,
        "loc": 2
    },
    "abc285_a_46015071": {
        "buggy": "Datos = input()\nData = [int (num) for num in Datos.split()]\nif Data[0]*2==Data[1] or (Data[1]*2)+1==Data[1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n    ",
        "length": 7,
        "loc": 1
    },
    "abc285_c_45507788": {
        "buggy": "#N=int(input())\nS=input()\n\nans=0\n\nfor i in range(len(S)-1,-1,-1):\n    x=ord(S[i])-ord('A')+1\n    print(x)\n\n    ans+=26**(len(S)-i-1)*x\n    \n\n#a,b=map(int,input().split())\nprint(ans)\n\n\n",
        "length": 16,
        "loc": 8
    },
    "abc285_e_48880084": {
        "buggy": "# \u521d\u65e5\u3092\u4f11\u65e5\n# dp[i][j] := i\u65e5\u76ee\u3092\u8003\u3048\u308b\u3001j\u65e5\u5e73\u65e5\u304c\u7d9a\u3044\u3066\u3044\u308b\n\n# 10\n# 10 10\n# 10 10 10\n# 10 10 10 10\n# 10 10 1 10 10\n# 10 10 1 1 10 10\n\nn = int(input())\nbase_productivity = list(map(int, input().split()))\nproductivity = [0]\nfor i in range(n):\n    productivity.append(productivity[-1] + base_productivity[i//2])\n\nINF = float('inf')\ndp = [[-INF]*n for _ in range(n)]\ndp[0][0] = 0\n\nfor i in range(n-1):\n    for j in range(n):\n        if j < n - 1:\n            dp[i+1][j+1] = dp[i][j]\n        if dp[i][j] != -INF:\n            dp[i+1][0] = dp[i][j] + productivity[j]\n\n#print(productivity)\n#print(dp)\nans = 0\nfor i in range(n):\n    ans = max(ans, dp[n-1][i] + productivity[i])\nprint(ans)",
        "length": 33,
        "loc": 26
    },
    "abc286_a_45028040": {
        "buggy": "N,P,Q,R,S = map(int, input().split())\nA = list(map(int, input().split()))\n\nans = A[:P-1] + A[R-1:S] + A[P-1:Q] + A[S:]\nprint(*ans)",
        "length": 5,
        "loc": 4
    },
    "abc286_d_45471607": {
        "buggy": "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import Counter\nfrom functools import lru_cache\n\n\nsys.setrecursionlimit(10 ** 8)\nMOD1 = 10**9 + 7\n\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a, b = [], []\n    for _ in range(n):\n        ai, bi = map(int, sys.stdin.readline().split())\n        a.append(ai)\n        b.append(bi)\n\n    # @lru_cache(maxsize=None)\n    # def rec(index, s):\n    #     if s == x:\n    #         return True\n    #\n    #     if index == n:\n    #         return False\n    #\n    #     for i in range(b[index] + 1):\n    #         if rec(index + 1, s + i * a[index]):\n    #             return True\n    #     return False\n    #\n    # if rec(0, 0):\n    #     print(\"Yes\")\n    # else:\n    #     print(\"No\")\n    dp = [[False for _ in range(x + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(x + 1):\n            for k in range(b[i] + 1):\n                if j >= k * a[i]:\n                    dp[i + 1][j] = dp[i][j] or dp[i][j - k * a[i]]\n    if dp[n][x]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == '__main__':\n    main()\n",
        "length": 51,
        "loc": 43
    },
    "abc286_f_45090669": {
        "buggy": "def extgcd(a, b):\n    if b:\n        d, y, x = extgcd(b, a % b)\n        y -= (a // b) * x\n        return d, x, y\n    return a, 1, 0\n\ndef remainder(V):\n    x = 0; d = 1\n    for X, Y in V:\n        g, a, b = extgcd(d, Y)\n        x, d = (Y*b*x + d*a*X) // g, d*(Y // g)\n        x %= d\n    return x, d\n\nlis = [4, 9, 5, 7, 11, 13, 17, 19, 23]\nnow = 0\na = []\ncheck = []\nfor num in lis:\n    now+=1\n    check.append(now)\n    a.append(now+num-1)\n    for i in range(num-1):\n        a.append(now)\n        now+=1\n\nprint(len(a))\nprint(*a)\n\nb = list(map(int, input().split()))\n\nV = []\nfor i in range(len(check)):\n    amari = b.index(check[i]) - check[i] + 1\n    m = check[i]\n    V.append((amari,m))\n\nx,d = remainder(V)\n\nprint(x)",
        "length": 41,
        "loc": 36
    },
    "abc286_g_38690639": {
        "buggy": "import sys\nni = lambda :int(input())\nna = lambda :list(map(int,input().split()))\nyes = lambda :print(\"yes\");Yes = lambda :print(\"Yes\");YES = lambda : print(\"YES\")\nno = lambda :print(\"no\");No = lambda :print(\"No\");NO = lambda : print(\"NO\")\n#######################################################################\n\nfrom collections import defaultdict\n \nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n \n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\nn, m = na()\ne = []\nfor i in range(m):\n    u,v = na()\n    u-=1\n    v-=1\n    e.append((u,v))\n\nk = ni()\nx = [i-1 for i in na()]\nxx = [0] * m\nfor i in range(k):\n    xx[x[i]] = 1\nuf = UnionFind(n)\ndeg = [0] * n\nfor i in range(m):\n    u,v = e[i]\n    if xx[i] ^ 1:\n        uf.union(u,v)\n    else:\n        deg[u]^=1\n        deg[v]^=1\n\n\nd = uf.all_group_members()\nans = 0\nfor i in d:\n    r = 0\n    for j in d[i]:\n        r ^= deg[i]\n    #print(d[i], r)\n    ans += r\nif ans <= 2:\n    Yes()\nelse:\n    No()\n",
        "length": 94,
        "loc": 88
    },
    "abc287_a_45997889": {
        "buggy": "n = int(input())\ncount = 0\nfor i in range(n):\n    a = input()\n    if a == 'for':\n        count= count + 1\n    else :\n        count=count \nif count > n/2 :\n   print('Yes')\nelse:\n    print('No')",
        "length": 12,
        "loc": 5
    },
    "abc287_c_46180932": {
        "buggy": "N, M = map(int, input().split())\nraw_path = [list(map(lambda i: int(i) - 1, input().split())) for _ in range(M)]\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x]) # \u7d4c\u8def\u5727\u7e2e\n        return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]: # \u30e9\u30f3\u30af\u306b\u3088\u308b\u8efd\u91cf\u5316\n            x, y = y, x\n        \n        self.parents[x] += self.parents[y] # \u8ca0\u306e\u6570\u304c\u5927\u304d\u304f\u306a\u308b\u307b\u3069\u3001\u30ce\u30fc\u30c9\u306e\u6570\u304c\u591a\u3044\u3068\u3044\u3046\u3053\u3068\n        self.parents[y] = x\n\nunionFind = UnionFind(N)\nresult_flag = True\n\ncounter = [0] * N\n\nfor p in raw_path:\n    counter[p[0]] += 1\n    counter[p[1]] += 1\n    if unionFind.find(p[0]) == unionFind.find(p[1]):\n        result_flag = False\n        break\n    unionFind.union(p[0], p[1])\n\ncount_parent = 0\nfor i in unionFind.parents:\n    if i < 0:\n        count_parent += 1\nif count_parent == 1 and result_flag and (N == 1 or set(counter) == set([1, 2])):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n    ",
        "length": 50,
        "loc": 46
    },
    "abc287_g_50462471": {
        "buggy": "import sys\ninput = sys.stdin.readline\nclass BIT:\n    def __init__(self,N):\n        self.s = (N-1).bit_length()\n        self.N = 1<<self.s\n        self.data = [0]*(self.N+1)\n    def build(self,A):\n        for i in range(1,self.N+1):\n            self.data[i] += A[i-1]\n            if i+(i&-i) <= self.N:\n                self.data[i+(i&-i)] += self.data[i]\n    def add(self,i,x):\n        i += 1\n        while i <= self.N:\n            self.data[i] += x\n            i += i&-i\n    def fold(self,l,r):\n        res = 0\n        while r > 0:\n            res += self.data[r]\n            r -= r&-r\n        while l > 0:\n            res -= self.data[l]\n            l -= l&-l\n        return res\n    def all_prod(self):\n        return self.data[self.N]\n    def max_right_(self,x):\n        i = self.N\n        if self.data[i] <= x:\n            return self.N\n        tmp = 0\n        for j in range(self.s-1,-1,-1):\n            if tmp+self.data[i] <= x:\n                tmp += self.data[i]\n                i += 1<<j\n            else:\n                i -= 1<<j\n        if tmp+self.data[i] <= x:\n            return i\n        else:\n            return i-1\n    def max_right(self,l,x):\n        return self.max_right_(self.fold(0,l)+x)\n\nN = int(input())\nX_ = set()\ndata = [[0,0] for _ in range(N)]\nfor i in range(N):\n    a,b = map(int,input().split())\n    data[i][0],data[i][1] = a,b\n    X_.add(a)\nQ = int(input())\nquery = [list(map(int,input().split())) for _ in range(Q)]\nfor q in range(Q):\n    qu = query[q]\n    if qu[0] == 1:\n        x,y = qu[1:]\n        X_.add(y)\nM = len(X_)\nX = sorted(X_)\nX.reverse()\nco = {x : i for i,x in enumerate(X)}\nbit0 = BIT(M)\nbit1 = BIT(M)\nfor i in range(N):\n    a,b = data[i][0],data[i][1]\n    bit0.add(co[a],a*b)\n    bit1.add(co[a],b)\nfor i in range(Q):\n    qu = query[i]\n    if qu[0] == 1:\n        x,y = qu[1:]\n        a,b = data[x-1]\n        bit0.add(co[a],-a*b)\n        bit1.add(co[a],-b)\n        bit0.add(co[y],y*b)\n        bit1.add(co[y],b)\n        data[x-1][0] = y\n    if qu[0] == 2:\n        x,y = qu[1:]\n        a,b = data[x-1]\n        bit0.add(co[a],a*y-a*b)\n        bit1.add(co[a],y-b)\n        data[x-1][1] = y\n    if qu[0] == 100:\n        x = qu[1]\n        if bit1.all_prod() < x:\n            print(-1)\n            continue\n        r = bit1.max_right_(x)\n        res = bit0.fold(0,r)\n        if r < M:\n            res += X[r]*(x-bit1.fold(0,r))\n        print(res)",
        "length": 96,
        "loc": 87
    },
    "abc288_b_44592257": {
        "buggy": "n, k = map(int, input().split())\ns = [input() for _ in range(n)]\ns.sort()\nfor i in range(k):\n  print(s[i])",
        "length": 5,
        "loc": 2
    },
    "abc288_e_41523056": {
        "buggy": "\"\"\"\ncf. https://atcoder.jp/contests/abc288/editorial/5659\n\"\"\"\nINF = 10**12\ndef solve(n, m, a, c, x):\n    x = [_-1 for _ in x]\n    # i\u756a\u76ee\u306e\u5546\u54c1\u307e\u3067\u3067\u3001j\u500b\u306e\u5546\u54c1\u3092\u8cb7\u3063\u305f\u3068\u304d\u306b\u3001\u5fc5\u8981\u306a\u30b3\u30b9\u30c8\n    cost = [[INF] * n for i in range(n)]\n    for i in range(n):\n        cost[i][0] = c[i]\n        for j in range(1, i+1):\n            cost[i][j] = min(cost[i][j-1], c[i-j])\n\n    # \u8cfc\u5165\u304c\u5fc5\u9808\u304b\u3069\u3046\u304b\n    required = [False] * n\n    for i in x:\n        required[i] = True\n\n    dp = [[INF] * (n+1) for i in range(n+1)] # (\u73fe\u5728\u306e\u5546\u54c1, \u8cfc\u5165\u3057\u305f\u6570) => \u6700\u5c0f\u91d1\u984d\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(i+1):\n            dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + a[i] + cost[i][j])\n            if not required[i]: # \u5546\u54c1i\u3092\u8cb7\u308f\u306a\u3044\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n    return min(dp[n][m:])\n\nn, m = map(int, input().split())\na = [*map(int, input().split())]\nc = [*map(int, input().split())]\nx = [*map(int, input().split())]\nprint(solve(n, m, a, c, x))",
        "length": 33,
        "loc": 4
    },
    "abc289_a_45965844": {
        "buggy": "print(input().replace(\"0\", \"1\").replace(\"1\", \"0\"))",
        "length": 1,
        "loc": 1
    },
    "abc289_c_45901971": {
        "buggy": "import itertools\nn,m = map(int,input().split())\nl = []\nfor i in range(m):\n  c = int(input())\n  a = list(map(int,input().split()))\n  l.append(a)\n\nans = 0\nfor i in range(1,n+1):\n  for j in itertools.combinations(l,i):\n    s = set([])\n    for k in j:\n      s = s | set(k)\n    if len(s) == n:\n      ans += 1\nprint(ans)",
        "length": 17,
        "loc": 10
    },
    "abc289_d_46033056": {
        "buggy": "INT = lambda : int(input())\nMI = lambda : map(int, input().split())\nMI_DEC = lambda : map(lambda x : int(x)-1, input().split())\nLI = lambda : list(map(int, input().split()))\nLI_DEC = lambda : list(map(lambda x : int(x)-1, input().split()))\nINF = float('inf')\n\nN = INT()\nA = LI()\nM = INT()\nB = LI()\nX = INT()\n\ndp = [False] * (X+1)\ndp[0] = True\ncantMove = [False] * (X+1)\nfor i in range(M):\n    cantMove[B[i]] = True\n\n\nfor i in range(X):\n    if cantMove[i]:\n        continue\n\n    for a in A:\n        if i + a <= X:\n            dp[i+a] = True\n\nprint('Yes' if dp[X] else 'No')",
        "length": 29,
        "loc": 22
    },
    "abc290_b_46211702": {
        "buggy": "# B\nN, K = map(int, input().split())\nS = input()\n#N, K = 10, 3\n#S = \"oxxoxooxox\"\n#print(S)\ncnt = 0\ns = \"\"\nfor i in S:\n    #print(i)\n    if i == \"o\" and cnt < 3:\n        cnt += 1\n        s = s + i\n    elif i == \"o\":\n        s = s + \"x\"\n    if i == \"x\":\n        s = s + \"x\"\nprint(s)",
        "length": 18,
        "loc": 11
    },
    "abc290_c_45228128": {
        "buggy": "n,k=(int(x) for x in input().split())\na=set([])\nA=input().split()\nfor i in range(n):\n  if not A[i] in a:\n    a.add(int(A[i]))\n\nif k>=10:\n  k=10\nans=0\nfor i in range(k):\n  if i in a:\n    ans+=1\n  else:\n    break\nprint(ans)",
        "length": 16,
        "loc": 0
    },
    "abc291_a_45508180": {
        "buggy": "S = input()\n\nfor i in range(len(S)):\n  if 'A' < S[i] < 'Z':\n    print(i + 1)",
        "length": 5,
        "loc": 4
    },
    "abc291_b_45669598": {
        "buggy": "# import\u7cfb ---\nfrom heapq import heappush, heappop\nfrom math import factorial\n\n# \u5165\u529b\u7528 ---\nINT = lambda: int(input())\nMI = lambda: map(int, input().split())\nMI_DEC = lambda: map(lambda x: int(x) - 1, input().split())\nLI = lambda: list(map(int, input().split()))\nLI_DEC = lambda: list(map(lambda x: int(x) - 1, input().split()))\nLS = lambda: list(input())\nLSS = lambda: input().split()\n\nINF = 1 << 60\nMOD = 998244353\n\n# \u30b3\u30fc\u30c9 ---\nN = INT()\nX = sorted(LI())\n\nprint(sum(X[N:4*N]) / 3*N)\n",
        "length": 21,
        "loc": 21
    },
    "abc291_c_45227759": {
        "buggy": "N = int(input())\nS = input()\nse = set()\nse.add((0, 0))\nnow = (0, 0)\nfor i in range(N):\n  if S[i] == \"L\":\n    now = (now[0] - 1, now[1])\n  if S[i] == \"R\":\n    now = (now[0] + 1, now[1])\n  if S[i] == \"U\":\n    now = (now[0], now[1] + 1)\n  if S[i] == \"D\":\n    now = (now[0], now[1] - 1)\n  se.add(now)\nif len(se) == N + 1:\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 19,
        "loc": 16
    },
    "abc291_d_45489809": {
        "buggy": "n=int(input())\nmod=998244353 \nc=[]\n\nfor i in range(n):\n    a,b=map(int,input().split())\n    c.append((a,b))\nif n==1:\n    print(0)\nelse:\n    dp=[[0]*2 for i in range(n)]\n    for j in range(2):\n        if c[1][j]!=c[0][j]:\n            dp[1][j]+=1\n        if c[1][j]!=c[0][(j+1)%2]:\n            dp[1][j]+=1\n    \n    for i in range(1,n-1):\n        for j in range(2):\n            if c[i+1][j]!=c[i][j]:\n                dp[i+1][j]+=dp[i][j]\n                dp[i+1][j]%=mod \n            if c[i+1][j]!=c[i][(j+1)%2]:\n                dp[i+1][j]+=dp[i][(j+1)%2]\n                dp[i+1][j]%=mod\n\n    ans=dp[n-1][0]+dp[n-1][1]\n    print(ans%mod)",
        "length": 28,
        "loc": 9
    },
    "abc292_b_45695205": {
        "buggy": "n, q = map(int, input().split())\nplayer = [0] * n\nfor i in range(q):\n    c, x =   map(int,input().split())\n    if c == 1:\n        player[x - 1] += 1\n    elif c == 2:\n        player[x - 1] += 2\n    else:\n        if player[x - 1] == 2:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n",
        "length": 13,
        "loc": 10
    },
    "abc292_c_45536157": {
        "buggy": "from collections import Counter\nfrom functools import reduce\n\nN = int(input())\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n    \n\ncnt = 0\nfor AB in range(1, N // 2 + 1):\n  CD = N - AB\n  if AB == 1:\n    cntAB = 1\n  else:\n    cntAB = reduce(lambda x, y: x * (y+1), Counter(prime_factorize(AB)).values(), 1)\n  if CD == 1:\n    cntCD = 1\n  else:\n    cntCD = reduce(lambda x, y: x * (y+1), Counter(prime_factorize(CD)).values(), 1)\n  cnt += (cntAB * cntCD * 2) if AB != CD else (cntAB + cntCD)\n\n\nprint(cnt)\n",
        "length": 37,
        "loc": 34
    },
    "abc292_d_44987159": {
        "buggy": "# D - Unicyclic Components\nfrom collections import defaultdict\n\ndef main():\n  N, M = map(int, input().split())\n  lib = UnionFind(N)\n  vertexes = set()\n  cnt = defaultdict(int)\n\n  for _ in range(M):\n    u, v = map(int, input().split())\n    lib.unite(u, v)\n    vertexes.add(u)\n    vertexes.add(v)\n    cnt[u] += 1\n    cnt[v] += 1\n    \n  groups = lib.get_groups(vertexes)\n  matches = True\n\n  for group in groups:\n    n = len(group)\n    m = 0\n\n    for v in group:\n      m += cnt[v]\n    \n    if n != m//2:\n      matches = False\n  \n  if matches:\n    print('Yes')\n  else:\n    print('No')\n\n\nclass UnionFind:\n  def __init__(self, n):\n    # n \u3067\u9802\u70b9\u6570\u3092\u53d7\u3051\u53d6\u308b\n    # \u9802\u70b9\u756a\u53f7\u304c\u9023\u756a\u3067\u306f\u306a\u3044\u5834\u5408\u3001\u6700\u5927\u306e\u9802\u70b9\u756a\u53f7\u3092\u6e21\u3057\u3066\u3082OK\n    # \u9802\u70b9\u756a\u53f7\u306f1\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067\u3001n\u9802\u70b9\u306e\u5834\u5408\u3001n+1\u3067\u30ea\u30b9\u30c8\u3092\u4f5c\u6210\u3057\u3066\u304a\u304f\n\n    # [summary]\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u3092\u5ba3\u8a00\n\n    # \u5404\u9802\u70b9\u306e\u89aa\u306e\u756a\u53f7(\u81ea\u8eab\u304c\u6839\u306e\u5834\u5408\u306f -1)\n    # \u6700\u521d\u306f\u3001\u3069\u306e\u9802\u70b9\u3082\u6839\u3067\u3042\u308b\u3068\u3057\u3066\u521d\u671f\u5316\n    self.par = [-1] * (n + 1)\n\n    # \u5404\u9802\u70b9\u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u6570\n    self.size = [1] * (n + 1)\n\n    # \u9802\u70b9\u3092\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046\n    self.groups = dict()\n    \n    # \u30b5\u30a4\u30af\u30eb(\u9589\u8def)\u3092\u691c\u51fa\u3059\u308b\u305f\u3081\u306e\u30d5\u30e9\u30b0\n    self.cycled = False\n\n\n  def root(self, x):\n    # [summary]\u6839\u3092\u6c42\u3081\u308b\n    # \u305d\u306e\u904e\u7a0b\u3067\u3001\u7d4c\u8def\u5727\u7e2e\u3092\u884c\u3046(par[x]\u306b\u306f\u3001\u6839\u304c\u683c\u7d0d\u3055\u308c\u308b)\n\n    if self.par[x] == -1:\n      # x\u304c\u6839\u306e\u5834\u5408\u306f\u3001\u76f4\u63a5x\u3092\u8fd4\u3059\n      return x\n    else:\n      # x\u306e\u89aapar[x]\u3092\u6839\u306b\u5f35\u308a\u66ff\u3048\u308b\n      # (\u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u3089\u308c\u308b)\n      # \u5404\u9802\u70b9\u306e\u89aa\u5b50\u95a2\u4fc2\u3092\u77e5\u308a\u305f\u3044\u5834\u5408\u306f\u3001\u3053\u306e\u884c\u3092\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n      self.par[x] = self.root(self.par[x])\n\n      return self.root(self.par[x])\n\n\n  def is_same(self, x, y):\n    # [summary]x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n\n    if self.root(x) == self.root(y):\n      return True\n\n\n  def unite(self, x, y):\n    # [summary]x\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3068 y\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3059\u308b\n\n    # x,y\u3092 \u305d\u308c\u305e\u308c\u6839\u307e\u3067\u79fb\u52d5\u3059\u308b\n    x = self.root(x)\n    y = self.root(y)\n\n    if x == y:\n      # \u3059\u3067\u306b\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u3068\u304d\u306f \u4f55\u3082\u3057\u306a\u3044\n      # \u3059\u3067\u306b\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3057\u3066\u3044\u308b\u306e\u306b\n      # \u307e\u305f\u8fba\u3092\u3064\u306a\u3044\u3060\u3089\u3001\u9589\u8def\u304c\u767a\u751f\u3059\u308b\n      # (\u5b9f\u88c5\u4e0a\u306f\u3001\u5b9f\u969b\u306b\u8fba\u3092\u3064\u306a\u3050\u8a33\u3067\u306f\u306a\u304f\n      # \u30d5\u30e9\u30b0\u3092\u30aa\u30f3\u306b\u3059\u308b\u3060\u3051)\n      self.cycled = True  \n    else:\n      # union by size(y\u5074\u306e\u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u304f\u306a\u308b\u3088\u3046\u306b\u3059\u308b)\n      if self.size[x] < self.size[y]:\n        x, y = y, x\n\n      # y\u3092x\u306e\u5b50\u306b\u3059\u308b\n      self.par[y] = x\n      self.size[x] += self.size[y]\n\n\n  def detects_cycle(self):\n    return self.cycled\n\n\n  def get_size(self, x):\n    # [summary]x\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u6570\n\n    return self.size[self.root(x)]\n\n\n  def get_groups(self, vertexes):\n    # [summary]\u5404\u9802\u70b9\u3092\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3057\u3066\u3001\"[1,2,4], [3,5]\"\u306e\u3088\u3046\u306a\n    # \u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3055\u308c\u305f\u9802\u70b9\u756a\u53f7\u306e\u96c6\u5408\u3092\u8fd4\u3059\n\n    self.__break_into_groups(vertexes)\n\n    return self.groups.values()\n\n\n  def __break_into_groups(self, vertexes):\n    # [summary]\u5404\u9802\u70b9\u3092\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3059\u308b\n\n    for v in vertexes:\n      r = self.root(v)\n\n      if not r in self.groups.keys():\n        self.groups[r] = [v]\n      else:\n        self.groups[r].append(v)\n\n\nif __name__ == '__main__':\n  main()",
        "length": 138,
        "loc": 18
    },
    "abc292_e_50119653": {
        "buggy": "n, m = map(int, input().split())\nedge = [[] for _ in range(n+1)]\neset = [set() for _ in range(n+1)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edge[a] += [b]\n    eset[a].add(b)\n\nans = 0\nfor i in range(n):\n    vis = [0]*(n+1)\n    i += 1\n    vis[i] = 1\n    q = [i]\n    while q:\n        v = q.pop()\n        for nv in edge[v]:\n            if vis[nv]: continue\n            vis[nv] = 1\n            q += [nv]\n            ans += 1\nprint(ans)\n",
        "length": 23,
        "loc": 23
    },
    "abc292_f_45523633": {
        "buggy": "import math\nA,B = map(int,input().split())\nif A > B:\n    A,B = B,A\n\n\ndef isOK(key):\n    if math.cos(key)*A/math.cos(math.pi/6-key) <= B:\n        return True\n    else:\n        return False\n\n\ndef search():\n    l,r = 0,math.pi/12\n    while r-l < 10**(-9):\n        mid = (r+l)/2\n        if isOK(mid):\n            r = mid\n        else:\n            l = mid\n    return A/math.cos(math.pi/6-r)\n\n\nprint(search())",
        "length": 25,
        "loc": 16
    },
    "abc293_b_46050349": {
        "buggy": "# B\nn = int(input())\na = list(map(int, input().split()))\n#n = 5\n#a = [3, 1, 4, 5, 4]\n#print(a)\ncall = set()\nfor i in range(n):\n    #print(i)\n    #print(a[i])\n    if i+1 in call:\n        pass\n    else:\n        call.add(a[i])\nprint(sorted(call))\nno_call =[]\nfor i in range(1, n+1):\n    if i not in call:\n        #print(i)\n        no_call.append(i)\nprint(len(no_call))\nprint(*no_call)\n",
        "length": 22,
        "loc": 15
    },
    "abc293_c_45502821": {
        "buggy": "# import\u7cfb ---\nfrom more_itertools import distinct_permutations\n\n# \u5165\u529b\u7528 ---\nINT = lambda: int(input())\nMI = lambda: map(int, input().split())\nMI_DEC = lambda: map(lambda x: int(x) - 1, input().split())\nLI = lambda: list(map(int, input().split()))\nLI_DEC = lambda: list(map(lambda x: int(x) - 1, input().split()))\nLS = lambda: list(input())\nLSS = lambda: input().split()\n\n# \u30b3\u30fc\u30c9 ---\nH, W = MI()\n\nfield = []\n\nfor _ in range(H):\n    field.append(LI())\n\nans = 0\n\nfor perm in distinct_permutations([(0, 1)] * (H - 1) + [(1, 0)] * (W - 1)):\n    is_ok = True\n    \n    visited = set([field[0][0]])\n    now_x, now_y = 0, 0\n    \n    for x, y in perm:\n        now_x += x; now_y += y\n        if field[now_y][now_x] in visited:\n            is_ok = False\n            break\n        visited.add((now_x, now_y))\n    \n    if is_ok:\n        ans += 1\n\nprint(ans)\n",
        "length": 39,
        "loc": 34
    },
    "abc293_e_45761832": {
        "buggy": "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n\nA, X, M = map(int, readline().split())\n\ndef f(X):\n    if X == 1:\n        return 1\n    num = f(X // 2)\n    ret = num + pow(A, X // 2, M) * num\n    ret %= M\n    if X % 2:\n        ret += pow(A, X - 1, M)\n        ret %= M\n    return ret\n\nprint(f(X))\n",
        "length": 21,
        "loc": 21
    },
    "abc294_d_45910052": {
        "buggy": "N, Q = map(int, input().split())\n\n# \u7b54\u3048\u306e\u5019\u88dc\nlast_ans = 0\n\n# \u5217\u306e\u5148\u982d\ntop = 0\n\n# \u53d7\u4ed8\u306b\u547c\u3070\u308c\u305f\u304c\u3001\u884c\u3063\u3066\u306a\u3044\nready = [False] * N\n\nfor i in range(Q):\n  t = input()\n  if t == \"1\":\n    ready[top] = True\n    top += 1\n  elif t == \"3\":\n    for j in range(last_ans, N):\n      if ready[j] == True:\n        print(j + 1)\n        last_ans = j + 1\n        break\n  else:\n    x = int(t[2:])\n    ready[x - 1] = False",
        "length": 25,
        "loc": 21
    },
    "abc294_f_53961424": {
        "buggy": "def main():\n\n   from fractions import Fraction\n   from bisect import bisect_left, bisect_right, insort\n\n   N, M, K = map(int, input().split())\n   AB = [tuple(map(int, input().split())) for _ in range(N)]\n   CD = [tuple(map(int, input().split())) for _ in range(M)]\n\n   def is_ok(X: Fraction):\n      p, q = X.as_integer_ratio()\n      r = q-p\n\n      Dab = [p*b - r*a for a, b in AB]\n      Dcd = [r*c - p*d for c, d in CD]\n      Dcd.sort()\n\n      cnt = 0\n      for dab in Dab:\n         cnt += M - bisect_left(Dcd, dab)\n\n      return cnt >= K\n\n   def bin_search(ok: Fraction, ng: Fraction):\n      while abs(ok-ng) > 1e-10:\n         mid = (ok+ng)/2\n         if is_ok(mid):\n            ok = mid\n         else:\n            ng = mid\n      return ok\n\n   ans = bin_search(Fraction(0), Fraction(1))\n   print(float(ans*100))\n\n\nmain()\n",
        "length": 37,
        "loc": 25
    },
    "abc295_a_45272260": {
        "buggy": "n=int(input())\nx=list(input().split())\neng=[\"and\",\"not\",\"that\",\"the\",\"you\"]\n\nfor i in range(n):\n    print(i)\n    print(x[i])\n    if x[i] in eng:\n        print(\"Yes\")\n        break\n    elif i==n-1:\n        print(\"No\")",
        "length": 12,
        "loc": 0
    },
    "abc295_e_42264948": {
        "buggy": "import sys\ninput = sys.stdin.readline\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\n\n\n\nN, M, K = mi()\nA = list(mi())\n\n# N, M, K = 10,20,7\n# A = [6, 5, 0, 2, 0, 0, 0, 15, 0, 0]\n\n# N,M,K = [3, 5, 2]\n# A = [2, 0, 4]\n\n###############\nMAX = N+1\nMOD = 998244353\nfac = [0 for i in range(0,MAX)]\nfinv = [0 for i in range(0,MAX)]\ninv = [0 for i in range(0,MAX)]\n\nfac[0] = fac[1] = 1\ninv[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,MAX):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = MOD - MOD//i*inv[MOD%i]%MOD\n    finv[i] = finv[i-1]*inv[i]%MOD\n\ndef comb(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD\n###############\n\nA = [a for a in A if a > 0]\nA.sort()\nZ = N - len(A)  # 0 \u306e\u500b\u6570\n\nimport bisect\nNC = 0              # \u5834\u5408\u306e\u6570\nNA = pow(M,Z,MOD)     # \u5168\u3066\u306e\u5834\u5408\u306e\u6570\nNAI = pow(NA,MOD-2,MOD) # \u305d\u306e\u9006\u6570\nfor i in range(1,M+1):\n# i\u4ee5\u4e0a\u3068\u306a\u308b\u8981\u7d20\u6570\u304c N-K+1 \u4ee5\u4e0a\u3068\u306a\u308b\u78ba\u7387\u306e\u548c\u3092\u6c42\u3081\u308b\n    C = len(A)-bisect.bisect_left(A,i)  # i\u4ee5\u4e0a\u306e\u975e\u96f6\u8981\u7d20\u306e\u500b\u6570\n    if C >= N-K+1:\n        NC = (NC + NA) % MOD\n    elif C+Z < N-K+1:\n        continue\n    else:\n        # Z\u500b\u306e\u96f6\u8981\u7d20\u4e2dN-K+1-C\u500b\u4ee5\u4e0a\u3092i\u4ee5\u4e0a\u306b\u7f6e\u63db\u3048\u308b\n        for m in range(N-K+1-C, Z+1):\n#            print(f'i={i}, comb({Z},{m})*pow({M-i+1},{m})*pow({M},{Z-m})')\n            NC = (NC + comb(Z,m)*pow(M-i+1,m,MOD)*pow(M,Z-m,MOD)) % MOD\n\nprint((NC*NAI)%MOD)\n",
        "length": 59,
        "loc": 57
    },
    "abc296_b_45538761": {
        "buggy": "j_list=['a','b','c','d','e','f','g','h']\nstr_list = [input() for _ in range(8)]\ncounter = 0\nfor i in str_list:\n    for j in range(8):\n        if(i[j]=='*'):\n            print(counter)\n            print(j)\n            print(j_list[j]+str(8-counter))\n            break\n    counter += 1\n",
        "length": 11,
        "loc": 0
    },
    "abc296_c_46012599": {
        "buggy": "N, X = map(int, input().split())\nA = list(map(int,input().split()))\nAset = set(A)\nok = False\nfor a in A:\n    if X-a in Aset:\n        ok = True\n        break\nif ok:\n    print('Yes')\nelse:\n    print('No')\n    ",
        "length": 13,
        "loc": 6
    },
    "abc296_d_45799143": {
        "buggy": "import math\nfrom math import ceil\n\nn, m = map(int, input().split())\nans = n ** 2 + 2\n\nif m > n ** 2:\n  print(-1)\n  exit()\n\nfor i in range(1, 10 ** 6 + 1):\n  p = ceil(m / i)\n  if 1 <= p <= n and m <= i * p <= n ** 2:\n    ans = min(ans, i * p)\nif ans == n ** 2 + 2:\n  print(-1)\nelse:\n  print(ans)",
        "length": 18,
        "loc": 13
    },
    "abc296_f_45226037": {
        "buggy": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 10\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\n\n\nclass UnionFind:\n    def __init__(self, n):\n        # \u8ca0  : \u6839\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u7d76\u5bfe\u5024\u306f\u30e9\u30f3\u30af\u3092\u793a\u3059\n        # \u975e\u8ca0: \u6839\u3067\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\u5024\u306f\u89aa\u3092\u793a\u3059\n        self.table = [-1] * n\n        self.size = [1] * n\n        self.group_num = n\n\n    def root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.root(self.table[x])\n            return self.table[x]\n\n    def get_size(self, x):\n        r = self.root(x)\n        return self.size[r]\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def union(self, x, y):\n        r1 = self.root(x)\n        r2 = self.root(y)\n        if r1 == r2:\n            return\n        # \u30e9\u30f3\u30af\u306e\u53d6\u5f97\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.size[r1] += self.size[r2]\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n            self.size[r2] += self.size[r1]\n        self.group_num -= 1\n\n\nn=I()\nA=LI()\nB=LI()\nU=UnionFind(n)\nif sorted(A)!=sorted(B):\n    print(\"No\")\n    exit()\n\nif len(set(A))!=A:\n    print(\"Yes\")\n    exit()\n\nfor i in range(n):\n    U.union(A[i]-1,B[i]-1)\n\nvis=[0]*n\nL=[]\nfor g in range(n):\n    if vis[U.root(g)]==0:\n        vis[U.root(g)]=1\n        L+=[U.get_size(g)]\n\nLL=[]\nfor s in L:\n    if s==1:\n        continue\n    elif s>2:\n        if (s-1)%2:\n            LL+=[1]\n    else:\n        LL+=[1]\n\n\nif not LL or sum(LL)%2==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n\n",
        "length": 110,
        "loc": 80
    },
    "abc297_a_45500749": {
        "buggy": "n,d=map(int,input().split())\ndata=list(map(int,input().split()))\nfor i in range(n-1):\n    if data[i+1]-data[i]<=d:\n        print(data[i])\n        quit()\nprint(-1)",
        "length": 7,
        "loc": 5
    },
    "abc297_b_46013217": {
        "buggy": "s = input()\nr = s[::-1]\nif s.find('B') % 2 == r.find('B') % 2:\n    if s.find('R') < s.find('K') < 8 - s.find('R') + 1:\n        print('Yes')\n        exit()\nprint('No')",
        "length": 7,
        "loc": 4
    },
    "abc297_c_46194170": {
        "buggy": "n,m=map(int,input().split())\nfor _ in range(n):\n  a=list(input())\n  for i in range(m-1):\n    if a[i]=='T' and a[i+1]=='T':\n      a[i],a[i+1]='P','T'\n  print(''.join(a))\n  ",
        "length": 8,
        "loc": 6
    },
    "abc297_f_49316217": {
        "buggy": "# https://atcoder.jp/contests/abc297/tasks/abc297_f\n\nheight, width, num_blocks = map(int, input().split())\nMOD = 998244353\nn = 10**6\n\ndef g(h, w):\n    return cmb(h*w, num_blocks, MOD)\n\ndef f(h, w):\n    expected = g(h, w) - 2*g(h-1, w) - 2*g(h, w-1) + g(h-2, w) + g(h, w-2) + 4*g(h-1, w-1) - 2*g(h-2, w-1) - 2*g(h-1, w-2) + g(h-2, w-2)\n    expected %= MOD\n    return expected\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n       return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] % p * factinv[n-r] % p\n\nfact = [1, 1]  # fact[n] = (n! mod MOD)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod MOD)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    factinv.append((factinv[-1] * inv[-1]) % MOD)\n\nans = 0\nfor h in range(1, height+1):\n    for w in range(1, width+1):\n        if h*w < num_blocks: continue\n        ans += (height - h + 1)*(width - w + 1)*f(h, w)%MOD*h*w\n        ans %= MOD\nans *= pow(g(height, width), -1, MOD)\nans %= MOD\n\nprint(ans)\n",
        "length": 39,
        "loc": 8
    },
    "abc298_a_45277640": {
        "buggy": "def main():\n    n = int(input())\n    s = list(input())\n\n    ok = False\n\n    for i in range(n):\n        if s[i] == \"o\":\n            ok = True\n        elif s[i] == \"x\":\n            print(\"No\")\n            break\n\n    if ok == True:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \nif __name__ == \"__main__\":\n    main()",
        "length": 20,
        "loc": 12
    },
    "abc298_b_45996525": {
        "buggy": "# B\n\nn = int(input())\na = []\nfor _ in range(n):\n    cur_a = list(map(int, input().split()))\n    a.append(cur_a)\nb = []\nfor _ in range(n):\n    cur_b = list(map(int, input().split()))\n    b.append(cur_b)\n\n'''\nn = 3\na = [[0, 1, 1], [1, 0, 0], [0, 1, 0]]\nb = [[1, 1, 0], [0, 0, 1], [1, 1, 1]]\n'''\n'''\nn = 5\na = [[0, 0, 1, 1, 0], [1, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 0, 1]]\nb = [[1, 1, 0, 0, 1], [0, 1, 1, 1, 0], [0, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 0, 1, 0]]\n'''\n#print(a)\n#print(b)\nimport numpy as np\nfor i in range(1,4):\n    #print(\"=====================\")\n    #print(i)\n    a90 = np.rot90(a, k = -i)\n    #print(a90)\n    ans = True\n    for j in range(n):\n        for k in range(n):\n            #ans = True\n            #print(\"-----------------\")\n            #print(\"j, k\", j, k)\n            #print(\"a90:::::::::\", a90[j][k])\n            if a90[j][k] == 1:\n                #print(\"b[j][j]:::::\", b[j][k])\n                if b[j][k] != 1:\n                    ans = False\n                    #print(\"NG::::::::::::::::::::::\")\n    if ans:\n        break   \nif ans:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "length": 48,
        "loc": 26
    },
    "abc298_d_45550904": {
        "buggy": "\nfrom collections import deque, defaultdict, Counter\nQ = int(input())\nnum = 1\ndq = deque([1])\nMOD = 998244353\nans = []\npow10 = []\np = 1\nfor i in range(600001):\n\tpow10.append(p)\n\tp = (p*10)%MOD\n\nfor _ in range(Q):\n\tq = input().split()\n\tif q[0]==\"1\":\n\t\tt = int(q[1])\n\t\tnum = (num*10 + t) % MOD\n\t\tdq.append(t)\n\n\telif q[0]==\"2\":\n\t\ta = dq.popleft()\n\t\tnum -= (a * a*pow10[len(dq)])\n\t\tnum = (num+MOD) % MOD\n\n\telif q[0]==\"3\":\n\t\tans.append(num)\n\nprint(*ans ,sep='\\n')",
        "length": 29,
        "loc": 23
    },
    "abc299_a_46177642": {
        "buggy": "print('oiunt'[[*open(0)][1].replace('.','')!='|*|'::2])",
        "length": 1,
        "loc": 1
    },
    "abc299_c_45750635": {
        "buggy": "# Copyright (c) 2023, Le Duc Phuc Long\n\n# If you don't think twice, you have to code twice.\n\n# Import session\nimport sys\n#input = sys.stdin.readline\nfrom collections import defaultdict\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef instr():\n    return list(input().strip())\n\ndef invr():\n    return map(int, input().split())\n\n############ ---- Other Functions ---- ############\n# Precompute\n\n# IO\n#input = sys.stdin.readline\n#sys.stdin = open('in.txt', 'r')\n#sys.stdout = open('out.txt', 'w')\n# Main function\n\nn = inp()\ns = input().strip()\n\ncur, ans = 0, -1\nfor c in s:\n    if c == '-':\n        if cur == 0:\n            continue\n        ans = max(cur, ans)\n        cur = 0\n    else:\n        cur += 1\n\nif '-' in s:\n    ans = max(cur, ans)\n\nprint(ans)\n",
        "length": 48,
        "loc": 45
    },
    "abc299_d_45471725": {
        "buggy": "n = int(input())\n\nmax = n\nmin = 0\npast = -1\ncnt = 0\nans = -1\nwhile cnt <= 20 and max-min > 1:\n    mid = (max+min)//2\n    print(\"? \" + str(mid) + '\\n')\n    s = int(input())\n    if s == 1:\n        max = mid\n    else:\n        min = mid\n    cnt += 1\n\nprint(\"! \" + str(min))\nexit()",
        "length": 19,
        "loc": 10
    },
    "abc299_g_43242154": {
        "buggy": "#!/usr/bin/env python3\nimport sys\nimport heapq\n\ndef solve(N: int, M: int, A: \"list[int]\"):\n    last_index = [0 for _ in range(M+1)]\n    for i in range(N):\n        last_index[A[i]] = i\n    partitions = []\n    for i in range(1, M+1):\n        partitions.append(last_index[i])\n    partitions.sort(reverse=True)\n\n    l = -1\n    is_used = [False]*(M+1)\n    is_called = [False]*N\n    ans = []\n    que: list = []\n    while partitions:\n        partition = partitions.pop()\n        minimum_index = -1\n        for i in range(l+1, partition+1):\n            heapq.heappush(que, A[i]*N+i)\n            is_called[i] = True\n        if is_used[A[partition]]:\n            continue\n        while que:\n            minimum = heapq.heappop(que)\n            v, index = minimum // N, minimum % N\n            if (minimum_index < index) and (not is_used[v]):\n                minimum_index = index\n                is_used[v] = True\n                ans.append(v)\n                if v == A[partition]:\n                    break\n        l = partition\n    for i in range(1, M+1):\n        assert is_used[i]\n    for i in range(N):\n        assert is_called[i]\n    print(*ans)\n\n# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, M, A)\n\nif __name__ == '__main__':\n    main()\n",
        "length": 56,
        "loc": 19
    },
    "abc300_a_45457940": {
        "buggy": "N, A, B = map(int, input().split())\nC = list(map(int, input().split()))\nprint(C)\nfor i in range(len(C)):\n  if C[i] == A + B:\n    print(i+1)",
        "length": 6,
        "loc": 3
    },
    "abc300_c_45723345": {
        "buggy": "H,W = map(int,input().split())\nC = []\nfor i in range(H):\n    C.append(list(input()))\n\ndef check(y,x):\n    size = 0\n    while True:\n        if  (y + (size + 1) < H and x + (size + 1) < W and C[y+(size+1)][x+(size+1)] == '#') and \\\n            (y + (size + 1) < H and x - (size + 1) >= 0 and C[y+(size+1)][x-(size+1)] == '#') and \\\n            (y - (size + 1) >= 0 and x + (size + 1) < W and C[y-(size+1)][x+(size+1)] == '#') and \\\n            (y - (size + 1) >= 0 and x - (size + 1) >= 0 and C[y-(size+1)][x-(size+1)] == '#'):\n            size += 1\n        else:\n            break\n    ans[size] += 1\n\nans = [0 for _ in range(H+1)]\n\nfor i in range(H):\n    for j in range(W):\n        if C[i][j] == '#':\n            check(i,j)\n\nprint(*ans[1:])",
        "length": 25,
        "loc": 18
    },
    "abc300_d_45256387": {
        "buggy": "n = 10**12\n\ndef primes(n):\n    ass = []\n    is_prime = [True] * (n+1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if not is_prime[i]:\n            continue\n        for j in range(i*2, n+1, i):\n            is_prime[j] = False\n    for i in range(len(is_prime)):\n        if is_prime[i]:\n            ass.append(i)\n    return ass\n\nx = int((n/12)**0.5)\np = primes(x)\nm = len(p)\nans = 0\nfor b in range(1,m-1):\n    for c in range(b + 1, m):\n        if p[b] * p[c]**2 > n:\n            break\n        for a in range(b):\n            if p[a] **2 * p[b] * p[c]**2 > n:\n                break\n\n            else:\n                ans += 1\nprint(ans)\n",
        "length": 32,
        "loc": 1
    },
    "abc300_f_45435689": {
        "buggy": "\nn,m,k = map(int, input().split())\n\ns = input()\n\nli = [0 for i in range(n+1)]\n\nfor i in range(1, n+1):\n    c = s[i-1]\n    li[i] += li[i-1] \n    if c == \"x\":\n        li[i] += 1\n\nxcnt = li[-1]\nans = -1\n\n\nfor l in range(n):\n    \n    ok = 1\n    ng = n*m - l\n    \n    while abs(ok-ng) > 1:\n        mid = (ok+ng)//2\n        # print(ok,mid,ng)\n\n        # [l, l+mid)\u5185\u306bx\u304ck\u500b\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u304b\n        repeat = (l+mid) // n \n        res = (l+mid) % n\n        \n        \n        xnum = xcnt * repeat - li[l] + li[res]\n        # print(ok,mid,ng, xnum)\n        if xnum <= k:\n            ok = mid\n        else:\n            ng = mid\n\n    if ans < ok:\n        ans = ok\n\nprint(ans)\n\n\n\n",
        "length": 45,
        "loc": 21
    },
    "abc301_a_45927126": {
        "buggy": "N = int(input())\nS = input()\n\ncnt = 0\nfor i in S:\n    if i == \"T\":\n        cnt += 1\n\nif cnt > N - cnt:\n    print(\"T\")\nelse:\n    print(\"A\")",
        "length": 12,
        "loc": 9
    },
    "abc301_b_45340910": {
        "buggy": "n = int(input())\na = list(map(int,input().split()))\n\nb = []\nfor i in range(n-1):\n    if a[i] <= a[i+1]:\n        b += list(range(a[i],a[i+1]))\n    if a[i] >= a[i+1]:\n        b += list(range(a[i],a[i+1],-1))\n        \nb.append(a[-1])\n\nprint(b)",
        "length": 13,
        "loc": 13
    },
    "abc301_d_45747617": {
        "buggy": "import sys\nfrom collections import deque, defaultdict\nfrom math import *\nfrom bisect import bisect_left, bisect_right\ninput = sys.stdin.readline\n\ndef get(s1, s2):\n    global n \n    i = 0\n    while i < len(s1) and (s1[i] == '?' or s1[i] == s2[i]):\n        i += 1\n    if i == len(s1): return n\n    else:\n        if s1[i] < s2[i]:\n            v = 0\n            for j in range(i):\n                v = v * 2 + int(s2[j])\n            for j in range(i, len(s1)):\n                if s1[j] == '0': v = v * 2 \n                else:  v = v * 2 + 1\n            return v\n        else:\n            j = i - 1\n            while j >= 0 and (s1[j] != '?' or s2[j] == '0'):  \n                j -= 1\n            if j == -1: return -1\n            else:\n                v = 0\n                for k in range(j):\n                    v = v * 2 + int(s2[k])\n                v = v * 2 \n                for k in range(j+1, len(s1)):\n                    if s1[k] == '0': v = v << 1\n                    else: v = v * 2 + 1\n                return v \n\nif __name__ == \"__main__\":\n    s1 = input().strip()\n    n = int(input())\n    s2 = bin(n)[2:]\n    \n    i = 0\n    while i < len(s1) - 1 and s1[i] == '0':\n        i += 1\n    s1 = s1[i:]\n    v = 0\n    if len(s1) < len(s2):\n        for x in s1:\n            if x == '0': v = v * 2\n            else: v = v * 2 + 1 \n    elif len(s1) == len(s2):\n        v = get(s1, s2)\n    else:\n        le = len(s1) - len(s2)\n        if s1[:le] != '?' * le: v = -1\n        else:\n            v = get(s1[le:], s2)\n    print(v)\n\n    \n    \n        \n\n    \n            \n",
        "length": 65,
        "loc": 55
    },
    "abc301_f_51429838": {
        "buggy": "s=input()\n\nn=len(s)\nmod=998244353\n\ndp=[[0]*27 for _ in range(n+1)]\ndp2=[0]*(n+1)\ndp[0][0]=1\n\ncheck=[0]*26\ncnt=0\n\nx=ord('A')\n\nfor i in range(n):\n  if s[i]=='?':\n    for j in range(27):\n      dp[i+1][j]+=dp[i][j]*26\n      dp2[i+1]+=dp[i][j]*j\n      dp[i+1][j]%=mod\n      dp2[i+1]%=mod\n    for j in range(26):\n      dp[i+1][j+1]+=dp[i][j]*(26-j)\n      dp[i+1][j+1]%=mod\n  elif s[i].isupper():\n    if check[ord(s[i])-x]:\n      dp2[i+1]=sum(dp[i])%mod\n      break\n    for j in range(26):\n      if j<cnt: \n        continue\n      if j==0:\n        dp[i+1][j+1]=dp[i][j]\n      else:\n        dp[i+1][j+1]+=dp[i][j]*(25-j+1)*pow(26-cnt,-1,mod)%mod\n        dp2[i+1]+=dp[i][j]*(1-(25-j+1)*pow(26-cnt,-1,mod))%mod\n    dp2[-1]+=dp[i][-1]\n    check[ord(s[i])-x]+=1\n    cnt+=1\n  else:\n    for j in range(27):\n      dp[i+1][j]=dp[i][j]\n      \ndp3=[[0,0] for _ in range(n+1)]\n\ndp3[-1][0]=1\n\nfor i in reversed(range(n)):\n  if s[i]=='?':\n    dp3[i][0]+=dp3[i+1][0]*26\n    dp3[i][1]+=dp3[i+1][0]*26\n    dp3[i][1]+=dp3[i+1][1]*26\n    dp3[i][0]%=mod\n    dp3[i][1]%=mod\n  elif s[i].isupper():\n    dp3[i][1]=sum(dp3[i+1])%mod\n  else:\n    dp3[i][0]=dp3[i+1][0]\n\nans=sum(dp[-1])%mod\n\nfor i in range(n+1):\n  ans+=dp2[i]*sum(dp3[i])\n  ans%=mod\n\nprint(ans)",
        "length": 66,
        "loc": 37
    },
    "abc302_c_45989052": {
        "buggy": "import itertools\n\ndef diff(A, B):\n  res = 0\n  for a, b in zip(A, B):\n    if a != b:\n      res += 1\n  return res\n\nN, M = map(int, input().split())\nS = [input() for _ in range(N)]\n\nfor T in itertools.permutations(S):\n  ok = True\n  for i in range(N-1):\n    if diff(T[i], T[i+1]) != 1:\n      ok = False\n  if ok:\n    print(\"Yes\")\n    break\nprint(\"No\")\n      ",
        "length": 22,
        "loc": 20
    },
    "abc303_a_46127283": {
        "buggy": "n = int(input())\ns = input()\nt = input()\n\np = 0\n\nfor i in range(n):\n    if s[i] == \"1\" or s[i] == \"l\":\n        if t[i] == \"1\" or t[i] == \"l\":\n            p += 1\n        \n    elif s[i] == \"0\" or t[i] == \"o\":\n        if t[i] == \"0\" or t[i] == \"o\":\n            p += 1\n            \n    elif s[i] == t[i]:\n        p += 1\n    \nif p == n:\n    print(\"Yes\")\n    \nelse:\n    print(\"No\")\n    ",
        "length": 24,
        "loc": 11
    },
    "abc303_c_46045444": {
        "buggy": "# import math\n# import sys\n# sys.setrecursionlimit(10**9)\n# from itertools import permutations\n# from itertools import combinations\n# from functools import lru_cache\n# import heapq\n\n# DIV = 10**9+7\n\n#data(yyyy-mm-dd):\n#recursion\u4f7f\u3046\u6642\u306fCpython\u3067\u51fa\u3059\uff0e\u305d\u308c\u4ee5\u5916\u306f\u57fa\u672cPypy\ndef main():\n    n,m,hit_point,k = map(int,input().split(\" \"))\n    s = list(input())\n    item = dict()\n    for i in range(m):\n        x,y = map(int,input().split(\" \"))\n        item[(x,y)] = m\n    \n    # print(item)\n    flag = True\n    x = 0\n    y = 0\n    for i in range(n):\n        # print(i,x,y,hit_point,item[x][y])\n        #\u79fb\u52d5\u7d4c\u8def\n        char = s[i]\n        if char == \"R\":\n            x += 1\n        elif char == \"L\":\n            x -= 1\n        elif char == \"U\":\n            y += 1\n        elif char == \"D\":\n            y -= 1\n        #\u79fb\u52d5\u3059\u308b\n        hit_point -= 1\n        if hit_point < 0:\n            print(\"No\")\n            return 1\n        if hit_point < k and (x,y) in item:\n            # print(\"recoverd\")\n            if item[(x,y)] > 0:\n                hit_point = k\n                item[(x,y)] -= 1\n    print(\"Yes\")\n    return 1\n\n\n\nif __name__ == \"__main__\":\n    main()",
        "length": 53,
        "loc": 19
    },
    "abc303_e_53920661": {
        "buggy": "from collections import deque\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\ndist = [-1 for i in range(N)]\nque = deque()\nfor i in range(N):\n    if G[i] == 1:\n        dist[i] = 0\n        que.append(i)\n        break\n\n\nwhile que:\n    v = que.popleft()\n    for v2 in G[v]:\n        if dist[v2] != -1:\n            continue\n        dist[v2] = dist[v] + 1\n        que.append(v2)\n\ncenter = [i for i in range(N) if dist[i]%3==1]\nans = [len(G[i]) for i in center]\nans.sort()\nprint(*ans)\n",
        "length": 31,
        "loc": 14
    },
    "abc304_a_45720608": {
        "buggy": "n=int(input())\nINDEX=-1\nnow=float('inf')\nans=[]\nfor i in range(n):\n    s,a=input().split()\n    a=int(a)\n    ans.append([s,a])\n    if now>a:\n        now=a\n        INDEX=i\nfor i in range(n):\n    print(*ans[(i+INDEX)%n])",
        "length": 13,
        "loc": 13
    },
    "abc304_b_45306152": {
        "buggy": "n = int(input())\n\nfor i in range(6):\n    if n <= 10**(3 + i) - 1:\n        print((n // (10**i)) * 10**i)\n        break\n",
        "length": 6,
        "loc": 3
    },
    "abc304_d_45574429": {
        "buggy": "import numpy as np\nimport bisect\nw, h = map(int,input().split())\nn = int(input())\nichigo = [ list(map(int,input().split())) for _ in range(n)]\nA = int(input())\na = list(map(int,input().split()))\nB = int(input())\nb = list(map(int,input().split()))\n\nans = {}\nfor i in range(n):\n  s = bisect.bisect(a,ichigo[i][0])\n  t = bisect.bisect(b,ichigo[i][1])\n  if (s,t) in ans:\n    ans[(s,t)] += 1\n  else:\n    ans[(s,t)] = 1\n\n\n\nlis = list(ans.values())\n\nM = max(lis)\nif len(ans) == (A+1)*(B+1):\n  n = min(lis)\nelse:\n  n = 0\nprint(M,n)",
        "length": 29,
        "loc": 29
    },
    "abc305_a_45435091": {
        "buggy": "n=100\n\nif n%5<3:\n    ans=n-(n%5)\nelse:\n    ans=n+5-(n%5)\nprint(ans)",
        "length": 7,
        "loc": 1
    },
    "abc306_b_45523037": {
        "buggy": "import sys\ninput = lambda: sys.stdin.readline().strip()\n\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(63):\n    if a[i] == 0:\n        continue\n    else:\n        ans += (2 ** i)\nprint(ans)",
        "length": 12,
        "loc": 7
    },
    "abc307_a_45953883": {
        "buggy": "N = int(input())\nA = list(map(int,input().split()))\n\nres = [0]*N\nSUM = 0\nfor i in range(len(A)):\n    SUM += A[i]\n    if (i + 1)%7==0:\n        res[i//7] = SUM\n        SUM = 0\n\nprint(res)",
        "length": 12,
        "loc": 12
    },
    "abc308_a_46000754": {
        "buggy": "S = list(map(int, input().split()))\n\nN = len(S)\nfor i in range(N):\n    if sorted(S) == S or not(100 <= S[i] <= 675) or S[i]%25 != 0:\n        print('No')\n        exit()\nelse:\n    print('Yes')",
        "length": 9,
        "loc": 5
    },
    "abc308_b_45960039": {
        "buggy": "n, m = map(int, input().split())\nc = input().split()\nd = input().split()\np = list(map(int, input().split()))\nds = {d[i]: p[1 + i] for i in range(m)}\ns = 0\nfor i in c:\n    if i not in ds:\n        print(p[0])\n    else:\n        s += ds[i]\nprint(s)",
        "length": 12,
        "loc": 9
    },
    "abc308_d_54718266": {
        "buggy": "h,w=map(int,input().split())\ngrid=[['.' for _ in range(w+2)]]\nfor _ in range(h):\n    tmp=list(input())\n    grid.append(['.']+tmp+['.'])\ngrid.append(['.' for _ in range(w+2)])\n\nif grid[1][1]!='s':\n    print('No')\nelse:\n    bool=[[False for _ in range(w+2)] for __ in range(h+2)]\n    bool[1][1]=True\n    box=[(1,1)]\n    direction=[(-1,0),(1,0),(0,-1),(0,1)]\n    d=dict()\n    tmp=['s','n','u','k','e','s']\n    for i in range(5):\n        d[tmp[i]]=tmp[i+1]\n    \n    while len(box)>0:\n        H,W=box.pop()\n        for dh, dw in direction:\n            if bool[H+dh][W+dw]==False and grid[H+dh][W+dw]==d[grid[H][W]]:\n                bool[H+dh][W+dw]=True\n                box.append((H+dh,W+dw))\n\n    if grid[h][w]:\n        print('Yes')\n    else:\n        print('No')",
        "length": 30,
        "loc": 27
    },
    "abc309_a_45763717": {
        "buggy": "a,b=map(int,input().split())\nif set([a,b]) not in [{3,4},{6,7}] and abs(a-b) in [1,3]:\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 5,
        "loc": 2
    },
    "abc309_b_45722179": {
        "buggy": "N = int(input())\nA = [list(input()) for _ in range(N)]\nrotate_list = []\nfor i in range(N):\n    rotate_list.append(A[0][i])\n\nfor i in range(1, N):\n    rotate_list.append(A[i][N-1])\n\nfor i in reversed(range(0, N-1)):\n    rotate_list.append(A[N-1][i])\n\nfor i in reversed(range(1, N-1)):\n    rotate_list.append(A[i][0])\n\nfor i in range(N):\n    rotate_list.append(A[0][i])\n\ncnt = -1\nfor i in range(N):\n    A[0][i] = rotate_list[cnt]\n    cnt += 1\n\nfor i in range(1, N):\n    A[i][N-1] = rotate_list[cnt]\n    cnt += 1\n    \n\nfor i in reversed(range(0, N-1)):\n    A[N-1][i] = rotate_list[cnt]\n    cnt += 1\n\nfor i in reversed(range(1, N-1)):\n    A[i][0] = rotate_list[cnt]\n    cnt += 1\n\nfor i in range(N):\n    for j in range(N):\n        print(A[i][j], end=\"\")\n    print(\"\")",
        "length": 40,
        "loc": 36
    },
    "abc309_c_45772102": {
        "buggy": "N, K = map(int, input().split())\nAB = [tuple(map(int, input().split())) for _ in range(N)]\n\nAB.sort()\nmedicines = 0\nfor i in range(N):\n    medicines += AB[i][1]\n\nfor i in range(N):\n    if medicines <= K:\n        if i == 0:\n            print(1)\n            exit(0)\n        else:\n            print(AB[i - 1][0] + 1)\n            exit(0)\n    medicines -= AB[i][1]",
        "length": 17,
        "loc": 18
    },
    "abc309_e_46044734": {
        "buggy": "N, M = map(int, input().split())\np = [int(i) for i in input().split()]\n\nmemo = [-1] * (N + 1)\nfor i in range(M):\n    x, y = map(int, input().split())\n    memo[x] = y\n\nfor j in range(2, N + 1):\n    memo[j] = max(memo[j], memo[p[j - 2]] - 1)\n\nans = 0\nfor i in range(N + 1):\n    ans += memo[i] >= 0\n\nprint(ans)\n",
        "length": 16,
        "loc": 7
    },
    "abc310_a_46010909": {
        "buggy": "n, p, q = map(int,input().split())\nd_list = [int(e) for e in input().split()]\n\na = min(d_list)\n\nprint(min(p-q+a,p))",
        "length": 6,
        "loc": 6
    },
    "abc310_b_46217262": {
        "buggy": "#\u63d0\u51fa\u30b3\u30fc\u30c9------------------------------\nimport itertools\nimport sys\nsys.setrecursionlimit(10**6)\ndef IN(): return int(input())\ndef IS(): return input() \ndef INL(): return list(map(int,input().split()))\ndef ITN(): return map(int,input().split())\n\nN,M = ITN()\nPrice_and_func = [list(map(int,input().split())) for _ in range(N)]\n\ndef condition(l1,l2):\n    if l1[0] >= l2[0]:\n        if (set(l1[2:]) & set(l2[2:])) == set(l1[2:]):\n            if len(l2) > len(l1):\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n\nfor i in range(N):\n    for j in range(N):\n        if i == j: continue\n        if condition(Price_and_func[i],Price_and_func[j]) == True:\n            print('Yes')\n            exit()\n\nprint('No')",
        "length": 33,
        "loc": 16
    },
    "abc311_a_46012329": {
        "buggy": "N = int(input())\nS = input()\n\nprint(max([S.rfind('A'), S.rfind('B'), S.rfind('C')])+1)",
        "length": 4,
        "loc": 4
    },
    "abc311_b_45980619": {
        "buggy": "\ndef check(b,c):\n #start at a and end at bth day, check if everyone is available\n  for i in range(N):\n    for j in range(b,c+1):\n      if(a[i][j] == 'x'):\n        return False\n  return True\n  \na = []\ntemp  = []\nN,D = map(int,input().split()) #N = 3, D = 5\n\nfor i in range(N):\n  s = input()\n  a.append(s)\nfor i in range(N):\n  print(a[i])\nans = 0\nfor i in range(D):\n  for j in range(i,D):\n    #start at i and end at jth day\n    if(check(i,j) == True):\n      ans = max(ans,j-i+1)\n    \nprint(ans)\n\n# x = int((1 + D)*D/2)\n# for i in range(N):\n#   i = input(\"ox\")\n#   a.append(i)\n# for i in range(x):\n#   print(\"hello\")\n  ",
        "length": 34,
        "loc": 17
    },
    "abc312_a_45975022": {
        "buggy": "S = input()\n\nFlag = 0\n\nstring = ['ACE', 'BDF', 'CEG', 'DFA', 'EGB', 'FAC', 'GBD']\n\nfor i in range(len(string)):\n    if S == string[i]:\n        Flag = 1\n\nif Flag == 1:\n    print('Yes')\nelse:\n    print('NO')\n",
        "length": 14,
        "loc": 14
    },
    "abc312_b_45967113": {
        "buggy": "n,m = map(int,input().split())\na = [input() for _ in range(n)]\n\nfor i in range(n-9):\n    for j in range(m-9+1):\n        if (all(row[j:j+4] == \"###.\" for row in a[i:i+3]) and \n            a[i+3][j:j+4] == \"....\" and a[i+5][j+5:j+9] ==\"....\" and\n            all(row[j+5:j+9] == \".###\" for row in a[i+6:i+9])):\n            print(i+1,j+1)",
        "length": 9,
        "loc": 4
    },
    "abc312_c_46028780": {
        "buggy": "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nA.sort()\nB.sort()\nmx = max(A[-1],B[-1])\n\ndef is_ok(x):\n    sell = len([a for a in A if a<=x])\n    buy = len([b for b in B if b>=x])\n    return sell>=buy\n\n\ndef binary_search(ng, ok):\n    \"\"\"\n    \u521d\u671f\u5024\u306eng,ok\u3092\u53d7\u3051\u53d6\u308a,is_ok\u3092\u6e80\u305f\u3059\u6700\u5c0f(\u6700\u5927)\u306eok\u3092\u8fd4\u3059\n    ng ok \u306f  \u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1 \u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n    \u6700\u5927\u6700\u5c0f\u304c\u9006\u306e\u5834\u5408\u306f\u3088\u3057\u306a\u306b\u3072\u3063\u304f\u308a\u8fd4\u3059\n    \"\"\"\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n    \nprint(binary_search(0,mx))",
        "length": 28,
        "loc": 28
    },
    "abc312_d_52032093": {
        "buggy": "# D - Count Bracket Sequences\nimport math\n\ndef main():\n  S = input()\n  n = len(S)\n  dp = [[0] * (n+1) for _ in range(n+1)]\n  dp[0][0] = 1\n  mod = 998244353\n\n  for i in range(n):\n    for j in range(i+1):\n      half = math.ceil((i+1)/2)\n    \n      if S[i] == '(' or S[i] == '?':\n        if j+1 >= half:\n          dp[i+1][j+1] += dp[i][j]\n          dp[i+1][j+1] %= mod\n          \n      if S[i] == '' or S[i] == '?':\n        if j >= half:\n          dp[i+1][j] += dp[i][j]\n          dp[i+1][j] %= mod\n  \n  if n % 2 == 0:\n    print(dp[n][n//2])\n  else:\n    print(0)\n  \n\nif __name__ == '__main__':\n  main()",
        "length": 32,
        "loc": 20
    },
    "abc312_f_46140996": {
        "buggy": "N,M = map(int, input().split())\nT0 = []\nT1 = []\nT2 = []\nfor i in range(N):\n    t,x = map(int, input().split())\n    if t==0:\n        T0.append(x)\n    elif t==1:\n        T1.append(x)\n    elif t==2:\n        T2.append(x)\nT0.sort(reverse=True)\nT1.sort()\nT2.sort(reverse=True)\nimport heapq\nans = 0\nque = T0[:min(len(T1),M)]\nans = sum(que)\n#print(ans)\nnow = ans\nheapq.heapify(que)\nfor cnt in T2:\n    for i in range(cnt):\n        if len(T1)==0:\n            break\n\n        tmp = T1.pop()\n        heapq.heappush(que,tmp)\n        now += tmp\n    M = max(0,M-1)\n    while len(que)>M:\n        now-=heapq.heappop(que)\n   # print(now,que)\n    ans = max(now,ans)\nprint(ans)\n\n\n\n",
        "length": 39,
        "loc": 18
    },
    "abc313_a_45698032": {
        "buggy": "n=int(input())\np=list(map(int,input().split()))\nans=p[0] if p.count(max(p))==1 and p[0]==max(p) else max(p)+1-p[0]\nprint(ans)",
        "length": 4,
        "loc": 3
    },
    "abc313_b_45889938": {
        "buggy": "#\u6700\u5f37\u306e\u4eba\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\u3060\u3051\u306a\u306e\u3067\u3001\u8ab0\u304b\u306b\u8ca0\u3051\u305f\u304b\u3069\u3046\u304b\u3092\u8abf\u3079\u308b\n#\u8ca0\u3051\u305f\u3053\u3068\u304c\u306a\u3044\u4eba\u304c\u8907\u6570\u4eba\u3044\u305f\u3089\u6700\u5f37\u306f\u7d5e\u308c\u306a\u3044\nN,M=list(map(int,input().split()))\nplayer=[i for i in range(1,N+1)]\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    if b in player:\n        player.remove(b)\n\nif player.count==1:\n    print(player[0])\nelse:\n    print(-1)",
        "length": 13,
        "loc": 10
    },
    "abc313_c_45773299": {
        "buggy": "n = int(input())\na = sorted(list(map(int, input().split())))\n\navg = sum(a) // n\nextra = sum(a) % n\nans = 0\navg_list = [avg if i<extra else avg+1 for i in range(n)]\nfor i in range(n):\n    ans += abs(a[i] - avg_list[i])\nprint(ans // 2)\n",
        "length": 10,
        "loc": 7
    },
    "abc313_f_45736506": {
        "buggy": "import numpy as np\nimport scipy.optimize\n\nn, m = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(n)]\nxy = [(x-1, y-1) for _ in range(m) for x, y in [map(int, input().split())]]\n\nfor x, y in xy:\n    if x == y:\n        ab[x] = (max(ab[x]), min(ab[x]))\n\nbasis = sum(a for a, b in ab)\nc = np.array([-(b-a)/2 for a, b in ab])\n\nA_ub = np.eye(n)\nb_ub = np.zeros([n])\nfor x, y in xy:\n    if x != y:\n        A_ub[x, y] = -1\n        A_ub[y, x] = -1\n\nlp = scipy.optimize.linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1))\nprint(basis - c@lp.x)\n",
        "length": 23,
        "loc": 22
    },
    "abc314_a_45968783": {
        "buggy": "s = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679'\n\nn = int(input())\n\nprint(float(s[:n+2]))",
        "length": 5,
        "loc": 5
    },
    "abc314_d_46143343": {
        "buggy": "N = int(input())\nS = input()\nQ = int(input())\nTXC = [[i for i in input().split()] for _ in range(Q)]\n\nisupper = -1\nislower = -1\nlastmodified = [-1]*N\nli = [c for c in S]\nfor i, (t,x,c) in enumerate(TXC):\n    t = int(t)\n    if t == 1:\n        x = int(x)\n        li[x-1] = c\n        lastmodified[x-1] = i\n    elif t == 2:\n        islower = i\n    elif t == 3:\n        isupper = i\n\nans = []\nif islower < isupper:\n    for c, lm in zip(li, lastmodified):\n        ans.append(c if lm>isupper else c.upper())\nelif islower > isupper:\n    for c, lm in zip(li, lastmodified):\n        ans.append(c if lm>islower else c.lower())\nelse:\n    for c, lm in zip(li, lastmodified):\n        ans.append(c if lm>islower else c.lower())\nprint(''.join(ans))",
        "length": 31,
        "loc": 30
    },
    "abc314_g_47095184": {
        "buggy": "from bisect import *\nimport sys\ninput=sys.stdin.readline\n#####segfunc#####\ndef segfunc(x, y):\n    return x+y\t\t\t\t\t#\u533a\u9593\u30af\u30a8\u30ea\u3067\u306efunc\u3092\u8a2d\u5b9a\n#################\n \n#####ide_ele#####\nide_ele =0\t\t\t\t\t#\u30af\u30a8\u30ea\u306e\u5358\u4f4d\u5143\u3092\u8a2d\u5b9a\n#################\n \nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n \n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n \n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n \n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\ndef main():\n  def mgr_bisect(ng,ok):\t\t\t\t#\u3053\u3053\u306e\u90e8\u5206(mgr_bisect)\u306f\u6539\u5909\u3057\u306a\u3044\n    while (abs(ok-ng)>1):\n      mid=(ok+ng)//2\n      if is_ok(mid):\n        ok=mid\n      else:\n        ng=mid\n    return ok\n  N,M,H=map(int,input().split())\n  attacks=[]\n  compnum=set()\n  compnum.add(0)\n  damages=[0]*M\n  attackinsts=[]\n  for i in range(N):\n    a,b=map(int,input().split())\n    b-=1\n    damages[b]+=a\n    compnum.add(damages[b])\n    attackinsts.append((a,b))\n  compnum=list(compnum)\n  compnum.sort()\n  #print(compnum)\n  num_to_ind={}\n  ind_to_num={}\n  for i,v in enumerate(compnum):\n    num_to_ind[v]=i\n    ind_to_num[i]=v\n  n=len(compnum)\n  cnts=[0]*n\n  cnts[0]=M\n  sums=[0]*n\n  cursuml=[0]*M\n  cntseg=SegTree(cnts,segfunc,ide_ele)\n  sumseg=SegTree(sums,segfunc,ide_ele)\n  allsum=0\n  needamulets=[0]*N\n  for i in range(N):\n    a,b=attackinsts[i]\n    cursum=cursuml[b]\n    allsum-=cursum\n    nxtsum=cursum+a\n    allsum+=nxtsum\n    cursuml[b]+=a\n    curind=num_to_ind[cursum]\n    nxtind=num_to_ind[nxtsum]\n    #print(curind,nxtind)\n    curcnt=cntseg.query(curind,curind+1)\n    nxtcnt=cntseg.query(nxtind,nxtind+1)\n    #print(curcnt,nxtcnt)\n    cntseg.update(curind,curcnt-1)\n    cntseg.update(nxtind,nxtcnt+1)\n    \n    cursums=sumseg.query(curind,curind+1)\n    nxtsums=sumseg.query(nxtind,nxtind+1)\n    sumseg.update(curind,cursums-cursum)\n    sumseg.update(nxtind,nxtsums+nxtsum)\n    if allsum<H:continue\n    if allsum==H:\n      needamulets[i]=1\n      continue\n    #\u751f\u304d\u6b8b\u308b\u305f\u3081\u3001\u9664\u304f\u5fc5\u8981\u304c\u3042\u308b\u6700\u5c0f\u30c0\u30e1\u30fc\u30b8\n    dif=allsum-H\n    def is_ok(arg):\n      return sumseg.query(arg,n)>dif\n    ind=mgr_bisect(n,-1)\n    thre_num=ind_to_num[ind]\n    cusum=sumseg.query(ind,n)\n    #print([cntseg.query(i,i+1) for i in range(n)])\n    #print([sumseg.query(i,i+1) for i in range(n)])\n    needamulets[i]=cntseg.query(ind,n)-((cusum-dif)//thre_num)\n    \n  #print(needamulets)\n  ans=[-1]*(M+1)\n  for i in range(M+1):\n    ans[i]=bisect(needamulets,i)\n  print(*ans)\nmain()",
        "length": 150,
        "loc": 143
    },
    "abc315_a_46219249": {
        "buggy": "import re\n\nre.sub(\"a|e|i|o|u\", \"\", input())",
        "length": 3,
        "loc": 3
    },
    "abc315_b_46054320": {
        "buggy": "M = int(input())\nD = list(map(int, input().split()))\n\nmiddleD = (sum(D)+1)/2\nsumD = 0\nfor i in range(M):\n  sumD += D[i]\n  if sumD >= middleD:\n    print(i+1, middleD - sumD + D[i])\n    break",
        "length": 10,
        "loc": 4
    },
    "abc315_c_46161967": {
        "buggy": "a=int(input())\nx=0\ny=0\nlot=[]\ndeli=[]\nfor i in range(a):\n    x,y=map(int,input().split())\n    lot.append(x)\n    deli.append(y)\nx=lot[deli.index(max(deli))]\ny=deli.index(max(deli))\nmaxx=max(deli)\nlot.pop(y)\ndeli.pop(y)\nnum=[]\nfor i in range(len(deli)):\n    if lot[i]==x:\n        num.append(deli[i]/2)\n    else:\n        num.append(deli[i])\nprint(maxx+max(num))",
        "length": 21,
        "loc": 21
    },
    "abc315_f_46136201": {
        "buggy": "N = int(input())\nXY = [[int(i) for i in input().split()] for _ in range(N)]\n\nINF = 10**13\nmaC = 30\ndp = [INF]*((N)*(maC+1))\ndef pos2ind(n,c):\n    return n*(maC+1) + c\n\ndp[0] = 0\nfor i in range(1, N):\n    x,y = XY[i]\n    for j in range(maC+1):\n        if j>i-1:\n            break\n        for k in range(1, j+2):\n            # print(f'{i,j,k = }')\n            # print(f'{i-k = }')\n            xx, yy = XY[i-k]\n            dist2 = (x-xx)**2 + (y-yy)**2\n            dist = dist2**.5\n            # print(f'{dist2 = }')\n            # print(f'{dp[pos2ind(i,j)] = }')\n            # print(f'{dp[pos2ind(i-k,j-(k-1))]+dist2 = }')\n            dp[pos2ind(i,j)] = min(dp[pos2ind(i,j)], dp[pos2ind(i-k,j-(k-1))]+dist)\nans = INF\nfor j in range(maC+1):\n    # print(f'{j, dp[pos2ind(N-1,j)] = }')\n    ans = min(ans, dp[pos2ind(N-1,j)] + 2**(j-1))\nprint(ans)",
        "length": 30,
        "loc": 29
    },
    "abc317_a_54907933": {
        "buggy": "N, H, X = map(int, list(input().split()))\nP = list(map(int, input().split()))\n\nmin_num = 999999\nresult = 0\nfor i in range(N):\n    if H + P[i] > X:\n        if min_num > H + P[i]:\n            min_num = H + P[i]\n            result = i + 1\n\nprint(result)\n",
        "length": 12,
        "loc": 7
    },
    "abc317_c_54776081": {
        "buggy": "from itertools import permutations\nn, m = map(int, input().split())\ngraph = [[0]*(n+1) for i in range(n+1)]\n\nfor i in range(m):\n  a,b,c = map(int, input().split())\n  graph[a][b] = c\n  graph[b][a] = c\n\n# for i in range(1,n+1):\n#   print(*graph[i])\n\nP = permutations(range(1,n+1))\nans = 0\nfor p in P:\n  s = 0\n  for j in range(n):\n    c = graph[p[j-1]][p[j]]\n    if c == 0:\n      break\n    s += c\n  # print(p, s)\n  ans = max(ans, s)\nprint(ans)",
        "length": 24,
        "loc": 17
    },
    "abc317_d_52641231": {
        "buggy": "N = int(input())\nXYZ = [[int(x) for x in input().split()] for _ in range(N)]\nlst = []\ntotal = 0\nfor x, y, z in XYZ:\n    lst.append((max((y-x)//2+1, 0), z))\n    total += z\n# dp[i][j]: i\u500b\u76ee\u307e\u3067\u306e\u9078\u6319\u533a\u3092\u898b\u3066\u3001j\u8b70\u5e2d\u3092\u7372\u5f97\u3059\u308b\u3068\u304d\u306b\u5fc5\u8981\u306a\u6700\u5c0f\u30b3\u30b9\u30c8\ndp = [[10**10]*(total+1) for _ in range(N+1)]\ndp[0][0] = 0\nfor i, (c, w) in enumerate(lst):\n    for j in range(total+1):\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n        if j+w <= total:\n            dp[i+1][j+w] = min(dp[i+1][j+w], dp[i][j]+c)\nprint(min(dp[N][total//2+1:]))\n",
        "length": 16,
        "loc": 9
    },
    "abc317_e_51930031": {
        "buggy": "H, W = map(int, input().split())\nS = [list(input()) for _ in range(H)]\nfor h in range(H):\n  for w in range(W):\n    if S[h][w] == \"S\":\n      sh, sw = h, w\n    elif S[h][w] == \"G\":\n      gh, gw = h, w\n\nfor h in range(H):\n  w = 0\n  flg = False\n  while w < W:\n    if S[h][w] not in (\"*\", \".\"):\n      flg = False\n    \n    if S[h][w] == \">\":\n      flg = True\n    elif flg:\n      S[h][w] = \"*\"\n    w += 1\n  w = W - 1\n  flg = False\n  while w >= 0:\n    if S[h][w] not in (\"*\", \".\"):\n      flg = False\n    \n    if S[h][w] == \"<\":\n      flg = True\n    elif flg:\n      S[h][w] = \"*\"\n    w -= 1\n\n\nfor w in range(W):\n  h = 0\n  flg = False\n  while h < H:\n    if S[h][w] not in (\"*\", \".\"):\n      flg = False\n    \n    if S[h][w] == \"v\":\n      flg = True\n    elif flg:\n      S[h][w] = \"*\"\n    h += 1\n  h = 0\n  flg = False\n  while h >= 0:\n    if S[h][w] not in (\"*\", \".\"):\n      flg = False\n    \n    if S[h][w] == \"^\":\n      flg = True\n    elif flg:\n      S[h][w] = \"*\"\n    h -= 1\n\ndef can_move(h, w):\n  return 0 <= h < H and 0 <= w < W and S[h][w] in (\"S\", \"G\", \".\")\n\ndh = (0, 1, 0, -1)\ndw = (1, 0, -1, 0)\n\nfrom collections import deque\nque = deque()\nque.append((sh, sw))\ndist = [[-1] * W for _ in range(H)]\ndist[sh][sw] = 0\nwhile que:\n  fh, fw = que.popleft()\n  for i in range(4):\n    th = fh + dh[i]\n    tw = fw + dw[i]\n    if can_move(th, tw) and dist[th][tw] == -1:\n      dist[th][tw] = dist[fh][fw] + 1\n      que.append((th, tw))\nprint(dist[gh][gw])",
        "length": 78,
        "loc": 47
    },
    "abc317_f_46240679": {
        "buggy": "from math import gcd\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nMOD = 998244353\nDDD = 64\n#DDD = 10\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\nN, A1, A2, A3 = map(int, input().split())\n\nbinNs = bin(N)[2:].zfill(DDD)[::-1]\n#print('# binNs:', binNs)\n\ndp = [[[[[[0]*(A3) for m in range(A2)] for l in range(A1)] for k in range(3)] for j in range(3)] for i in range(3)]\ndp[0][0][0][0][0][0] = 1\ncoef = 1\nfor d in range(DDD):\n    Nd = int(binNs[d])\n#    print('\\n##### d:', d, '/ Nd:', Nd)\n#    for i in range(3):\n#        for j in range(3):\n#            for k in range(3):\n#                print('# (i, j, k):', (i, j, k), '/ dp[i][j][k]:', dp[i][j][k])\n    dp2 = [[[[[[0]*(A3) for m in range(A2)] for l in range(A1)] for k in range(3)] for j in range(3)] for i in range(3)]\n    for st1 in range(3):\n        for st2 in range(3):\n            for st3 in range(3):\n                for r1 in range(A1):\n                    for r2 in range(A2):\n                        for r3 in range(A3):\n                            dpNow = dp[st1][st2][st3][r1][r2][r3]\n                            if dpNow == 0:\n                                continue\n                            for x1 in range(2):\n                                nst1 = st1\n                                if x1 > Nd:\n                                    nst1 = 1\n                                elif x1 < Nd:\n                                    nst1 = -1\n                                nr1 = (r1 + x1*coef) % A1\n                                for x2 in range(2):\n                                    nst2 = st2\n                                    if x2 > Nd:\n                                        nst2 = 1\n                                    elif x2 < Nd:\n                                        nst2 = -1\n                                    nr2 = (r2 + x2*coef) % A2\n                                    x3 = x1^x2\n                                    nst3 = st3\n                                    if x3 > Nd:\n                                        nst3 = 1\n                                    elif x3 < Nd:\n                                        nst3 = -1\n                                    nr3 = (r3 + x3*coef) % A3\n                                    dp2[nst1][nst2][nst3][nr1][nr2][nr3] += dpNow\n                                    dp2[nst1][nst2][nst3][nr1][nr2][nr3] %= MOD\n    dp = dp2\n    coef <<= 1\n    coef %= MOD\n\nans = 0\nfor st1 in [-1, 0]:\n    for st2 in [-1, 0]:\n        for st3 in [-1, 0]:\n            ans += dp[st1][st2][st3][0][0][0]\n            ans %= MOD\n#print('# ans:', ans)\n\nL = lcm(A1, A2)\nans -= N//L\nL = lcm(A1, A3)\nans -= N//L\nL = lcm(A2, A3)\nans -= N//L\nans -= 1\nans %= MOD\n\nprint(ans)\n",
        "length": 82,
        "loc": 63
    },
    "abc318_a_45733281": {
        "buggy": "N, M, P = map(int, input().split())\n\nans = 0\nif N > M:\n    ans += 1 + int((N - M) / P)\nprint(ans)",
        "length": 6,
        "loc": 4
    },
    "abc318_b_54678489": {
        "buggy": "n=int(input())\nf=[[0]*101 for i in range(101)]\n\nfor i in range(n):\n\ta,b,c,d=map(int,input().split())\n\tfor x in range(a,b):\n\t\tfor y in range(c,d):\n\t\t\t# print(x,y)\n\t\t\tf[x][y]=1\nans=0\nfor i in range(10):\n\tans+=sum(f[i])\nprint(ans)",
        "length": 13,
        "loc": 11
    },
    "abc318_c_45939362": {
        "buggy": "n,d,p=map(int,input().split())\nf=list(map(int,input().split()))\nf.sort(reverse=True)\ni=0\nans=0\nwhile d*i<n:\n    ans+=min(p,sum(f[d*i:d*(i+1)+1]))\n    i+=1\nprint(ans)",
        "length": 9,
        "loc": 7
    },
    "abc318_e_45983420": {
        "buggy": "N=int(input())\nA = list(map(int, input().split()))\n\nl = [[] for i in range(3*10**5+1)]\n\nfor i,j in enumerate(A):\n    l[j].append(i)\n#print(l[1])\nans=0\nfor i in range(1,300001):\n\n    now = l[i]\n    cnt = 0\n    M = len(now)-1\n    for j in range(len(now)-1):\n        space = now[j+1]-now[j]-1\n        cnt += M-j\n        ans += cnt * space\n        cnt-=1\nprint(ans)",
        "length": 20,
        "loc": 19
    },
    "abc319_a_45796003": {
        "buggy": "s=str(input())\nif s==\"tourist\":\n    print(3858)\nif s==\"ksun48\":\n    print(3679)\nif s==\"Beng\":\n    print(3658)\nif s==\"Um_nik\":\n    print(3648)\nif s==\"apiad\":\n    print(3638)\nif s==\"Stonefeang\":\n    print(3630)\nif s==\"ecnerwala\":\n    print(3613)\nif s==\"mnbvmar\":\n    print(3555)\nif s==\"newbiedmy\":\n    print(3516)\nif s==\"semiexp\":\n    print(3481)",
        "length": 21,
        "loc": 6
    },
    "abc319_b_45999150": {
        "buggy": "N = int(input())\n\ndef judge_num(num):\n  for j in range(1,11):\n    if N % j == 0:\n      if num % (N / j) == 0:\n        return str(j)\n        break\n  return \"-\"\n\nans = str()\nfor i in range(0, N+1):\n  ans = ans + judge_num(i)\nprint(ans)",
        "length": 14,
        "loc": 4
    },
    "abc319_c_45783074": {
        "buggy": "import itertools\nimport math\n\nm = []\nfor i in range(3):\n    x, y,z  = map(int, input().split())\n    m.append(x)\n    m.append(y)\n    m.append(z)\n\nprint(m)\n\ncklist = [[[2,3],[4,7],[5,9]] \\\n         ,[[1,3],[5,8]]  \\\n         ,[[1,2],[6,9],[5,7]]  \\\n         ,[[1,7],[5,6]]  \\\n         ,[[2,8],[4,6],[1,9],[3,7]]   \\\n         ,[[3,9],[4,5]]  \\\n         ,[[1,4],[3,5],[8,9]]  \\\n         ,[[2,5],[7,9]]  \\\n         ,[[1,5],[3,6],[7,8]]]\n\nlp = [0,1,2,3,4,5,6,7,8]\n\ndef gakkari(c,v,w):\n    for i in cklist[c]:\n        s = 10* w[i[0]-1] + w[i[1]-1]\n        #print(s,c,v,i,w)\n        if s == v or s == 10*v :\n            return True\n    return False\n    \nkei =math.factorial(9)\ncnt = 0\nfor s in itertools.permutations(lp, 9 ):\n    l = list(s)\n    w = [0 for _ in range(9)]\n    for i in l:\n        w[i] = m[i]\n        ## gakkari chk\n        if gakkari(i,m[i],w) :\n            break\n        \n    else:\n        cnt += 1\n\n\n#print(w)\n#print(cklist)\n\n\nprint(cnt/kei )\n\n",
        "length": 53,
        "loc": 11
    },
    "abc319_d_45944386": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nL = list(map(int, input().split()))\n\nng, ok = max(L) - 1, sum(L) + n - 1\nwhile ok - ng > 1:\n    mid = (ok + ng) // 2\n    res = 1\n    temp = 0\n    for i in range(n):\n        temp += L[i]\n        if temp > mid:\n            res += 1\n            temp = L[i]\n        else:\n            temp += 1\n    if res <= m:\n        ok = mid\n    else:\n        ng = mid\nprint(ok)\n",
        "length": 23,
        "loc": 16
    },
    "abc319_f_45777946": {
        "buggy": "ir = lambda: int(input()) # \u6570\u5b57\u306e\u8aad\u307f\u8fbc\u307f\nlr = lambda: list(map(int, input().split())) # \u6570\u5b57\u306e\u914d\u5217\u306e\u8aad\u307f\u8fbc\u307f\n\nimport heapq\n\nN = ir()\nP = [[] for _ in range(N)]\nS = [0]\nG = [0]\npotionidx = []\n\nfor i in range(1, N):\n    p, t, s, g = lr()\n    # \u6728\u306f\u89aa\u304b\u3089\u5b50\u306e\u65b9\u5411\u3060\u3051\u6301\u3064\n    P[p-1].append(i)\n    S.append(s)\n    G.append(g)\n    if t == 2:\n        # \u6575\u306e\u5f37\u3055\u3092\u6301\u3064\u5fc5\u8981\u304c\u306a\u3044\u306e\u3067\u8ca0\u6570\u3067\u85ac\u3067\u3042\u308b\u3053\u3068\u3092\u8868\u73fe\n        # \u3069\u306e\u85ac\u3092\u4f7f\u3063\u305f\u304b\u3092bit\u3067\u8868\u73fe\u3059\u308b\u305f\u3081index\u3092\u4fdd\u5b58\n        S[-1] = ~len(potionidx)\n        potionidx.append(i)\n\ndef go(q, potionbit, power):\n    # \u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u304c\u5b58\u5728\u3059\u308b\u9650\u308a\u56de\u308b\n    while len(q) > 0 and q[0][0] <= power:\n        _, vertex = heapq.heappop(q)\n        power += G[vertex]\n        # \u6575\u306e\u5f37\u3055\u306f10**9\u304c\u4e0a\u9650\n        power = min(power, 10**9)\n        for v in P[vertex]:\n            if S[v] > 0:\n                heapq.heappush(q, (S[v], v))\n            else:\n                # \u85ac\u304c\u3042\u308b\u5834\u6240\u306b\u5230\u9054\u3057\u305f\u3053\u3068\u3092bit\u3067\u8868\u73fe\n                potionbit |= 1 << ~S[v]\n    return (q, potionbit, power)\n\npotionnum = len(potionidx)\n# \u85ac\u306e\u6570\u3060\u3051bit\u5168\u63a2\u7d22\ndp = [(0, 0, 0)] * (1<<potionnum)\n# \u85ac\u3092\u4f7f\u308f\u305a\u306b\u56de\u3063\u305f\u72b6\u614b\u304c\u521d\u671f\u5024\n# [(strength, vertex)], potionbit, power\ndp[0] = go([(0, 0)], 0, 1)\n\nfor i in range(1<<potionnum):\n    for k in range(potionnum):\n        # k\u756a\u76ee\u306e\u85ac\u3092\u307e\u3060\u4f7f\u3063\u3066\u3044\u306a\u3044\u4e14\u3064\u305d\u306e\u85ac\u306b\u5230\u9054\u53ef\u80fd\n        if not i & (1<<k) and dp[i][1] & (1<<k):\n            q, potionbit, power = dp[i]\n            potion = G[potionidx[k]]\n            power *= potion\n            power = min(power, 10**9)\n            # k\u756a\u76ee\u306e\u85ac\u3092\u5f37\u30550\u306e\u6575\u3068\u3057\u3066\u6700\u521d\u306b\u53d6\u5f97\u3059\u308b\u3088\u3046\u306b\u3057\u3066\u5e33\u5c3b\u3092\u5408\u308f\u305b\u308b\n            power -= potion\n            # k\u756a\u76ee\u306e\u85ac\u304c\u3042\u308b\u9802\u70b9\u304b\u3089\u79fb\u52d5\u3057\u59cb\u3081\u308b\n            heapq.heappush(q, (0, potionidx[k]))\n            state = go(q, potionbit, power)\n            # k\u756a\u76ee\u306e\u85ac\u3092\u4f7f\u3063\u305f\u5f8c\u306epower\u304c\u5927\u304d\u3051\u308c\u3070\u66f4\u65b0\n            if state[2] > dp[i|(1<<k)][2]:\n                dp[i|(1<<k)] = state\n\n# \u6575\u3092\u5012\u3057\u3066\u4e0a\u6607\u3059\u308b\u5f37\u3055\u306f1\u4ee5\u4e0a\u306a\u306e\u3067\u6700\u7d42\u7684\u306a\u5f37\u3055\u306f\u6700\u5927\u306e\u6575\u306e\u5f37\u3055\u3088\u308a1\u4ee5\u4e0a\u5927\u304d\u304f\u306a\u308b\nprint(\"Yes\" if dp[-1][2] > max(S) else \"No\")\n",
        "length": 64,
        "loc": 8
    },
    "abc320_a_55169721": {
        "buggy": "A, B = input().split()\nA, B = int(A), int(B)\nres = A^B + B^A\nprint(res)",
        "length": 4,
        "loc": 3
    },
    "abc320_b_54243171": {
        "buggy": "s = list(input())\nmax = 0\nfor i in range(len(s)):\n    for j in range(i+1,len(s)):\n        x = s[i:j]\n        x.reverse()\n        if s[i:j]==x and max<j-i:\n            max = j-i\nprint(\"{}\".format(max))\n",
        "length": 9,
        "loc": 4
    },
    "abc320_c_55010802": {
        "buggy": "import sys\nsys.setrecursionlimit(10**6)\n# sys.set_int_max_str_digits(10**6)\n\n# mod = 998244353\n# ds = [(-1,0),(0,1),(1,0),(0,-1)]\n# inf = float('inf')\n# ni,nj=i+di,j+dj\n# 0<=ni<H and 0<=nj<W\n# alph = 'abcdefghijklmnopqrstuvwxyz'\ndef rint(offset=0,base=10): return list(map(lambda x: int(x, base)+offset, input().split())) \ndef full(s, f=int, *args): return [full(s[1:], f) if len(s) > 1 else f(*args) for _ in range(s[0])]\ndef shift(*args,offset=-1): return (a+offset for a in args)\n\nM, = rint()\n# S = []\nS = [list(map(int, list(input()))) for _ in range(3)]\n# S = input()\nfrom collections import deque\nimport heapq\n\ninf = float(\"inf\")\n\ndef next_chance(i,t,d):\n    for dt in range(M):\n        if S[i][(t+dt)%M] == d:\n            return dt\n    return inf\n\ndef options(t,d, vis):\n    best = inf\n    best_i = []\n    for i in range(3):\n        if not vis[i]:\n            score = next_chance(i,t,d)\n            if score < best:\n                best_i = [i]\n                best = score\n            elif score == best:\n                best_i.append(i)\n    return best, best_i\n\n\nans = inf\nfor d in range(10):\n    vis = [False]*3\n\n    def dfs(t,d):\n        if all(vis):\n            return -1\n        dt, opts = options(t,d,vis)\n        if dt == inf:\n            return inf\n        cost = inf\n        for s in opts:\n            if not vis[s]:\n                vis[s] = True\n                cost = min(cost, dfs(t+dt+1,d))+1\n                vis[s] = False\n        return dt+cost\n    \n    ans = min(ans, dfs(0,d))\n\nprint(ans if ans != inf else -1)\n\n\n\n\n# ans = False\n# print(\"Yes\" if ans else \"No\")",
        "length": 70,
        "loc": 58
    },
    "abc320_d_54919763": {
        "buggy": "\"\"\"\n3 2\n1 2 2 1\n1 3 -1 -2\n\"\"\"\nN,M=map(int,input().split())\nG=[[]for i in range(N+1)]\nfor i in range(M):\n    a,b,x,y=map(int,input().split())\n    G[a].append([b,x,y])\n    G[b].append([a,x,y])\n\nvisited=[False]*(N+1)\nvisited[1]=True\nlistx=[[0]*2 for i in range(N+1)]\nset1={1}\nwhile len(set1)>0:\n    set2=set()\n    for i in set1:\n        for num,x,y in G[i]:\n            if visited[num]==False:\n                set2.add(num)\n                visited[num]=True\n                listx[num][0]=listx[i][0]+x\n                listx[num][1]=listx[i][1]+y\n    set1=set2.copy()\n\nfor i in range(1,N+1):\n    if visited[i]==False:\n        print(\"undecidable\")\n    else:\n        print(listx[i][0],listx[i][1])\n            ",
        "length": 33,
        "loc": 11
    },
    "abc320_f_46034926": {
        "buggy": "import sys\ninput=sys.stdin.readline\n\nN,H = map(int,input().split())\nX = list(map(int,input().split()))\nX = [0] + X\nP = [0 for i in range(N+1)]\nF = [0 for i in range(N+1)]\nfor i in range(1,N):\n  P[i],F[i] = map(int,input().split())\n\ninf = 10**8\ndp = [[[inf for i in range(H+1)] for i in range(H+1)] for i in range(N+1)]\nfor i in range(H+1):\n  dp[0][H][i] = 0\n\nfor n in range(N-1):\n  d = X[n+1] - X[n]\n  for h in range(d,H+1):\n    for hh in range(H-d+1):\n      if dp[n][h][hh] == inf:\n        continue\n      #\u4f7f\u308f\u306a\u3044\n      dp[n+1][h-d][hh+d] = min(dp[n+1][h-d][hh+d],dp[n][h][hh])\n      #\u5f80\u8def\u3067\u4f7f\u3046\n      hhh = min(H,h-d+F[n+1])\n      dp[n+1][hhh][hh+d] = min(dp[n+1][hhh][hh+d],dp[n][h][hh] + P[n+1])\n      #\u5fa9\u8def\u3067\u4f7f\u3046\n      hhh = hh + d\n      if hhh == H:\n        for k in range(hhh-F[n+1],hhh+1):\n          dp[n+1][h-d][k] = min(dp[n+1][hhh][k],dp[n][h][hh] + P[n+1])\n      elif hhh >= F[n+1]:\n        dp[n+1][h-d][hhh-F[n+1]] = min(dp[n+1][h-d][hhh-F[n+1]],dp[n][h][hh] + P[n+1])\n      \nd = X[N] - X[N-1]\nans = inf\nfor h in range(d,H-d+1):\n  ans = min(ans,dp[N-1][h+d][h-d])\nif ans == inf:\n  ans = -1\nprint(ans)",
        "length": 42,
        "loc": 32
    },
    "abc321_a_54713012": {
        "buggy": "n = input()\n\nfor i in range(len(n)-1):\n    if int(n[i]) < int(n[i+1]):\n        print(\"No\")\n        break\n    \nelse:\n     print(\"Yes\")    \n",
        "length": 9,
        "loc": 4
    },
    "abc321_b_54748415": {
        "buggy": "n,x = map(int, input().split())\nalist = list(map(int, input().split()))\ns = sum(alist)\nmx = max(alist)\nmn = min(alist)\nfor i in range(100):\n    if s + i - min(mn, i) - max(mx, i) >= x:\n        print(i)\n        exit()\nprint(-1)",
        "length": 10,
        "loc": 6
    },
    "abc321_d_54470617": {
        "buggy": "N, M, P = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nB.sort()\nS = [B[0]]\nfor j in range(1, M) : S.append(B[j] + S[j - 1])\n\nres = 0\nfor i in range(N) :\n  l, r = -1, M\n  while l + 1 < r :\n    m = (l + r) // 2\n    if A[i] + B[m] <= P : l = m\n    else : r = m\n  res += (S[l] + A[i] if l >= 0 else 0) + P * (M - r)\nprint(res)",
        "length": 16,
        "loc": 15
    },
    "abc321_e_54658079": {
        "buggy": "def solve():\n    n,x,k = list(map(int, input().split(' ')))\n    # print(n,x,k)\n    n += 1\n    k = min(100,k)\n    ans = 0\n    depth = k\n    prev = -1\n    while x and depth >= 0:\n        # print(f'{x=} {depth=} {prev=}')\n        if prev == -1:\n            L = x*(1<<depth)\n            R = L + (1<<depth)\n        else:\n            if depth == 0:\n                L = x\n                R = x+1\n            else:\n                another_way = prev^1\n                # print(f'{another_way=}')\n                L = another_way*(1<<(depth-1))\n                R = L + (1<<(depth-1))\n        # print(L,R)\n        intersection = max(0,min(R,n)-max(0,L))\n        # print(f'{intersection=}')\n        ans += intersection\n        prev = x\n        x //= 2\n        depth -= 1\n    # print(f'{ans=}')\n    return ans\n\nt = int(input())\n\nfor _ in range(t):\n    print(solve())",
        "length": 36,
        "loc": 5
    },
    "abc321_f_50281141": {
        "buggy": "q, k = map(int, input().split())\nmod = 998244353\ndp = [0] * (k + 1)\ndp[0] = 1\nfor i in range(q):\n  t, x = map(str, input().split())\n  x = int(x)\n  if t == \"+\":\n    for j in reversed(range(k+1-x)):\n      dp[j+x] += dp[j]\n  else:\n    for j in range(k+1-x):\n      dp[j+x] -= dp[j]\n  print(dp[k])\n  # print(dp)",
        "length": 15,
        "loc": 11
    },
    "abc322_a_46209873": {
        "buggy": "input()\nidx = input().find('ABC')\nprint(idx + 1 if idx > 0 else idx)",
        "length": 3,
        "loc": 3
    },
    "abc322_b_46209097": {
        "buggy": "n,m=map(int,input().split())\ns=input()\nt=input()\nk=3\nif t[0:n]==s:\n  k-=2\nelif t[-n::]==s:\n  k-=1\nprint(k)",
        "length": 9,
        "loc": 7
    },
    "abc322_c_46201794": {
        "buggy": "N, M = map(int, input().split())\nans = [N] * N\n\nfor i in map(int, input().split()):\n    ans[i-1] = 0\nfor i in range(N-2, 0, -1):\n    ans[i-1] = min(ans[i-1], ans[i]+1)\n\nprint('\\n'.join(map(str, ans)))\n",
        "length": 9,
        "loc": 6
    },
    "abc322_d_46190250": {
        "buggy": "import itertools\nimport sys\n\nP = []\nfor i in range(3):\n    p = []\n    for j in range(4):\n        p.append(list(map(lambda x: int(x == '#'), input())))\n    P.append(p)\n\ncnt = 0\nfor p in P:\n    cnt += sum(itertools.chain.from_iterable(p))\nif cnt != 16:\n    print('No')\n    sys.exit()\n\n\ndef rotate(piece: list, n):\n    if n == 0:\n        return piece\n    if n == 1:\n        return list(map(list, zip(*piece[::-1])))\n    if n == 2:\n        return list(reversed([p[::-1] for p in piece]))\n    if n == 3:\n        return list(map(list, zip(*piece)))[::-1]\n\n\nR = []\nfor p in P:\n    R.append([rotate(p, i) for i in range(4)])\n\n\ndef slide(p, n):\n    rotated = R[p][n // 49]\n    row = (n % 49) // 7 - 3\n    col = (n % 49) % 7 - 3\n    result = [[0] * 4 for _ in range(4)]\n\n    for i, r in enumerate(rotated):\n        for j, e in enumerate(r):\n            if 0 <= i + row <= 3 and 0 <= j + col <= 3:\n                result[i + row][j + col] = e\n            elif e:\n                return None\n    return result\n\n\ndef can_merge(p1, p2, p3):\n    for i in range(4):\n        for j in range(4):\n            if p1[i][j] + p2[i][j] + p3[i][j] != 1:\n                return False\n    return True\n\n\nfor i in range(196):\n    p1 = slide(0, i)\n    if p1 is None:\n        continue\n    for j in range(196):\n        p2 = slide(1, j)\n        if p2 is None:\n            continue\n        for k in range(196):\n            p3 = slide(2, k)\n            if p3 is None:\n                continue\n            if can_merge(p1, p2, p3):\n                # print('Yes')\n                # print(*p1, sep='\\n')\n                # print()\n                # print(*p2, sep='\\n')\n                # print()\n                # print(*p3, sep='\\n')\n                sys.exit()\nprint('No')\n",
        "length": 78,
        "loc": 71
    },
    "abc322_e_53314219": {
        "buggy": "from itertools import product\n\nN,K,P=map(int,input().split())\ndp=[10**18]*(P+1)**K\ndp[0]=0\n\nfor i in range(N):\n    I=list(map(int,input().split()))\n    for p in product(reversed(range(P+1)),repeat=K):\n        pn=[0]*K\n        for j in range(K):\n            pn[j]=min(P,p[j]+I[j+1])\n        pi=0\n        for pp in p:\n            pi*=(P+1)\n            pi+=pp\n        pni=0\n        for pp in pn:\n            pni*=(P+1)\n            pni+=pp\n        dp[pni]=min(dp[pni],dp[pi]+I[0])\nprint(dp[-1] if dp[-1]<10**10 else -1)",
        "length": 22,
        "loc": 22
    },
    "abc323_a_54490439": {
        "buggy": "s = input()\nans = \"Yes\"\nfor i in range(3,16):\n    if i %2 == 1 and s[i] != \"0\":\n        ans = \"No\"\n        break\nprint(ans)",
        "length": 7,
        "loc": 3
    },
    "abc323_b_54226184": {
        "buggy": "n = int(input())\ns = [str(input()) for _ in range(n)]\n\ndic = {}\n\nfor i in range(n):\n  dic[i] = 0\n\nfor i in range(n):\n  for k in range(n):\n    if i > k and s[i][k] == \"o\":\n      dic[i] += 1\n      \ndic = sorted(dic.items(), key=lambda x:x[1], reverse=True)\n\nfor i in dic:\n  print(i[0]+1, end=\" \")\n",
        "length": 17,
        "loc": 13
    },
    "abc323_f_50628101": {
        "buggy": "# +-----------+--------------------------------------------------------------+\n# |   main    |                                                              |\n# +-----------+--------------------------------------------------------------+\ndef main():\n    XA, YA, XB, YB, XC, YC = map(int, input().split())\n    XB -= XA\n    XC -= XA\n    XA = 0\n    YB -= YA\n    YC -= YA\n    YA = 0\n    if XC < XB:\n        XC *= -1\n        XB *= -1\n    if YC < YB:\n        YC *= -1\n        YB *= -1\n    \n    __print(XB, YB, XC, YC, XB < XC, YB < YC)\n    ans = abs(XC - XB) + abs(YC - YB) + abs(XB - XA) + abs(YB - YA) - 1\n    if XB < 0:\n        if XB < XC:\n            ans += 2\n        if YB == 0:\n            ans += 2\n        elif YB < 0 and YB < YC:\n            ans += 2\n    elif XB == XA:\n        if YB < 0 and YB < YC:\n            ans += 4\n        elif XB < XC:\n            ans += 2\n    else:\n        # \u3053\u3053\u306b\u554f\u984c\u304c\u3042\u308b\n        if YB == YC:\n            pass\n        elif YB < YC:\n            if XB == XC:\n                if YB == 0:\n                    ans += 2\n            else:\n                ans += 2\n    print(ans)\n\n\n\n# +-----------+--------------------------------------------------------------+\n# |  library  | See Also : https://github.com/nodashin6/atcoder              |\n# +-----------+--------------------------------------------------------------+\n\n\n\n\n\n# +-----------+--------------------------------------------------------------+\n# |   other   |                                                              |\n# +-----------+--------------------------------------------------------------+\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n__print = lambda *args, **kwargs: print(*args, **kwargs) if __debug else None\n\n\nif __name__ == '__main__':\n    # for test on local PC\n    try:\n        __file = open('./input.txt')\n        input = lambda: __file.readline().rstrip()\n        __debug = True\n    except:\n        __debug = False\n    main()",
        "length": 71,
        "loc": 39
    },
    "abc324_a_54513764": {
        "buggy": "result=\"Yse\"\nN=int(input())\nlis=list(map(int,input().split(' ')))\n\nfor i in range(len(lis)-1):\n    if lis[i]!=lis[i+1]:\n        result=\"No\"\n\nprint(result)",
        "length": 9,
        "loc": 1
    },
    "abc324_d_53028745": {
        "buggy": "import sys\ndef main():\n    input = sys.stdin.readline\n    n = int(input())\n    s = sorted(input()[:-1])\n    max_val = int(\"\".join(s[::-1]))\n    s = list(map(int, s))\n    cnt = 0\n    for i in range(1,10**8+1):\n        if i*i > max_val:\n            break\n        lst = list(map(int, str(i*i)))\n        if len(lst) < n:\n            lst += [0] * (n - len(lst))\n        if sorted(lst) == s:\n            cnt += 1\n    print(cnt)        \nmain()\n",
        "length": 18,
        "loc": 9
    },
    "abc324_e_52742757": {
        "buggy": "import bisect\n\nN,T = input().split()\nN = int(N)\nk = len(T)\nleft = []\nright = []\nfor i in range(N):\n    s = input()\n    c = 0\n    for j in s:\n        if j == T[c]: c += 1\n        if c == k: break\n    left.append(c)\n    c = 0\n    for j in s[::-1]:\n        if j == T[k-1-c]: c += 1\n        if c == k: break\n    right.append(c)\nleft.sort()\nright.sort()\nc = 0\nfor j in range(k+1):\n    x = bisect.bisect(left,j)-bisect.bisect_left(left,j)\n    y = N-bisect.bisect_left(right,k-1)\n    c += x*y\nprint(c)",
        "length": 27,
        "loc": 25
    },
    "abc325_a_54471524": {
        "buggy": "S,T=map(str,input().split())\nprint(S+'\u3000'+'san')",
        "length": 2,
        "loc": 2
    },
    "abc325_d_53458224": {
        "buggy": "from heapq import heappush, heappop\n\nn = int(input())\narr = [list(map(int, input().split())) for _ in range(n)]\narr = sorted(arr)\nheap = []\ni, cnt, t = 0, 0, 1\nwhile i < len(arr):\n\tif t < arr[i][0]: t = arr[i][0]\n\twhile i < len(arr) and arr[i][0] <= t:\n\t\theappush(heap, (arr[i][0] + arr[i][1]))\n\t\ti += 1\n\twhile len(heap):\n\t\tx = heappop(heap) \n\t\tif x < t: continue\n\t\tt += 1\n\t\tcnt += 1\n\t\tbreak\nwhile len(heap):\n\tif heappop(heap) >= t:\n\t\tt += 1\n\t\tcnt += 1\nprint(cnt)",
        "length": 23,
        "loc": 9
    },
    "abc325_f_47338119": {
        "buggy": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nLN = 1111111\n\ndef cnt(d):\n    ret = []\n    s,k = 0,0\n    if d%s1[0] == 0: s = d//s1[0]\n    else: s = d//s1[0]+1\n    ssum = s1[0]*s\n    remain = d-ssum\n    ret.append([s,0])\n    while s >= 0:\n        s -= 1\n        remain += s1[0]\n        if remain %s2[0] == 0: k = remain//s2[0]\n        else: k = remain//s2[0]+1\n        ret.append([s,k])\n    return ret\n\nN = int(input())\nD = list(map(int,input().split()))\ns1 = list(map(int,input().split())) #Len,Cost,K\ns2 = list(map(int,input().split()))\nans = 10**24\ndp = [LN]*(s1[2]+1) # idx : num of s1, val : num of s2\nque = cnt(D[0])\nfor a,b in que: \n    if a > s1[2] or b > s2[2]: continue\n    dp[a] = b\nfor i in range(1,N):\n    tmp = [LN]*(s1[2]+1)\n    que = cnt(D[i])\n    for idx,val in enumerate(dp):\n        if val == LN: continue\n        for a,b in que:\n            if idx+a > s1[2] or val+b > s2[2]: continue\n            tmp[idx+a] = min(tmp[idx+a],val+b)\n    dp = tmp\nif dp.count(LN) == s1[2]+1: print(-1)\nelse:\n    for i,j in enumerate(dp): \n        if j == LN: continue\n        ans = min(ans,i*s1[1]+j*s2[1])\n    print(ans)",
        "length": 46,
        "loc": 14
    },
    "abc325_g_46914169": {
        "buggy": "from functools import lru_cache\nfrom math import inf, ceil\n\n\ndef read_ints():\n    return [int(x) for x in input().split(' ')]\n\ndef slv():\n    s=input()\n    K=int(input())\n    n=len(s)\n\n    @lru_cache(None)\n    def dfs(i,j):\n        if j<i:return 0\n        if j==i:return 1\n        res=j-i+1\n        if s[i]=='o':\n            for x in range(i+1,j+1):\n                if s[x]=='f' and dfs(i+1,x-1)==0:\n                    res=min(res,dfs(min(x+K+1,j+1),j))\n        for x in range(i+1,j+1):\n            if s[x]=='o':\n                res=min(res,x-i+dfs(x,j))\n        return res\n\n    print(dfs(0,n-1))\nT = 1\nfor _ in range(T):\n    slv()\n",
        "length": 30,
        "loc": 21
    },
    "abc326_a_54729093": {
        "buggy": "x, y = map(int, input().split())\nprint(\"Yes\" if y - x == 2 or x - y == 3 else \"No\")",
        "length": 2,
        "loc": 2
    },
    "abc326_b_54408960": {
        "buggy": "N = int(input())\n\nfor n in range(N, 920) :\n  s = str(n)\n  a = int(s[0])\n  b = int(s[1])\n  c = int(s[2])\n  if a * b == b * c :\n    print(n)\n    break",
        "length": 10,
        "loc": 8
    },
    "abc326_c_54306688": {
        "buggy": "import bisect\nn,m=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nans=0\nfor i in range(n):\n    ans=max(ans,bisect.bisect_left(a,a[i]+m)-1)\nprint(ans)",
        "length": 8,
        "loc": 7
    },
    "abc326_f_54719711": {
        "buggy": "def enum_sum(a: list[int]) -> dict[int, int]:\n    n = len(a)\n    s = [0] * (1 << n)\n    for i in range(n):\n        for u in range(1 << i):\n            s[u | 1 << i] = s[u] + a[i]\n    return {s[u]: u for u in range(1 << n)}\n\n\ndef solve(a: list[int], X: int) -> list[int] | None:\n    sa = sum(a)\n    sr = sa + X\n    if sr & 1:\n        return None\n    sr >> 1\n    n = len(a)\n    m = n >> 1\n    b1 = enum_sum(a[:m])\n    b2 = enum_sum(a[m:])\n    for s1, u1 in b1.items():\n        s2 = sr - s1\n        u2 = b2.get(s2)\n        if u2 is None:\n            continue\n        res = []\n        for i in range(m):\n            res.append(u1 >> i & 1)\n        for i in range(n - m):\n            res.append(u2 >> i & 1)\n        return res\n    return None\n\n\ndef main():\n    N, X, Y = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    res_y = solve(A[::2], Y)\n    res_x = solve(A[1::2], X)\n    if res_y is None or res_x is None:\n        print(\"No\")\n        return\n    print(\"Yes\")\n\n    A[::2] = res_y\n    A[1::2] = res_x\n    A = [1] + A\n    res = []\n    f = 0\n    for i in range(N):\n        f ^= 1\n        res.append(\"L\" if A[i] ^ A[i + 1] ^ f else \"R\")\n    print(\"\".join(res))\n\n\nmain()\n",
        "length": 56,
        "loc": 15
    },
    "abc327_a_54666524": {
        "buggy": "N = int(input())\nS = input()\nok = [\"a\", \"b\"]\nfor i in range(N-1):\n    if S[i] in ok and S[i+1] in ok:\n        print(\"Yes\")\n        exit()\nprint(\"No\")",
        "length": 8,
        "loc": 5
    },
    "abc327_c_55003503": {
        "buggy": "numbers = []\nnine = set(list(i for i in range(1,10)))\n\ndef check_row(data):\n    for i in data:\n        if nine != set(i):\n            return False\n    return True\n\ndef check_col(data):\n    for i in zip(*data):\n        if nine != set(i):\n            return False\n    return True\n\ndef check_block(data):\n    for i in range(0,9,3):\n        for j in range(0,9,3):\n            num = set()\n            for row in range(3):\n                for col in range(3):\n                    num.add(data[row][col])\n            if nine != num:\n                return False\n    return True\n\nfor i in range(9):\n    a = list(map(int,input().split()))\n    numbers.append(a)\n\nif check_col(numbers) and check_row(numbers) and check_block(numbers):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n",
        "length": 35,
        "loc": 22
    },
    "abc327_e_54952693": {
        "buggy": "import codecs\nimport copy\nimport heapq as hq\nimport itertools\nimport math\nimport pprint as pp\nimport random\nimport statistics\nimport time\nfrom bisect import bisect_left, bisect_right, insort\nfrom collections import Counter\nfrom collections import defaultdict as dd\nfrom collections import deque\nfrom functools import lru_cache, reduce\nfrom sys import setrecursionlimit, stdin\nfrom typing import Generic, Iterable, Iterator, List, TypeVar, Union\n\nN=int(input())\nP=list(map(int,input().split()))\n\ndp=[-float(\"inf\")]*N\ndp[0]=P[0]\n\nfor i in range(1,N):\n    dpnxt=[-float(\"inf\")]*N\n    for j in range(N):\n        if j==0:\n            dpnxt[j]=max(dp[j],dpnxt[i])\n        else:\n            dpnxt[j]=max(dp[j-1]*0.9+P[i],dp[j])\n    dp=dpnxt\n    \n\nnum=1\nans=-float(\"inf\")\nfor i in range(N):\n    myans=dp[i]/num-1200/((i+1)**0.5)\n    \n    ans=max(ans,myans)\n    num*=0.9\n    num+=1\nprint(ans)\n\n",
        "length": 43,
        "loc": 28
    },
    "abc328_a_55136049": {
        "buggy": "N, X = map(int, input().split())\nS = list(map(int, input().split()))\nans = 0\nfor i in range(N):\n  if S[i] <= X:\n    ans += 1\nprint(ans)",
        "length": 7,
        "loc": 6
    },
    "abc328_b_54688793": {
        "buggy": "N = int(input())\nD = list(map(int,input().split()))\nans = 0\nfor x in range(1,N+1):\n  for y in range(1,D[x-1]+1):\n    x = str(x)\n    a = list(x)\n    a = list(map(int,a))\n    y = str(y)\n    b = list(y)\n    b = list(map(int,b))\n    a = set(a)\n    b = set(b)\n    a = list(a)\n    b = list(b)\n    print(a,b)\n    a = list(a)\n    b = list(b)\n    if len(a) == 1 and len(b) == 1 and a == b:\n      ans += 1\nprint(ans)\n  ",
        "length": 22,
        "loc": 16
    },
    "abc328_e_51767048": {
        "buggy": "from itertools import combinations\n\nN, M, K = map(int, input().split())\n\nedge = []\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    edge.append([u - 1, v - 1, w])\n\ndef find(x):\n    if R[x] < 0:\n        return x\n    else:\n        R[x] = find(R[x])\n        return R[x]\n    \ndef unite(root_a, root_b):  \n    if root_a != root_b:\n        if R[root_a] > R[root_b]: \n            R[root_a] = root_b\n        elif R[root_b] > R[root_a]: \n            R[root_b] = root_a\n        elif R[root_a] == R[root_b]:\n            R[root_b] = root_a\n            R[root_a] -= 1\n\ndef group_size(R):\n    count = 0\n    for r in R:\n        if r < 0:\n            count += 1\n    return count\n\nans = 10**10\nfor edges in combinations(edge, N - 1): # \u8fba\u306e\u6570\u306fN-1\u672c\u3067\u3044\u3044\n    R = [-1]*N\n    cost = 0\n    for edge in edges:\n        u, v, w = edge\n        root_u = find(u)\n        root_v = find(v)\n        unite(root_u, root_v)\n        cost += w\n    if group_size(R) == 1:\n        ans = min(cost%K, ans)\n\nprint(ans)",
        "length": 47,
        "loc": 34
    },
    "abc329_a_55135985": {
        "buggy": "S = input()\nans = [0] * len(S)\nfor i in range(len(S)):\n  ans[i] = S[i]\nprint(ans)",
        "length": 5,
        "loc": 5
    },
    "abc329_c_54204891": {
        "buggy": "n = int(input())\ns = input()\nresult = set()\nch = s[0]\nlength = 1\nresult.add((ch, length))\nfor i in range(1, n):\n    if s[i-1] == s[i]:\n        length += 1\n        result.add((ch, length))\n    else:\n        ch = s[i]\n        length = 1\n        result.add((ch, length))\nresult = len(result)",
        "length": 15,
        "loc": 15
    },
    "abc329_e_50998625": {
        "buggy": "# coding: utf-8\n# Your code here!\nn,m=map(int,input().split())\ns=input()\nt=input()\ndp=[[[False]for _ in range(m+1)]for _ in range(n+1)]\ndp[0][0]=True\nfor i in range(n):\n    if i+m<=n:\n        for j in range(m+1):\n            if dp[i][j]:\n                dp[i][0]=True\n    if dp[i][m]:\n        for j in range(m+1):\n            dp[i][j]=True\n    for j in range(m):\n        if dp[i][j] and s[i]==t[j]:\n            dp[i+1][j+1]=True\nprint(\"Yes\" if dp[n][m] else \"No\")",
        "length": 19,
        "loc": 6
    },
    "abc330_b_54214263": {
        "buggy": "N, L, R = map(int, input().split())\na = list(map(int, input().split()))\nans = [] \nfor i in a:\n    if i < L:\n        ans.append(L)\n    elif i > L and i < R:\n        ans.append(i)\n    else:\n        ans.append(R)\nprint(*ans)",
        "length": 11,
        "loc": 5
    },
    "abc330_c_54054641": {
        "buggy": "d = int(input())\nx = 0\nout = d\nwhile 2 * x**2 < d:\n    y = int((d - x**2)**(0.5))\n    out = min(out, d - x**2 - y**2, x**2 + (y+1)**2 - d)\n    x += 1\n\nprint(out)",
        "length": 9,
        "loc": 4
    },
    "abc331_a_54933311": {
        "buggy": "M,D = map(int,input().split())\ny,m,d = map(int,input().split())\n\nif d == D:  # \u6700\u5f8c\u306e\u65e5\n    d = 1\n    if m == M:\n        m = 1\n        y += 1\nelse:\n    d += 1\n\nprint(y,m,d)",
        "length": 12,
        "loc": 9
    },
    "abc331_b_54148195": {
        "buggy": "from itertools import product\nN,S,M,L=map(int,input().split())\nans=10**20\nfor i,j,k in product(range(N),repeat=3):\n\tif 6*i+8*j+12*k<N:\n\t\tcontinue\n\tans=min(ans,S*i+M*j+L*k)\nprint(ans)",
        "length": 8,
        "loc": 4
    },
    "abc331_c_54472770": {
        "buggy": "n=int(input())\na=list(map(int,input().split()))\nfrom collections import Counter\nc=list(Counter(a).items())\nl=[]\nfor num,cnt in c:\n    l.append(num*cnt)\nfrom itertools import accumulate\nl=list(accumulate(l))\na_set=sorted(set(a))\nd=dict(zip(a_set,l))\ntotal=sum(a)\nans=[]\nfor i in range(n):\n    ans.append(total-d[a[i]])\nprint(*ans)",
        "length": 16,
        "loc": 4
    },
    "abc331_d_53655797": {
        "buggy": "def calc_area(y, x):\n    ret = score[N][N] * (x//N) * (y//N)\n    ret += score[N][x%N] * (y//N)\n    ret += score[y%N][N] * (x//N)\n    ret += score[y%N][x%N]\n    return ret\n\nN, Q = map(int, input().split())\nP = [list(input()) for i in range(N)]\nscore = [[0] * (N+1) for i in range(N+1)]\nABCD = [list(map(int, input().split())) for i in range(Q)]\n\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        if P[i-1][j-1] == \"B\":\n            score[i][j] = 1\n\nfor i in range(N+1):\n    for j in range(1, N+1):\n        score[i][j] += score[i][j-1]\n\nfor j in range(N+1):\n    for i in range(1, N+1):\n        score[i][j] += score[i-1][j]\n\nfor i in score:\n    print(*i)\n\nfor a, b, c, d in ABCD:\n    c += 1\n    d += 1\n    print(calc_area(c, d) -calc_area(a, d) -calc_area(c, b) + calc_area(a, b))",
        "length": 32,
        "loc": 0
    },
    "abc331_e_53576352": {
        "buggy": "N, M, L = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\npat = [list(map(lambda x:int(x)-1, input().split())) for _ in range(L)]\nng_set = set()\nfor i, j in pat:\n    ng_set.add((i, j))\n\n#P:B\u3092\u4fa1\u683c\u306e\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3057\u305f\u3082\u306e\u3067index\u3082\u540c\u6642\u306b\u4fdd\u6301\u3057\u3066\u3044\u308b\nP = sorted([(b, j) for j, b in enumerate(B)], reverse=True)\n\nans = -1\nfor i, a in enumerate(A):\n    for b, j in P:\n        if (i, j) in pat:\n            continue\n        ans = max(ans, a+b)\n        break\n\nprint(ans)\n",
        "length": 21,
        "loc": 16
    },
    "abc332_a_55010620": {
        "buggy": "N,S,K = map(int,input().split())\nx = 0\nfor i in range (N):\n    P,Q = map(int,input().split())\n    x += P*Q\nif S >= x:\n    x += K\nprint(x)\n",
        "length": 8,
        "loc": 6
    },
    "abc332_b_54879479": {
        "buggy": "K, G, M = map(int, input().split())\nGi, Mi = 0, 0\nfor _ in range(K):\n    if Gi == G:\n        Gi = 0\n    elif Mi == 0:\n        Mi = M\n    else:\n        if Gi + Mi > G:\n            Gi = G\n            Mi = Mi - (G - Gi)\n        else:\n            Gi = Gi + Mi\n            Mi = 0\nprint(Gi, Mi)",
        "length": 15,
        "loc": 12
    },
    "abc332_c_54228100": {
        "buggy": "n, m = map(int, input().split())\ns = str(input())\nm_real = m\nlogo_T = 0\nlogo_T_real = 0\nfor i in range (n):\n    if s[i] == \"0\":\n        m_real = m\n        logo_T_real = logo_T\n    if s[i] == \"1\":\n        if m_real > 0:\n            m_real -= 1\n        else:\n            logo_T += 1\n    if s[i] == \"2\":\n        if logo_T_real > 0:\n            logo_T_real -= 1\n        else:\n            logo_T += 1\nprint(logo_T)",
        "length": 20,
        "loc": 13
    },
    "abc332_d_53758957": {
        "buggy": "import sys\nsys.setrecursionlimit(10**8)\n\n\n\n\n\nH, W = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(H)]\nB = [list(map(int, input().split())) for _ in range(H)]\n\ndef perm(n):\n  rt = []\n  def iter(s, acc):\n    if not s:\n      rt.append(acc[:])\n    for i in range(len(s)):\n      v = s[i]\n      s.remove(v)\n      acc.append(v)\n      iter(s, acc)\n      acc.pop()\n      s.insert(i, v)\n  iter(list(range(n)), [])\n  return rt\n\ndef tp(tbl):\n  H = len(tbl)\n  W = len(tbl[0])\n  t = [['' for _ in range(H)] for _ in range(W)]\n  for i in range(H):\n    for j in range(W):\n      t[j][i] = tbl[i][j]\n  return t\n\ndef f(s):\n  n = 0\n  for i in range(len(s)):\n    for j in range(i):\n      if s[j] > s[i]:\n        n += 1\n  return n\n\nans = float('inf')\nfor p in perm(W):\n  tbl = []\n  for i in range(H):\n    t = []\n    for j in p:\n      t.append(A[i][j])\n    tbl.append(t)\n  if sorted(tbl) == sorted(B):\n    At = tp(tbl)\n    Bt = tp(B)\n    for q in perm(H):\n      tbl = []\n      for i in range(W):\n        t = []\n        for j in q:\n          t.append(At[i][j])\n        tbl.append(t)\n      if sorted(tbl) == sorted(Bt):\n        ans = min(ans, f(p) + f(q))\n\nif ans == float('inf'):\n  ans = -1\n\nprint(ans)\n\n",
        "length": 69,
        "loc": 62
    },
    "abc332_e_52500433": {
        "buggy": "ctypedef long long ll\nfrom libcpp.vector cimport vector\ncdef:\n    ll N,D,S,i,j,k,w,b,now\n    double mean\n    vector[double] pre\n    vector[ll] bi\n    vector[vector[double]] dp\n\nN,D=map(int,input().split())\nW=list(map(int,input().split()))\n\nmean=sum(W)/D\n#print(mean)\n\nfor S in range(1<<N):\n    w=0\n    j=0\n    for i in range(N):\n        if S&(1<<i):\n            w+=W[i]\n            j+=1\n    pre.push_back(((w-mean)**2)/D)\n    bi.push_back(j)\n    \ndp.resize(1<<N)\nfor S in range(1<<N):\n    dp[S].resize(D+1,10**20)\n    b=bi[S]\n    for k in range(1,min(D+1,b)):\n        if k==1:\n            dp[S][k]=pre[S]\n        else:\n            now=(S-1)&S\n            while now>0:\n                dp[S][k]=min(dp[S][k],dp[now][k-1]+pre[S^now])\n                now=(now-1)&S\n                \nprint(dp[(1<<N)-1][D])",
        "length": 39,
        "loc": 30
    },
    "abc332_f_49265039": {
        "buggy": "mod=998244353\nclass SegTreeLazy():\n    def __init__(self, a):\n        # \u521d\u671f\u5316\n        n=len(a)\n        self.n = n\n        self.a = a\n        self.ans=[0]*n\n        self.logN=(n-1).bit_length()\n        self.n0 = 1<<self.logN\n        self.ktree=[1]*2*self.n0\n        self.dtree=[0]*2*self.n0\n        for i in range(n):\n            self.dtree[self.n0-1+i]=a[i]\n            self.ktree[self.n0-1+i]=0\n        self.lazy=[None]*2*self.n0 \n    # [l,r)\u306e\u4e0a\u306b\u3042\u308b\u89aa\u30ce\u30fc\u30c9\u5168\u3066\u3092\u8fd4\u3059\n    def gindex(self,l, r):\n        L = (l + self.n0) >> 1; R = (r + self.n0) >> 1\n        lc = 0 if l & 1 else (L & -L).bit_length()\n        rc = 0 if r & 1 else (R & -R).bit_length()\n        for i in range(self.logN):\n            if rc <= i:\n                yield R\n            if L < R and lc <= i:\n                yield L\n            L >>= 1; R >>= 1     \n    # \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n    def propagates(self,*ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.lazy[2*i]=1\n            self.ktree[2*i-1] = self.ktree[i-1]*self.ktree[2*i-1]%mod\n            self.ktree[2*i] =  self.ktree[i-1]*self.ktree[2*i]%mod\n            self.dtree[2*i-1] =  (self.ktree[i-1]*self.dtree[2*i-1]%mod+self.dtree[i-1])%mod\n            self.dtree[2*i] = (self.ktree[i-1]*self.dtree[2*i]%mod+self.dtree[i-1])%mod\n            self.lazy[i-1] = None\n            self.ktree[i-1] = 1 \n            self.dtree[i-1] = 0 \n     \n    # \u533a\u9593[l, r)\u3092k,d\u3067\u66f4\u65b0\n    def update(self,l, r, k,d):\n        *ids, = self.gindex(l, r)\n        self.propagates(*ids)\n        L = self.n0 + l; R = self.n0 + r\n        while L < R:\n            if R & 1:\n                R -= 1\n                self.ktree[R-1] =self.ktree[R-1]*k%mod \n                self.dtree[R-1] = (self.dtree[R-1]*k%mod+d)%mod\n                self.lazy[R-1]=1\n            if L & 1:\n                self.ktree[L-1] = self.ktree[L-1]*k%mod\n                self.dtree[L-1] = (self.dtree[L-1]*k%mod+d)%mod\n                self.lazy[L-1]=1\n                L += 1\n            L >>= 1; R >>= 1\n            \n        \n    def query(self):\n        ans=[0]*n\n        for i in range(1,self.n0):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.lazy[2*i]=1\n            self.ktree[2*i-1] = self.ktree[i-1]*self.ktree[2*i-1]%mod\n            self.ktree[2*i] =  self.ktree[i-1]*self.ktree[2*i]%mod\n            self.dtree[2*i-1] =  (self.ktree[i-1]*self.dtree[2*i-1]%mod+self.dtree[i-1])%mod\n            self.dtree[2*i] = (self.ktree[i-1]*self.dtree[2*i]%mod+self.dtree[i-1])%mod\n            self.lazy[i-1] = None\n            self.ktree[i-1] = 1 \n            self.dtree[i-1] = 0 \n            \n        return self.dtree[self.n0-1:self.n0-1+self.n]\ndef modinv(a):\n    return pow(a,mod-2,mod)\n    \nn,m=map(int,input().split())\nA=list(map(int,input().split()))\nst=SegTreeLazy(A)\np=[0]*n\nq=[0]*n\nfor i in range(n):\n    p[i]=modinv(i+1)\n    q[i]=(1-p[i])%mod\nfor i in range(m):\n    l,r,x=map(int,input().split())\n    st.update(l-1,r,q[r-l],p[r-l]*x%mod)\nans=st.query()\nprint(*ans)    \n",
        "length": 93,
        "loc": 14
    },
    "abc333_a_54873390": {
        "buggy": "N = int(input())\nprint('N'*N)",
        "length": 2,
        "loc": 2
    },
    "abc333_b_54528600": {
        "buggy": "S = input()\nT = input()\n\ng1 = [\"AB\", \"BC\", \"CD\", \"DE\", \"EA\"]\n\nif S in g1 and T in g1:\n    print(\"Yes\")\nelif S not in g1 and T not in g1:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "length": 11,
        "loc": 4
    },
    "abc333_e_52477249": {
        "buggy": "n=int(input())\ntx=[list(map(int,input().split())) for _ in range(n)]\n\nK_max,k=0,0\nans=[]\ncnt=[0]*(n+1)\nfor t,x in tx[::-1]:\n  if t==1:\n    if cnt[x]<0:\n      cnt[x]+=1\n      ans.append(1)\n    else:\n      ans.append(0)\n    k-=1\n    \n  else:\n    cnt[x]-=1\n    k+=1\n  \n  K_max=max(K_max,k)\n  \nif min(cnt)==0:\n  print(K_max)\n  print(*ans[::-1])\n\nelse:\n  print(-1)",
        "length": 27,
        "loc": 12
    },
    "abc334_a_54632654": {
        "buggy": "B, G = map(int, input().split())\n\nif B > G:\n  print(\"Bat\")\nelse:\n  print(\"Grove\")\n",
        "length": 6,
        "loc": 6
    },
    "abc334_b_54939914": {
        "buggy": "A,M,L,R = map(int,input().split())\nx1 = -(-(L-A)//M)\nx2 = (R-A)//M\nif (L-A)%M == 0:\n    print(abs(x1-x2)+1)\nelse:\n    print(abs(x1-x2))",
        "length": 7,
        "loc": 2
    },
    "abc334_c_54507811": {
        "buggy": "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nif K % 2 != 0:\n    now = 0\n    for i in range(1, K-1, 2):\n        now += A[i+1] - A[i]\n    ans = now\n    for i in range(2, K-1, 2):\n        now += A[i-1] - A[i-2]\n        now -= A[i] - A[i-1]\n        ans = min(ans, now)\n    print(ans)\n    exit()\nans = 0\nfor i in range(0, K-1, 2):\n    ans += A[i+1] - A[i]\nprint(ans)\n    ",
        "length": 19,
        "loc": 9
    },
    "abc334_e_52777689": {
        "buggy": "class UnionFind():\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n        self.siz = [1] * n\n    def find(self, x):\n        if self.par[x] == -1: return x \n        else:\n          self.par[x] = self.find(self.par[x]) \n          return self.par[x]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx == ry: return False \n        if self.rank[rx] < self.rank[ry]: \n            rx, ry = ry, rx\n        self.par[ry] = rx \n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n        self.siz[rx] += self.siz[ry]\n        return True\n    def size(self, x):\n        return self.siz[self.find(x)]\n    \nH, W = map(int, input().split())\nvers = [[0] * W for i in range(H)]\ncnt = 0\ncolor = [list(input()) for i in range(H)]\nfor i in range(H):\n    for j in range(W):\n        vers[i][j] = cnt\n        cnt += 1\n        \nuf = UnionFind(H*W)\n\nfor i in range(H):\n    for j in range(W):\n        if color[i][j] == \".\":continue\n        for ii, jj in [(1, 0),(-1, 0),(0, 1),(0, -1)]:\n            if 0 <= i + ii < H and 0 <= j + jj < W:\n                if color[i+ii][j+jj] == \"#\":\n                    uf.union(vers[i][j], vers[i+ii][j+jj])\n\ngreenset = set()\ngreencnt = 0\nbunbo = 0\nfor i in range(H):\n    for j in range(W):\n        if color[i][j] == \"#\":\n            greenset.add(uf.find(vers[i][j]))\n        else:\n            bunbo += 1\ngreencnt = len(greenset)\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if color[i][j] == \"#\":continue\n        se = set()\n        for ii, jj in [(1, 0),(-1, 0),(0, 1),(0, -1)]:\n            if 0 <= i + ii < H and 0 <= j + jj < W:\n                if color[i+ii][j+jj] == \"#\":\n                    se.add(uf.find(vers[i+ii][j+jj]))\n        ans +=  greencnt - len(se) + 1\nmod = 998244353\nprint(ans)\nprint(bunbo)\nprint(ans * pow(bunbo, -1, mod) % mod)",
        "length": 70,
        "loc": 68
    },
    "abc335_a_54722195": {
        "buggy": "S = input()\n\nprint(S[:-1] + \"1\")",
        "length": 3,
        "loc": 3
    },
    "abc335_b_54952141": {
        "buggy": "n = int(input())\nfor i in range(n+1):\n  for j in range(n+1):\n    for k in range(n+1):\n      if i + j + k <= 3:\n        print(i,j,k)",
        "length": 6,
        "loc": 5
    },
    "abc335_c_54761839": {
        "buggy": "s=input().split()\nn=int(s[0])\na=[[n-i,0] for i in range(n)]\nq=int(s[1])\nstr=\"LURD\"\nd=[1,0,-1,0]\nfor _ in range(q):\n  s=input().split()\n  if s[0]=='1':\n    a.append([a[-1][0]+d[str.index(s[1])],a[-1][1]+d[str.index(s[1])-1]])\n  else:\n    print(a[-int(s[1])][0],a[-int(s[1])][1])",
        "length": 12,
        "loc": 5
    },
    "abc335_d_53021579": {
        "buggy": "N = int(input())\ngrid = [[0 for _ in range(N)] for j in range(N)]\ngrid[(N+1)//2-1][(N+1)//2-1] = \"T\"\ndir=[[0,1],[1,0],[0,-1],[-1,0]]\ndirPath = 0\nx=y=0\ngrid[x][y] = 1\nfor i in range(2,N**2):\n    while x+dir[dirPath][0] < 0 or x+dir[dirPath][0] > N-1   or y+dir[dirPath][1] < 0 or y+dir[dirPath][1] > N-1 or grid[x+dir[dirPath][0]][y+dir[dirPath][1]] != 0 :\n        dirPath = (dirPath+1)%4\n    x = x + dir[dirPath][0]\n    y = y + dir[dirPath][1]\n    print(x,y)\n\n    grid[x][y] = i\n\nfor i in range(N):\n    print(*grid[i])\n",
        "length": 18,
        "loc": 13
    },
    "abc335_e_54715880": {
        "buggy": "from collections import deque, defaultdict, Counter\nfrom bisect import bisect_left, bisect_right\nfrom atcoder.segtree import SegTree\nfrom atcoder.lazysegtree import LazySegTree\nfrom atcoder.dsu import DSU\nfrom atcoder.scc import SCCGraph\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nimport math, sys\n_int = lambda x: int(x)-1\nMOD = 998244353\nINF = 1<<62\nYes, No = \"Yes\", \"No\"\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nS = sorted(set(A))\n\nUV = []\nD = DSU(N)\nfor _ in range(M):\n    u, v = map(_int, input().split())\n    if A[u] == A[v]:\n        D.merge(u, v)\n    else:\n        if A[u] > A[v]: u, v = v, u\n        UV.append((u, v))\n\nG = SCCGraph(N)\nE = defaultdict(list)\nfor u, v in UV:\n    G.add_edge(D.leader(u), D.leader(v))\n    E[u].append(v)\n\nmemo = [0]*N\nmemo[D.leader(0)] = 1\nfor g in G.scc():\n    for i in g:\n        if memo[i] == 0: continue\n        for j in E[i]:\n            memo[j] = max(memo[j], memo[i]+1)\n\nprint(memo[D.leader(N-1)])",
        "length": 43,
        "loc": 33
    },
    "abc335_f_54448133": {
        "buggy": "n=int(input())\na=list(map(int,input().split()))\nmod=998244353\n\nb=500\n\ndp1=[[0]*(b) for _ in range(n)]\ndp2=[0]*n\ndp2[0]=1\n\nif a[0]<b:\n  if a[0]<n:\n    dp1[a[0]][a[0]]=1\nelse:\n  for i in range(1,n//a[0]):\n    dp2[i*a[0]]=1\n    \nfor i in range(1,n):\n  dp2[i]+=sum(dp1[i])\n  dp2[i]%=mod\n  for j in range(b):\n    if i+j<n:\n      dp1[i+j][j]+=dp1[i][j]\n      dp1[i+j][j]%=mod\n  if i+a[i]>=n:\n    continue\n  if a[i]<b:\n    dp1[i+a[i]][a[i]]+=dp2[i]\n    dp1[i+a[i]][a[i]]%=mod\n  else:\n    for j in range(1,(n-i-1)//a[i]+1):\n      dp2[i+j*a[i]]+=dp2[i]\n      dp2[i+j*a[i]]%=mod\n  \nprint(sum(dp2)%mod)",
        "length": 35,
        "loc": 15
    },
    "abc336_a_54679232": {
        "buggy": "N = int(input())\nXo = \"o\" * (N-3)\nans = \"L\" + Xo + \"n\" + \"g\"\nprint(ans)",
        "length": 4,
        "loc": 2
    },
    "abc336_c_54629693": {
        "buggy": "# 5\u9032\u6570\u3067\u8003\u3048\u308b\n\nN = int(input()) - 1\nrems = []\nwhile N > 0:\n  quotient = N // 5\n  remainder = N % 5\n  rems.append(remainder)\n  N = quotient \nconverted = rems[::-1]\nconverted = ''.join([str(c * 2) for c in converted])\nprint(converted)\n",
        "length": 12,
        "loc": 4
    },
    "abc336_d_54268398": {
        "buggy": "# import sys\n# sys.setrecursionlimit(10**6)\n# sys.set_int_max_str_digits(10**6)\n\n# mod = 998244353\n# ds = [(-1,0),(0,1),(1,0),(0,-1)]\n# alph = 'abcdefghijklmnopqrstuvwxyz'\ndef rint():\n    return list(map(int, input().split())) \n\n# S = input()\nN, = rint()\nA = rint()\n\ndef sub(A):\n    ret = [0]*N\n    height = 0\n    for i in range(len(A)):\n        height += 1\n        if A[i] < height:\n            height = A[i]\n        ret[i] = height\n    return ret\nL = sub(A) \nR = sub(A[::-1])\nans = 1\nfor i in range(N):\n    ans = max(ans, min(L[i], R[i]))\n\nprint(ans)",
        "length": 30,
        "loc": 25
    },
    "abc337_a_54540906": {
        "buggy": "N = int(input())\n\nX = 0\nY = 0\nfor i in range(N):\n    x, y = map(int,input().split())\n    X += x\n    Y += y\n\nif X > Y:\n    print(\"Takahasi\")\nelif X == Y:\n    print(\"Draw\")\nelse:\n    print(\"Aoki\")\n\n",
        "length": 16,
        "loc": 11
    },
    "abc337_c_54225038": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\n\ns = [i for i in range(1,N+1)]\nd = dict(zip(A, s))\n\nnext = d[-1]\nwhile next!=N:\n    print(next, end = ' ')\n    next = d[next]\nprint(next)",
        "length": 11,
        "loc": 8
    },
    "abc337_d_54308671": {
        "buggy": "H,W,K=map(int,input().split())\nS=[input() for i in range(H)]\ndic=dict({'o':0,'x':1,'.':2})\nans=10**10\nfor i in range(H):\n\tchk=[0,0,0]\n\tif W<K:\n\t\tbreak\n\tfor j in range(K):\n\t\tchk[dic[S[i][j]]]+=1\n\tif chk[1]==0:\n\t\tans=min(ans,chk[2])\n\tfor j in range(K,W):\n\t\tchk[dic[S[i][j-K]]]-=1\n\t\tchk[dic[S[i][j]]]+=1\n\t\tif chk[1]==0:\n\t\t\tans=min(ans,chk[2])\nfor j in range(W):\n\tchk=[0,0,0]\n\tif H<K:\n\t\tbreak\n\tfor i in range(K):\n\t\tchk[dic[S[i][j]]]+=1\n\tif chk[1]==0:\n\t\tans=min(ans,chk[2])\n\tfor i in range(K,H):\n\t\tchk[dic[S[i-K][j]]]-=1\n\t\tchk[dic[S[i][j]]]+=1\n\t\tif chk[1]==0:\n\t\t\tans=min(ans,chk[2])\nprint(ans)",
        "length": 31,
        "loc": 31
    },
    "abc337_e_54032860": {
        "buggy": "N = int(input())\nn = 1\nwhile n**2<N:n+=1\nout = [[i+1 for i in range(N) if (1<<b)&i] for b in range(n)]\nprint(len(out),flush=True)\nfor q in out:\n  print(len(q),*q,flush=True)\nret = [*map(int,input())]\nans = 1\nfor n in range(len(ret)):\n  if ret[n]==1 : ans += 1<<n\nprint(ans,flush=True)",
        "length": 12,
        "loc": 3
    },
    "abc337_f_49855272": {
        "buggy": "from collections import defaultdict\n\n\ndef solution():\n    N, M, K = map(int, input().split())\n    c_lst = list(map(lambda s: int(s) - 1, input().split()))\n    cnt = defaultdict(int)\n    for c in c_lst:\n        cnt[c] += 1\n    c_lst *= 2\n\n    res = 0  # number of total balls in boxes within range [i,i+N-1]\n    box = 0  # number of boxes currently being used within range [i,i+N-1]\n    dp = [0] * N  # dp[c] = number of color c balls in boxes within range [i,j]\n\n    j = 0\n    for i in range(N):\n        if i > 0:\n            # print(\"remove at i={}\".format(i))\n            dp[c_lst[i - 1]] -= 1\n            if dp[c_lst[i - 1]] % K == 0:\n                box -= 1\n                res -= min(K, 1 + (cnt[c_lst[i - 1]] - dp[c_lst[i - 1]] - 1))\n                # print(\"remove more at i={} for {}\".format(i, min(K, 1+(cnt[c_lst[i-1]]-dp[c_lst[i-1]]-1))))\n        while j < i + N and box < M:\n            # print(\"scan i,j={}\".format((i,j)))\n            dp[c_lst[j]] += 1\n            if dp[c_lst[j]] % K == 1:\n                box += 1\n                res += min(K, cnt[c_lst[j]] - dp[c_lst[j]] + 1)\n                # print(\"include at i,j={} for {}\".format((i,j), min(K, cnt[c_lst[j]]-dp[c_lst[j]]+1)))\n            j += 1\n        print(res)\n\n    return\n\n\nsolution()",
        "length": 38,
        "loc": 28
    },
    "abc338_a_55016820": {
        "buggy": "S = input()\n\nif S[0].isupper():\n  if (len(S)>= 2 and S[1:].islower()) or len(S) == 1:\n    print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 7,
        "loc": 6
    },
    "abc338_b_54399591": {
        "buggy": "s = list(input())\n\nS = sorted(list(set(s)))\n\nstr = \"\"\n\nfor i in range(len(S)-1):\n    if i == 0:\n        str = S[0]\n    elif s.count(S[i]) > s.count(str):\n        str = S[i]\n\nprint(str)",
        "length": 13,
        "loc": 7
    },
    "abc338_c_54491236": {
        "buggy": "n=int(input())\nq=list(map(int,input().split()))\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nans=0\ninf=float(\"inf\")\nfor x in range(max(q)+1):\n    y=inf\n    for i in range(n):\n        if q[i]<x*a[i]:\n            y=-inf\n            break\n        elif b[i]>0:\n            y=min((q[i]-x*a[i])//b[i],x)\n    ans=max(ans,x+y)\nprint(ans)",
        "length": 16,
        "loc": 14
    },
    "abc338_f_52289901": {
        "buggy": "from collections import deque\nN,M = map(int, input().split())\ninf = 1<<30\ndist = [[inf]*N for _ in range(N)]\nfor _ in range(M):\n    u,v,w = map(int, input().split())\n    dist[u-1][v-1] = w\n\nfor i in range(N):\n    dist[i][i] = 0\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n\ndp = [[inf]*N for _ in range(2**N)]\nfor i in range(N):\n    dp[1<<i][i] = 0\n\nfor i in range(2**N):\n    for u in range(N):\n        if dp[i][u] == inf:\n            continue\n        for v in range(N):\n            k = i | 1<<v\n            dp[k][v] = min(dp[k][v], dp[i][u]+dist[u][v])\n\nans = min(dp[(1<<N)-1])\nif ans == inf:\n    ans = \"No\"\nprint(ans)",
        "length": 31,
        "loc": 25
    },
    "abc339_a_55124019": {
        "buggy": "S = input()\nfor i in range(len(S)):\n  if S[-i] == \".\":\n    print(S[-i+1:])\n    break",
        "length": 5,
        "loc": 2
    },
    "abc339_c_54222445": {
        "buggy": "n = int(input())\nalist = list(map(int, input().split()))\nacc = 0\nimin = 0\namin = 0\nfor i in range(n):\n    acc += alist[i]\n    if acc <= amin:\n        amin = acc\n        imin = i\nprint(sum(alist[imin+1:]))",
        "length": 11,
        "loc": 4
    },
    "abc339_e_54055907": {
        "buggy": "# import sys\n# sys.setrecursionlimit(10**6)\n# sys.set_int_max_str_digits(10**6)\n# from scipy.optimize import bisect\n# from collections import defaultdict, Counter\n# import bisect\n# import heapq\nfrom atcoder.segtree import SegTree\nfrom sortedcontainers import SortedList\n\n# mod = 998244353\n# ds = [(-1,0),(0,1),(1,0),(0,-1)]\n\n# S = input()\n# N = int(input())\nN, D = map(int, input().split())\n\nA = list(map(int, input().split()))\n\n\nM = max(A)\nseg = SegTree(max, 0, M+1)\nfor i in range(N):\n    a = A[i]\n    m = seg.prod(max(a-D, 0),min(M,a+D+1))\n    seg.set(a,m+1)\n    \nans = seg.all_prod()\nprint(ans)",
        "length": 29,
        "loc": 25
    },
    "abc340_a_54522310": {
        "buggy": "A,B,D=map(int,input().split())\nans=[A]\nwhile A<=B:\n  ans.append(A+D)\n  A+=D\nprint(*ans)",
        "length": 6,
        "loc": 3
    },
    "abc340_b_54768693": {
        "buggy": "N = int(input())\n\nA = []\nfor i in range(N):\n  query, num = map(int,input().split())\n  if query == 1:\n    A.append(num)\n  elif query == 2:\n    print(A[-1])\n    ",
        "length": 10,
        "loc": 9
    },
    "abc340_f_52511513": {
        "buggy": "def extended_euclid(a, b):\n    c, d, e, f = 1, 0, 0, 1\n    while b != 0:\n        c, d = d, c - a // b * d\n        e, f = f, e - a // b * f\n        a, b = b, a % b\n    return (c, e)\n        \ndef gcd(a,b):\n  if a%b==0:\n    return b\n  else:\n    return gcd(b,a%b)\n  \nX,Y=list(map(int,input().split()))\nif X==0:\n  if abs(Y)==1 or abs(Y)==2:\n    print(2//abs(Y),0)\n  else:\n    print(-1)\nelif Y==0:\n  if abs(X)==1 or abs(X)==2:\n    print(0,2//abs(X))\n  else:\n    print(-1)\nelif gcd(abs(X),abs(Y))>2:\n  print(-1)\nelse:\n  a,b=extended_euclid(X,-Y)\n  print(2*b,2*a)",
        "length": 30,
        "loc": 30
    },
    "abc341_a_54737422": {
        "buggy": "n = int(input())\na = \"\"\n\nfor i in range(2*n):\n  a += \"1\" if i%2 ==0 else \"0\"\n\nprint(a)\n\n\n  ",
        "length": 10,
        "loc": 4
    },
    "abc341_e_53935483": {
        "buggy": "from sys import stdin\nN,Q = map(int, stdin.readline().split())\nS = list(stdin.readline()[:-1])\n\nTF = [0]*(N+10)\nBIT = [0]*(N+10)\n\ndef get(pos):\n    s = 0\n    while pos > 0:\n        s += BIT[pos]\n        pos -= pos & -pos\n    return s\n\ndef add(pos,val):\n    while pos <= N+5:\n        BIT[pos] += val\n        pos += pos & -pos\n    return\n\nfor i,v in enumerate(S):\n    if i == 0:\n        continue\n    if S[i] == S[i-1]:\n        add(i+1,1)\n        TF[i+1] = 1\n\nfor i in range(Q):\n    que,left,right = map(int, stdin.readline().split())\n    if que == 2:\n        if left == 1:\n            tmp = get(right)\n        else:\n            tmp = get(right)-get(left-1)\n\n        if tmp == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        if right != N:\n            if TF[right+1] == 1:\n                TF[right+1] = 0\n                add(right+1,-1)\n            else:\n                TF[right+1] = 1\n                add(right+1,1)\n        if left != 1:\n            if TF[left] == 1:\n                TF[left] = 0\n                add(left,-1)\n            else:\n                TF[left] = 1\n                add(left,1)\n",
        "length": 54,
        "loc": 34
    },
    "abc342_a_54672989": {
        "buggy": "S = input()\n\nfor i in range(len(S)-1):\n  if S[i-1] != S[i] and S[i] != S[i+1]:\n    print(i+1)",
        "length": 5,
        "loc": 6
    },
    "abc342_b_54862037": {
        "buggy": "N=int(input())\nP=list(map(int,input().split()))\nflg=[[False]*N for i in range(N)]\nfor i in range(1,N):\n\tfor j in range(i):\n\t\tflg[j][i]=True\nQ=int(input())\nfor i in range(Q):\n\tA,B=map(int,input().split())\n\tif flg[A-1][B-1]:\n\t\tprint(A)\n\telse:\n\t\tprint(B)",
        "length": 13,
        "loc": 6
    },
    "abc342_c_54936668": {
        "buggy": "n = int(input())\nphrase = input().lower()\noperation = int(input())\n\nalphabet = \"abcdefghijklmnopqrstuvwsyz\"\n\nfor i in range(operation):\n    original, become = input().split()\n    alphabet = alphabet.replace(original, become)\n\nnew = \"\"\n\nfor ch in phrase:\n    new += alphabet[ord(ch)-97]\nprint(new)\n",
        "length": 15,
        "loc": 5
    },
    "abc342_d_55039384": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\n# A\u306b0\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\u306f\u30010\u306e\u500b\u6570(n_0)*n - (n_0 + 1)*n_0/2\nn_0 = A.count(0)\n\nimport math\nimport collections\n\n# \u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\nA = [a for a in A if a != 0] # 0\u3092\u9664\u5916\nB = [] # A\u306e\u5404\u8981\u7d20\u3092\u5e73\u65b9\u6570\u3067\u5272\u3063\u305f\u6b8b\u308a\u3092\u5165\u308c\u308b\nfor i in range(len(A)):\n    a = A[i]\n    for j in range(2,int(math.sqrt(a))+1):\n        if a%(j**2) == 0:\n            a //= j**2\n    B.append(a)\n\nans = 0\n# A\u306b0\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\u306f\u30010\u306e\u500b\u6570(n_0)*n - (n_0 + 1)*n_0/2\nans += (n_0)*N - (n_0 + 1)*n_0//2\n\n# \u3042\u3068\u306f\u3001B\u306e\u4e2d\u306b\u4f55\u500b\u540c\u3058\u3082\u306e\u304c\u3042\u308b\u304b\nfor i in collections.Counter(B).values():\n    ans += i * (i-1)//2\n\nprint(ans)",
        "length": 27,
        "loc": 15
    },
    "abc342_f_54509689": {
        "buggy": "class Dual_Fenwick_Tree:\n    def __init__(self, n):\n        self._n = n + 1\n        self.data = [0] * (n + 1)\n\n    def _add(self, p, x):\n        assert 0 <= p < self._n\n        p += 1\n        while p <= self._n:\n            self.data[p - 1] += x\n            p += p & -p\n\n    def sum(self, l, r):\n        assert 0 <= l <= r <= self._n\n        return self._sum(r) - self._sum(l)\n\n    def _sum(self, r):\n        s = 0\n        while r > 0:\n            s += self.data[r - 1]\n            r -= r & -r\n        return s\n\n    # A[l:r]\u306bv\u3092\u8db3\u3059\n    def add(self, l, r, v):\n        self._add(l, v)\n        self._add(r, -v)\n\n    # A[x]\u3092\u8fd4\u3059\n    def get(self, x):\n        return self.sum(0, x + 1)\n\n    def __str__(self):\n        temp = []\n        for i in range(self._n):\n            temp.append(str(self.sum(0, i + 1)))\n        return ' '.join(temp)\n\n\nN, L, D = map(int, input().split())\nM = 2 * N + 5\nT = Dual_Fenwick_Tree(M)\nT.add(0, 1, 1)\nfor i in range(L):\n    v = T.get(i)/D\n    T.add(i + 1, i + D + 1, v)\n    \np = [0] * M\nq = [0] * M\nr = [0] * M\nfor i in range(M):\n    if i >= L:\n        p[i] = T.get(i)\n        \nAc = [0] * (M + 1)\nfor i in range(M):\n    Ac[i + 1] = Ac[i] + p[i]\n    \nfor i in range(M):\n    q[i] = Ac[i] + (Ac[-1] - Ac[N + 1])\n\nfrom collections import *        \nQ = deque()\nv = 0\nfor i in range(N, -1, -1):\n    r[i] = max(q[i], v)\n    Q.append(r[i]/D)\n    v += r[i]/D\n    if len(Q) > L:\n        v -= Q.popleft()\n        \nprint(r[0])",
        "length": 72,
        "loc": 69
    },
    "abc343_b_54540340": {
        "buggy": "N = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\nans = []\nfor i in range(N):\n    for j in range(N):\n        if A[i][j] == 1:\n            ans.append(j+1)\n    print(*ans)",
        "length": 8,
        "loc": 5
    },
    "abc343_c_54978258": {
        "buggy": "N=int(input())\nindex=1\ns = set()\nl=[]\nwhile (True):\n  flg=0\n  three=index*index*index\n  if(three>N):\n    break\n  l.append(three)\n  index+=1\n\n#print(l)\nflg=0\nfor i in reversed(l):\n  flg=0\n  strthree=str(i)\n  if(len(strthree)==1):\n    #print(i)\n    break\n  for j in range(len(strthree)//2):\n    #print(j)\n    #print(strthree[j],strthree[len(strthree)-1-j])\n    if(strthree[j]!=strthree[len(strthree)-1-j]):\n      flg=1\n      break\n  if(flg):\n    continue\n  print(i)\n  break\n",
        "length": 30,
        "loc": 19
    },
    "abc343_e_54516497": {
        "buggy": "# cf. https://atcoder.jp/contests/abc343/editorial/9435\n\ndef f(v):\n    return max(0, min(v)) + 7 - max(v)\n\ndef count2(a1, b1, c1, a2, b2, c2):\n    return f((a1, a2)) * f((b1, b2)) * f((c1, c2))\n\ndef count3(a1, b1, c1, a2, b2, c2, a3, b3, c3):\n    return f((a1, a2, a3)) * f((b1, b2, b3)) * f((c1, c2, c3))\n\ndef generate():\n    candidates = range(-1, 8)\n    for a in candidates:\n        for b in candidates:\n            for c in candidates:\n                yield a, b, c\n\ndef solve(v1, v2, v3):\n    for a2, b2, c2 in generate():\n        for a3, b3, c3 in generate():\n            nv3 = count3(0, 0, 0, a2, b2, c2, a3, b3, c3)\n            nv2 = count2(0, 0, 0, a2, b2, c2) + count2(0, 0, 0, a3, b3, c3) + count2(a2, b2, c2, a3, b3, c3) - 3*nv3\n            nv1 = 3*(7**3) - 2*nv2 - 3*nv3\n            if v1 == nv1 and v2 == nv2 and v3 == nv3:\n                return f\"Yes\\n0 0 0 {a2} {b2} {c2} {a3} {b3} {c3}\"\n    return \"No\"\n\nv1, v2, v3 = map(int, input().split())\nprint(solve(v1, v2, v3))\n\n",
        "length": 31,
        "loc": 4
    },
    "abc344_a_54865781": {
        "buggy": "string = input()\nstart = string.find(\"|\", 0)\nend = string.find(\"|\", start + 1) + 1\nif not(start == (end - 2)): string = string.replace(string[start:end+1], \"\")\nelse: string = string.replace(\"|\", \"\")\nprint(string)",
        "length": 6,
        "loc": 4
    },
    "abc344_b_54684544": {
        "buggy": "a = []\nwhile True:\n  i = int(input())\n  a.append(i)\n  if i == 0: break\na.sort()\nprint(*a,sep='\\n')",
        "length": 7,
        "loc": 6
    },
    "abc344_d_54960181": {
        "buggy": "import sys\n\ndef main():\n    input = sys.stdin.readline\n    T = input().rstrip()\n    N = int(input())\n    l = len(T)\n    dp = [[10**9] * (l + 1) for _ in [0] * (N + 1)]\n    dp[0][0] = 0\n    for i in range(N):\n        a,*si = input().rstrip().split()\n        for j in range(l):\n            if dp[i][j] + 1:\n                dp[i+1][j] = min(dp[i+1][j],dp[i][j])\n                for s in si:\n                    if T[j:j+len(s)] == s:\n                        dp[i+1][j+len(s)] = min(dp[i+1][j+len(s)],dp[i][j] + 1)\n    print(dp[N][l] if dp[N][l] < 10**9 else -1)\n\nif __name__ == '__main__':\n    main()",
        "length": 21,
        "loc": 12
    },
    "abc345_a_54946927": {
        "buggy": "S = input()\nif \"<\" in S and \"=\" in S:\n    if S.count(\"<\") == S.count(\">\") :\n        print(\"Yes\")\n    else :\n        print(\"No\")\n        \nelse :\n    print(\"No\")",
        "length": 9,
        "loc": 2
    },
    "abc345_b_54914858": {
        "buggy": "X = int(input())\nif X < 0:\n    result = int(X//10)\nelse:\n    result = int(X//10 + 1)\nprint(result)",
        "length": 6,
        "loc": 2
    },
    "abc345_c_54753666": {
        "buggy": "S = list(input())\nL = len(S)\ncount = [0] * 26\nflag = False\nfor i in range(L):\n    count[ord(S[i]) - ord('a')] += 1\nans = 0\nfor i in range(25):\n    for j in range(i+1, 26):\n        ans += count[i] * count[j]\n        if count[i] > 1:\n            flag = True\nif flag:\n    ans += 1\nprint(ans)",
        "length": 15,
        "loc": 11
    },
    "abc345_d_53727420": {
        "buggy": "def find_first_empty_pos():\n    for i in range(H):\n        for j in range(W):\n            if not G[i][j]:\n                return i,j\n    return -1,-1\n\ndef is_place(h,w,a,b):\n    if h+a > H or w+b > W:\n        return False\n    for i in range(h,h+a):\n        for j in range(w,w+b):\n            if G[i][j] != 0:\n                return False\n    return True\n\ndef place_or_delete(h,w,a,b,v):\n    for i in range(h,h+a):\n        for j in range(w,w+b):\n            G[i][j] = v\n\n# \u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef dfs(r_node):\n\n    i,j = find_first_empty_pos()\n    if i == j == -1:\n        print(\"Yes\")\n        exit()\n    for idx in r_node:\n        height,width = T[idx]\n        for a,b in [(height,width),(width,height)]:\n            if is_place(i,j,a,b):\n                place_or_delete(i,j,a,b,1)\n                dfs(S-{idx})\n                place_or_delete(i,j,a,b,0)\n\nN,H,W = map(int,input().split())\nT = [tuple(map(int,input().split())) for _ in range(N)]\nG = [[0]*W for _ in range(H)]\nS = set(range(N))\ndfs(S)\nprint(\"No\")",
        "length": 42,
        "loc": 34
    },
    "abc345_f_51504279": {
        "buggy": "import sys\nsys.setrecursionlimit(10**7)\n\nN, M, K = map(int, input().split())\nG = [[] for _ in range(N)]\nfor i in range(M):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, i+1))\n    G[v].append((u, i+1))\n\nvis = [0]*N\nlig = [0]*N\ncnt = 0\nans = []\nflg = False\ndef dfs(now, pre=-1, edge=-1):\n    global cnt\n    vis[now] = 1\n    for nxt, e in G[now]:\n        if vis[nxt] == 0:\n            vis[nxt] = 1\n            dfs(nxt, now, e)\n    if pre != -1 and lig[now] == 0 and cnt < K:\n        lig[now] = 1\n        cnt += 1\n        if lig[pre] == 0:\n            lig[pre] = 1\n            cnt += 1\n        else:\n            lig[pre] = 0\n            cnt -= 1\n        ans.append(edge)\n        if cnt == K:\n            global flg\n            flg = True\n#    print(now, lig)\n\nfor i in range(N):\n    if vis[i] == 0 and cnt < K:\n        dfs(i)\n\nif flg:\n    print('Yes')\n    print(len(ans))\n    print(*ans)\nelse:\n    print('No')\n",
        "length": 49,
        "loc": 44
    },
    "abc346_b_55138933": {
        "buggy": "W,B=map(int,input().split())\n\ncan_l=[]\nAns=\"No\"\npiano=\"wbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbwwbwbwwbwbwbw\"\npiano=list(piano)\nfor i in range(len(piano)):#\u4f55\u6587\u5b57\u3068\u308b\u304b\n  i+=1\n  for j in range(len(piano)-i):#\u4f55\u6587\u5b57\u76ee\u304b\u3089\u3068\u308b\u304b\n    A=[0,0]\n    for k in range(i):#i\u6587\u5b57\u306e\u3046\u3061\u4f55\u6587\u5b57\u76ee\u3092\u3068\u308b\u304b\n      k+=1\n      if piano[j+k]==\"w\":\n        A[0]+=1\n      if piano[j+k]==\"b\":\n        A[1]+=1\n      #print(i,j,k)\n    if A not in can_l:\n      can_l.append(A)\n\nprint(can_l)\ntest_l=[W,B]\n\nif test_l in can_l:\n  Ans=\"Yes\"\n  \nprint(Ans)",
        "length": 27,
        "loc": 21
    },
    "abc346_c_54986100": {
        "buggy": "N, K = map(int, input().split())\nA = set(map(int, input().split()))\n\nsum = int((K * (K + 1)) / 2)\nfor a in A:\n    if 1 <= a <= K:\n        sum -= a\nprint(sum)\n",
        "length": 8,
        "loc": 4
    },
    "abc346_d_54999312": {
        "buggy": "N = int(input())\nS = list(str(input()))\nC = list(map(int, input().split()))\n\n\nA = []\nB = []\n\nfor i in range(N+1):\n    if i == 0:\n        A.append(0)\n        B.append(0)\n    elif int(S[i-1]) == i % 2: \n        A.append(A[i-1] + C[i-1])\n        B.append(B[i-1])\n    else:\n        A.append(A[i-1])\n        B.append(B[i-1] + C[i-1])\n\nans = 10 ** 20\nfor j in range(N):\n    ans = min(ans, A[j]-A[0] + B[N]-B[j], B[j]-B[0] + A[N]-A[j])\n\nprint(ans)\n",
        "length": 24,
        "loc": 21
    },
    "abc346_e_52762677": {
        "buggy": "def solve(h, w, m, t, a, x):\n    a = [_-1 for _ in a]\n    cnt = {color: 0 for color in x} # \u8272\u3054\u3068\u306e\u5857\u3089\u308c\u305f\u30de\u30b9\u306e\u500b\u6570\n    S_row = set() # \u3059\u3067\u306b\u5857\u3089\u308c\u305f\u884c\u306e\u96c6\u5408\n    S_col = set() # \u3059\u3067\u306b\u5857\u3089\u308c\u305f\u5217\u306e\u96c6\u5408\n    # \u9006\u9806\u306b\u5857\u3089\u308c\u305f\u30de\u30b9\u306e\u6570\u3092\u8abf\u3079\u3066\u3044\u304f\n    for k in range(m-1, -1, -1):\n        if t[k] == 1: # a[k]\u5217\u76ee\u306e\u30de\u30b9\u3092\u8272x[k]\u3067\u5857\u308b\n            if not a[k] in S_row:\n                S_row.add(a[k])\n                cnt[x[k]] += w - len(S_col)\n        else: # a[k]\u884c\u76ee\u306e\u30de\u30b9\u3092\u8272x[k]\u3067\u5857\u308b\n            if not a[k] in S_col:\n                S_col.add(a[k])\n                cnt[x[k]] += h - len(S_row)\n    cnt[0] = h * w - sum(cnt.values())\n    return {color: num for color, num in cnt.items() if num > 0}\n\nh, w, m = map(int, input().split())\nt, a, x = zip(*[map(int, input().split()) for i in range(m)])\ncolor_num_mapping = solve(h, w, m, t, a, x)\nprint(len(color_num_mapping))\nfor color, num in sorted(color_num_mapping.items()):\n    print(color, num)\n\n",
        "length": 25,
        "loc": 16
    },
    "abc346_f_53725760": {
        "buggy": "import bisect\nN=int(input())\neng=\"abcdefghijklmnopqrstuvwxyz\"\nengd=dict()\nfor i in range(26) : engd[eng[i]]=i\n\ns=input()\nS=[[]for _ in range(26)]\nfor i in range(len(s)) : S[engd[s[i]]].append(i)\n\nt=input()\nT=[]\nfor i in t : T.append(engd[i])\nfor i in T:\n    if len(S[i])==0 : exit(print(0))\n\ndef can(n):\n    n1,n2=0,-1\n    for i in T:\n        p=bisect.bisect_left(S[i],n2)\n        p+=n-1\n        n1+=p//len(S[i])\n        n2=S[i][p%len(S[i])]\n    return n1<N\n\nleft=-1\nright=2**60\nwhile left!=right:\n    temp=(left+right+1)//2\n    if can(temp): left=temp\n    else: right=temp-1\nprint(max(0,left))",
        "length": 32,
        "loc": 20
    },
    "abc347_a_54735895": {
        "buggy": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = []\n\nfor i in range(n):\n  if a[i] % k == 0:\n      b.append(a[i] / k)\n\nb.sort()\nprint(*b)",
        "length": 10,
        "loc": 7
    },
    "abc347_b_54617710": {
        "buggy": "s = input()\nS_part = set()\nfor i in range(len(s)):\n    for j in range(i+1,len(s)+1):\n        S_part.add(s[i:j])\nprint(S_part)",
        "length": 6,
        "loc": 6
    },
    "abc347_c_55146553": {
        "buggy": "import bisect\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport math\nimport operator\nimport string\nimport sys\n\nreadline = sys.stdin.readline\nLS = lambda: readline().strip()\nLI = lambda: int(readline().strip())\nLLS = lambda: readline().strip().split()\nLL = lambda: list(map(int, readline().strip().split()))\nLLMI = lambda: list(map((1).__rsub__, LL()))\n\nN, A, B = LL()\nD = sorted(set(d % (A + B) for d in LL()))\nprint(\"Yes\" if any((D[(i + 1) % len(D)] - D[i]) % (A + B) > B for i in range(len(D))) else \"No\")\n",
        "length": 20,
        "loc": 20
    },
    "abc347_d_55134495": {
        "buggy": "a, b, C = map(int, input().split())\n\ndef popcount(X, digit):\n\tret = 0\n\tfor i in range(digit):\n\t\tif (1 << i & X):\n\t\t\tret += 1\n\treturn(ret)\n\nc = popcount(C, 60)\n\nif a + b + c > 120 or (a + b + c) % 2 == 1:\n\tprint(-1)\n\texit()\n\nif a > b + c or b > a + c or c > a + b:\n\tprint(-1)\n\texit()\n\nn00 = 60 - (a + b + c) // 2\nn01 = (-a + b + c) // 2\nn10 = (a - b + c) // 2\nn11 = (a + b - c) // 2\n\nX = ['0'] * 60\nY = ['0'] * 60\nfor i in range(60):\n\tif (1 << i & C):\n\t\tif n10 > 0:\n\t\t\tX[59 - i] = '1'\n\t\t\tn10 -= 1\n\t\telse:\n\t\t\tY[59 - i] = '1'\n\t\t\tn01 -= 1\n\telse:\n\t\tif n11 > 0:\n\t\t\tX[59 - i] = '1'\n\t\t\tY[59 - i] = '1'\n\t\t\tn11 -= 1\n\t\telse:\n\t\t\tn00 -= 1\n\nprint(int(('').join(map(str, X))), int(('').join(map(str, Y))))",
        "length": 43,
        "loc": 43
    },
    "abc347_e_55155569": {
        "buggy": "import bisect\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport math\nimport operator\nimport string\nimport sys\n\nfrom atcoder.lazysegtree import LazySegTree\n\nreadline = sys.stdin.readline\nLS = lambda: readline().strip()\nLI = lambda: int(readline().strip())\nLLS = lambda: readline().strip().split()\nLL = lambda: list(map(int, readline().strip().split()))\nLLMI = lambda: list(map((1).__rsub__, LL()))\n\nn, q = LL()\nX = LLMI()\n\n\ndef _op(x1, x2):\n    return [x1[0] + x2[0], 1]\n\n\ndef _mapping(lz, x):\n    return [x[0] + x[1] * lz, x[1]]\n\n\ndef _composition(lz1, lz2):\n    return lz1 + lz2\n\n\nseg = LazySegTree(\n    op=_op, e=[0, 0], mapping=_mapping, composition=_composition, id_=0, v=n\n)\nl = 0\nfor p in X:\n    v, u = seg.get(p)\n    l += 1 - 2 * u\n    seg.set(p, [v, u ^ 1])\n    seg.apply(0, n, l)\n\n\nprint([seg.get(i)[0] for i in range(n)])\n",
        "length": 47,
        "loc": 47
    },
    "abc348_a_54751581": {
        "buggy": "n = int(input())\n\nans = \"\"\nfor i in range(1, n+1):\n    ans += 'x' if i % 3 == 0 else '\u25cb'\nprint(ans)",
        "length": 6,
        "loc": 5
    },
    "abc348_b_54985226": {
        "buggy": "import math\n\nN=int(input())\npoi=[list(map(int,input().split())) for _ in range(N)]\n\nfor x,y in poi:\n    ans=0\n    dist=0\n    for i,(x_i,y_i) in enumerate(poi,1):\n        if dist<math.sqrt((x-x_i)**2+(y-y_i)**2):\n            dist=math.sqrt((x-x_i)**2+(y-y_i)**2)\n            ans=i\n        print(ans)",
        "length": 13,
        "loc": 13
    },
    "abc348_c_54773547": {
        "buggy": "N = int(input())\nAC = sorted(sorted([list(map(int, input().split())) for _ in range(N)]), key=lambda x:x[1])\nnum, _min = AC[0]\nfor i in AC[1:]:\n    if num != i[1]:\n        num = i[1]\n        if _min < i[0]:\n            _min = i[0]\nprint(_min)",
        "length": 9,
        "loc": 3
    },
    "abc349_a_54735340": {
        "buggy": "n = int(input())\na = list(map(int,input().split()))\n\na_n = abs(sum(a))\nprint(a_n)",
        "length": 5,
        "loc": 4
    },
    "abc349_c_54901128": {
        "buggy": "S = input()\nT = input()\nif T[-1] == 'X':\n    T = T[0:2]\nT = T.lower()\n\nj = 0\nfor i in range(len(T)):\n    while j < len(S):\n        if T[i] == S[j]:\n            j += 1\n            break\n        j += 1\nif j == len(S):\n    print(\"No\")\nelse:\n    print(\"Yes\")",
        "length": 17,
        "loc": 14
    },
    "abc349_d_54267102": {
        "buggy": "#D - Divide Interval\nl, r = map(int, input().split())\n\n#l = 3 \u306e\u6642\u3001(3,4)\u306e\u307f\n#l = 4\u306e\u6642\u3001 (4,5)(4,6)(4,8)\u304c\u3042\u308b\u306e\u3067(4,8)\u21904 = 2**2 (2**)\n#l = 8\u306e\u6642\u3001(8,9)(8,12)(8,16)\n#l = 16\u306e\u6642\u3001(16,17)(16,18)(16,20)(16,24)(16,32)\n#l + 0, l + 2**0, l + 2**1, l + 2**3, ...\n#l\u304c\u5947\u6570\u306e\u6642\u3001l + 2**0\u306e\u307f\n#l\u304c\u5076\u6570\u306e\u6642\u3001\n\nlis = []\nif l % 2 == 1:\n  lis.append([l])\n  l = l + 1\n\nwhile l != r:\n  i = 0\n  while l % pow(2, i+1) == 0 and l + pow(2, i+1) <= r:\n    i += 1\n  lis.append([l, l + pow(2, i)])\n  l += pow(2, i)\nprint(len(lis))\n\nfor k in range(len(lis)):\n  print(*(lis[k]))\n\n\n  \n\n",
        "length": 30,
        "loc": 14
    },
    "abc349_f_53462819": {
        "buggy": "def tridiv(n):\n    pf, f = dict(), 2\n    while f*f<=n:\n        if n%f == 0 :\n            if f not in pf : pf[f]=0\n            pf[f]+=1\n            n//=f\n        else : f = f+2 if f>2 else 3\n    if n>1 : \n        if n not in pf : pf[n]=0\n        pf[n]+=1\n    return [k**v for k,v in pf.items()]\nmod = 998244353\nN,M = map(int,input().split())\nA = [*map(int,input().split())]\nd = tridiv(M)\nK = len(d)\ncnt = [0]*(1<<K)\nfor n in range(N):\n    if M%A[n] : continue\n    cnt[sum(int(A[n]%d[k]==0)*(1<<k) for k in range(K))] += 1\ndp = [0 for n in range(1<<K)]\ndp[0] = 1\np2 = [pow(2,k,mod) for k in range(max(cnt)+1)]\nfor i in range(1<<K):\n    ndp = [0 for n in range(1<<K)]\n    for j in range(1<<K):\n        ndp[j] += dp[j]\n        ndp[j] %= mod\n        ndp[i|j] += dp[j]*(p2[cnt[i]]-1)\n        ndp[i|j] %= mod\n    dp = ndp\nprint(dp[(1<<K)-1])",
        "length": 33,
        "loc": 33
    },
    "abc350_a_54895381": {
        "buggy": "S = input()\ns = S[3:]\nn = int(s)\nif n > 349:\n  print(\"No\")\nelif n == 316:\n  print(\"No\")\nelse:\n  print(\"Yes\")",
        "length": 9,
        "loc": 6
    },
    "abc350_c_54963583": {
        "buggy": "import bisect\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport math\nimport operator\nimport string\nimport sys\n\nfrom atcoder.dsu import DSU\n\nreadline = sys.stdin.readline\nLS = lambda: readline().strip()\nLI = lambda: int(readline().strip())\nLLS = lambda: readline().strip().split()\nLL = lambda: list(map(int, readline().strip().split()))\nLLMI = lambda: list(map((1).__rsub__, LL()))\n\nn = LI()\nA = LLMI()\n\nuf = DSU(n)\nfor i, a in enumerate(A):\n    uf.merge(i, a)\n\ngroups = uf.groups()\nprint(n - len(groups))\nfor g in groups:\n    u = g[0]\n    for _ in range(len(g) - 1):\n        print(u + 1, A[u] + 1)\n        A[u], A[A[u]] = A[A[u]], A[u]\n",
        "length": 33,
        "loc": 33
    },
    "abc350_d_54866820": {
        "buggy": "from collections import defaultdict\nimport math\nimport sys\n\nsys.setrecursionlimit(790000)\n\n\nclass UnionFind:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.g = [[] for i in range(N)]\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        self.par[x] = self.root(self.par[x])\n\n        return self.par[x]\n\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx == ry:\n            return\n        self.par[rx] = ry\n        self.g[x].append(y)\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n\nn, m = map(int, input().split())\nunion = UnionFind(n)\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    union.unite(a, b)\n\nedge_nums = defaultdict(int)\nnode_nums = defaultdict(int)\nfor i in range(n):\n    edge_nums[union.root(i)] += len(union.g[i])\n    node_nums[union.root(i)] += 1\n\n\nresult = 0\nfor i in range(n):\n    result += math.comb(node_nums[i], 2) - edge_nums[i]\nprint(result)\n",
        "length": 50,
        "loc": 0
    },
    "abc351_b_54978591": {
        "buggy": "def find_differing_cell(N, A, B):\n  for i in range(N):\n      for j in range(N):\n          if A[i][j] != B[i][j]:\n           #print(i+1, j+1)\n            return (i + 1, j + 1)\n\nN=int(input())\nA = [['a' for x in range(N)] for y in range(N)] \nB = [['a' for x in range(N)] for y in range(N)] \n\nfor i in range(N):\n  ch = str(input())\n  for j in range(N):\n    A[i][j] = ch[j]\n    \nfor i in range(N):\n  ch = str(input())\n  for j in range(N):\n    B[i][j] = ch[j]\n\n#print(N,A,B)\nfind_differing_cell(N, A, B)",
        "length": 23,
        "loc": 5
    },
    "abc351_c_54968121": {
        "buggy": "from collections import deque\ndef solve_C():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    global dq\n    dq = deque()\n\n    def add(n):\n        global dq\n        if len(dq) == 0:\n            dq.append(n)\n            return\n        \n        most_left = dq.pop()\n        if n == most_left:\n            add(n+1)\n        else:\n            dq.append(most_left)\n            dq.append(n)\n            return\n    \n    i = 0\n    while i < n-1:\n        if a[i] == a[i+1] + 1 and a[n-1] == a[n-2]:\n            i += 1\n        else:\n            break\n    if i == n-2:\n        print(1)\n        return\n    \n    for num in a:\n        add(num)\n\n    print(len(dq))\n\nsolve_C()",
        "length": 38,
        "loc": 29
    },
    "abc352_a_54737577": {
        "buggy": "n, x, y, z = map(int, input().split())\n\nif x<z<y or y<z<x:\n  print(\"YES\")\nelse:\n  print(\"No\")",
        "length": 6,
        "loc": 4
    },
    "abc352_d_54879664": {
        "buggy": "from sortedcontainers import SortedList,SortedSet,SortedDict\n\nn,k = map(int,input().split())\np = list(map(int,input().split()))\ns = SortedList()\nidx = [0]*(n+1)\nfor i in range(n):\n    idx[p[i]] = i\nans = float('inf')\nfor i in range(1,n+1):\n    s.add(idx[i])\n    if len(s) > k:\n        s.discard(idx[i-k])\n        ans = min(ans,s[-1]-s[0])\nprint(ans)",
        "length": 15,
        "loc": 12
    },
    "abc353_a_54934846": {
        "buggy": "x=int(input())\ncont=0\ncad=[int(x) for x in input().split()]\nfor i in range(1,len(cad)):\n    if cad[0]<cad[i]:\n        print(i+1)\n        break\n    elif cad[0]>cad[i]:\n        cont+=1\nif len(cad)-1==cont:\n    print(-1)",
        "length": 11,
        "loc": 8
    },
    "abc353_d_54729259": {
        "buggy": "def prefix_sum(A) :\n  N = len(A)\n  res = [0 for i in range(N)]\n  res[0] = A[0]\n  for i in range(1, N) : res[i] = A[i] + res[i - 1]\n  return res\n\nN = int(input())\nA = list(map(int, input().split()))\nS = list(reversed(prefix_sum(list(reversed(A)))))\n\ndit = [10 ** len(str(A[i])) for i in range(N)]\nditsum = list(reversed(prefix_sum(list(reversed(dit)))))\n\nres = 0\nfor i in range(N - 1) :\n  res += A[i] * ditsum[i + 1] + S[i + 1]\nprint(res)",
        "length": 18,
        "loc": 8
    },
    "abc354_a_55104399": {
        "buggy": "h = int(input())\n\ncnt = 0\nplant = 0\nwhile plant < h:\n    plant = plant + 2**cnt\n    cnt += 1\n\nprint(cnt)",
        "length": 9,
        "loc": 3
    },
    "abc355_a_55137190": {
        "buggy": "A,B = (map(int,input().split()))\nif A==1 and B==2:\n    print(3)\nelif A==1 and B==3:\n    print(2)\nelif A==2 and B==1:\n    print(3)\nelif A==1 and B==2:\n    print(3)\nelif A==3 and B==2:\n    print(1)\nelif A==2 and B==3:\n    print(1)\nelse:\n    print(-1)",
        "length": 15,
        "loc": 4
    },
    "abc355_c_54869003": {
        "buggy": "n, t = map(int, input().split())\na = list(map(int, input().split()))\n\nr = {}\nc = {}\nd = {1: 0, 2: 0}\n\nans = -1\nfor l in range(t):\n    ai = a[l]\n    i = ai // n\n    j = ai % n\n    if j != 0:\n        if i+1 not in r:\n            r[i+1] = 1\n        else:\n            r[i+1] += 1\n        if r[i+1] == n:\n            ans = l + 1\n            break\n    else:\n        if i not in r:\n            r[i] = 1\n        else:\n            r[i] += 1\n        if r[i] == n:\n            ans = l + 1\n            break\n    if j != 0:\n        if j not in c:\n            c[j] = 1\n        else:\n            c[j] += 1\n        if c[j] == n:\n            ans = l + 1\n            break\n    else:\n        if n not in c:\n            c[n] = 1\n        else:\n            c[n] += 1\n        if c[n] == n:\n            ans = l + 1\n            break\n    if ai % (n+1) == 1:\n        d[1] += 1\n        if d[1] == n:\n            ans = l + 1\n            break\n    b = ai - n\n    if b % 2 == 0 and b // 2 >= 0 and b // 2 < n:\n        d[2] += 1\n        if d[2] == n:\n            ans = l + 1\n            break\n    # print(ans)\n\n# print(r)\n# print(c)\n# print(d)\n\nprint(ans)\n",
        "length": 62,
        "loc": 51
    },
    "abc355_d_54769975": {
        "buggy": "N = int(input())\nstarts = [0] * N\nends = [0] * N\n\nfor i in range(N):\n    start, end = map(int, input().split())\n    starts[i] = start\n    ends[i] = end\n\nstarts.sort(reverse = True)\nends.sort(reverse = True)\n\nn_active_intervals = 0\nn_overlaps = 0\nwhile starts:\n    if starts[-1] <= ends[-1]:\n        # print(f\"start at {starts[-1]}, {n_active_intervals} active\")\n        starts.pop()\n        n_overlaps += n_active_intervals\n        n_active_intervals += 1\n    else:\n        # print(f\"end at {ends[-1]},  {n_active_intervals-1} active\")\n        ends.pop()\n        n_active_intervals -= 1\n\nprint(n_active_intervals)",
        "length": 26,
        "loc": 26
    },
    "abc355_e_54311444": {
        "buggy": "import math\nimport re\nimport functools\nimport random\nimport sys\nimport os\nimport typing\nfrom math import gcd, comb, sqrt,isqrt,lcm\nfrom collections import Counter, defaultdict, deque\nfrom functools import lru_cache, reduce\nfrom itertools import accumulate, combinations, permutations\nfrom heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush\nfrom io import BytesIO, IOBase\nfrom copy import deepcopy\nimport threading\nfrom typing import *\nfrom bisect import bisect_left, bisect_right\nfrom types import GeneratorType\n\n# from sortedcontainers import  SortedList\n\nfrom operator import add\n\nBUFSIZE = 8192\n\n\ndef I():\n    return input()\n\n\ndef II():\n    return int(input())\n\n\ndef MII():\n    return map(int, input().split())\n\n\ndef LI():\n    return list(input().split())\n\n\ndef LII():\n    return list(map(int, input().split()))\n\n\ndef GMI():\n    return map(lambda x: int(x) - 1, input().split())\n\n\ndef LGMI():\n    return list(map(lambda x: int(x) - 1, input().split()))\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# 1000000000000002493\n\nmod = 998244353\ninf = 10 ** 15\n\n\ndef solve():\n    sn,l,r=MII()\n    n=2**sn\n    r+=1\n    d=[-1]*(n+1)\n    d[l]=0\n    dist=[-1]*(n+1)\n    q=deque([l])\n\n    while d[r]==-1:\n        x=q.popleft()\n        if x==0:\n            my=sn+1\n        else:\n            my=x.bit_length()\n        for ny in range(my):\n            y=2**ny\n            if x + y <= n and d[x + y] == -1:\n                d[x + y] = d[x] + 1\n                dist[x + y] = x\n                q.append(x + y)\n            if x - y >= 0 and d[x - y] == -1:\n                d[x - y] = d[x] + 1\n                dist[x - y] = x\n                q.append(x - y)\n\n\n\n    A=[r]\n    pos=r\n    while pos!=l:\n        A.append(dist[pos])\n        pos=A[-1]\n    A.pop()\n    pos=l\n    ans=0\n    for p in A[::-1]:\n        if p>pos:\n            d=p-pos\n            print(\"?\",d.bit_length()-1,pos//d,flush=True)\n            y=II()\n            ans=(ans+y)%100\n        else:\n            d=pos-p\n            print(\"?\", d.bit_length() - 1, p//d, flush=True)\n            y = II()\n            ans = (ans - y) % 100\n        pos=p\n    print('!',ans,flush=True)\n    return\n\n\n\n\n\n\nfor _ in range(1):\n    solve()",
        "length": 164,
        "loc": 121
    },
    "abc356_a_55030560": {
        "buggy": "n, l, r = map(int, input().split())\n\nstart_lis = [i for i in range(1, l)]\nmiddle_lis = list(reversed([i for i in range(l, r+1)]))\nfinal_lis = [i for i in range(r+1, n + 1)]\n\n# \u5404\u30ea\u30b9\u30c8\u3092\u30d5\u30e9\u30c3\u30c8\u5316\u3057\u30661\u3064\u306e\u30ea\u30b9\u30c8\u306b\u7d50\u5408\ncombined_lis = start_lis + middle_lis + final_lis\n\nprint(tuple(combined_lis))\n",
        "length": 10,
        "loc": 10
    },
    "abc356_b_54954884": {
        "buggy": "N, M=map(int, input().split())\ngoal=input().split()\nnutrition=[]\ncheck=[]\nfor i in range(N):\n  nutrition.append(input().split())\ndef sum_nut(N,nut_num,goal,check):\n  sum_n=[]\n  for i in range(N):\n    sum_n.append(int(nutrition[i][nut_num]))\n  if int(goal[nut_num])<sum(sum_n):\n    check.append(1)\n  else:\n    check.append(0)\nfor i in range(M):\n  sum_nut(N,i,goal,check)\nif sum(check)==M:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n",
        "length": 20,
        "loc": 11
    },
    "abc356_c_54900882": {
        "buggy": "N,M,K = map(int,input().split())\nC_List = []\nA_list_list = []\nR_list = []\nfor _ in range(M):\n    tmp = list(input().split())\n    C_List.append(int(tmp[0]))\n    R_list.append(tmp[-1])\n    tmp_a = tmp[1:-1]\n    tmp_a = list(map(int,tmp_a))\n    A_list_list.append(tmp_a)\n\nret = 0\nfor i in range(2**N + 1):\n    for A_list,r  in zip(A_list_list,R_list):\n        tmp = 0\n        for a in A_list:\n            a = a-1\n            if(i & 2**a):\n                tmp = tmp + 1\n        if(((tmp >= K) and (r == \"o\"))\n        or ((tmp < K) and (r == \"x\"))):\n            pass\n        else:\n            break\n    else:\n        ret = ret + 1\n\nprint(ret)",
        "length": 29,
        "loc": 14
    },
    "abc356_e_54889247": {
        "buggy": "#!/usr/bin/env python3\nimport math\nimport sys\nfrom bisect import (  # type: ignore\n    bisect,\n    bisect_left,\n    bisect_right,\n    insort,\n    insort_left,\n    insort_right,\n)\nfrom collections import Counter, defaultdict, deque  # type: ignore\nfrom heapq import (  # type: ignore\n    heapify,\n    heappop,\n    heappush,\n    heappushpop,\n    heapreplace,\n    merge,\n)\nfrom itertools import accumulate, combinations, permutations, product  # type: ignore\nfrom typing import Any, Generic, Iterable, Iterator, List, Optional, Tuple, TypeVar\n\nT = TypeVar(\"T\")\n\n# fmt: off\ndef InputI():  return int(sys.stdin.buffer.readline())\ndef InputIM(): return map(int, sys.stdin.buffer.readline().split())\ndef InputIL(): return list(map(int, sys.stdin.buffer.readline().split()))\n\ndef InputS():  return sys.stdin.buffer.readline().rstrip().decode(\"utf-8\")\ndef InputSS(): return sys.stdin.buffer.readline().rstrip().decode(\"utf-8\").split()\n\ndef InputIR(n):  return [InputI() for _ in range(n)]\ndef InputILR(n): return [InputIL() for _ in range(n)]\n\ndef InputSR(n):   return [InputS() for _ in range(n)]\ndef InputSSR(n):  return [InputSS() for _ in range(n)]\ndef InputSLR(n):  return [list(InputS()) for _ in range(n)]\ndef InputSLIR(n): return [[int(i) for i in list(InputS())] for _ in range(n)]\n\ninf = float(\"inf\")\nmod = 998244353\nMOD = 1000000007\nsys.setrecursionlimit(10 ** 7)\n# fmt: on\n\nN = InputI()\nA = InputIL()\nA.sort()\nle = [0] * (2*10**6+1)\nfor i in range(N):\n    le[A[i]] += 1\nfor i in range(1, 2*10**6+1):\n    le[i] += le[i-1]\ncnt_A = dict(Counter(A))\n\nans = 0\nfor key, value in cnt_A.items():\n    for alpha in range(1, A[-1]//key+1):\n        if alpha == 1:\n            ans += alpha * (le[(alpha+1)*key-1] - le[alpha*key])\n            ans += alpha * value * (value-1) // 2\n        else:\n            ans += alpha * (le[(alpha+1)*key-1] - le[alpha*key-1]) * value\nprint(ans)\n",
        "length": 66,
        "loc": 62
    },
    "abc357_a_55131574": {
        "buggy": "N,M = map(int, input().split())\nH = list(map(int, input().split()))\n\nfor i in range(N):\n    M = M-H[i]\n    if M == 0:\n        print(i+1)\n        break\n    if M < H[i]:\n        print(i)\n        break\n\nif M > 0:\n    print(N)",
        "length": 14,
        "loc": 9
    },
    "abc357_c_55043182": {
        "buggy": "n = int(input())\n\ncarp = [[\"#\"]]\nfor k in range(1, n + 1):\n    tmp = []\n    for _ in range(3):\n        for c in carp[k - 1]:\n            tmp.append(c * 3)\n\n    tmp = list(map(list, tmp))\n\n    cen = 3**k // 2\n    diff = 3 ** (k - 1) // 2\n    for i in range(3**k):\n        for j in range(3**k):\n            if cen - diff <= i <= cen + diff and cen - diff <= j <= cen + diff:\n                tmp[i][j] = \".\"\n    carp.append(tmp)\n\nfor c in carp[n]:\n    print(*c)\n",
        "length": 21,
        "loc": 21
    },
    "abc357_d_54944133": {
        "buggy": "import math\n\nMOD = 998244353\n\n\ndef main():\n    n = int(input())\n    k = math.floor(math.log10(n)) + 1\n    y = pow(10**k - 1, MOD - 2, MOD)\n    ans = ((n % MOD) * (pow(10, n * k, MOD) - 1) * y) % MOD\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "length": 15,
        "loc": 8
    },
    "abc357_e_54953956": {
        "buggy": "from atcoder.scc import*\nN,*A=map(int,open(0).read().split())\nG=SCCGraph(N)\nfor i in range(N):\n G.add_edge(i,A[i]-1)\nd=[0]*N\nfor g in G.scc()[::-1]:\n for v in g:d[v]=len(g)*-~d[A[g[0]]-1]\nprint(sum(d))",
        "length": 9,
        "loc": 8
    },
    "abc358_a_55146983": {
        "buggy": "S,T = input().split()\n\nif S == \"AtCorder\" and T == \"Land\":\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 6,
        "loc": 3
    },
    "abc358_b_55163067": {
        "buggy": "N,A =map(int,input().split())\nT = list(map(int,input().split()))\ntime = 0\n\nfor i in range(N):\n  time = max(time, T[i]) + A\nprint(time, end = ' ')",
        "length": 7,
        "loc": 7
    },
    "abc358_c_54954465": {
        "buggy": "from itertools import combinations\n\nN, M = list(map(int, input().split()))\nflavors_of_stands = []\nfor _ in range(N):\n    s = int(\"\".join(list(map(lambda x: '1' if x == 'o' else '0', input()))), base=2)\n    flavors_of_stands.append(s)\ntotal = 2 ** M - 1\nfor i in range(1, N):\n    all_cases = combinations(range(N), i)\n    for case in all_cases:\n        cur_ans = 0\n        for idx in case:\n            cur_ans |= flavors_of_stands[idx]\n        if cur_ans == total:\n            print(len(case))\n            exit(0)\n",
        "length": 17,
        "loc": 9
    },
    "abc358_d_55035534": {
        "buggy": "# \u5165\u529b\nnum_item, num_friend = input().split()\nnum_item, num_friend = int(num_item), int(num_friend)\nitem_data = sorted(list(map(int, input().split())))\nfriend_data = sorted(list(map(int, input().split())))\ncost = 0\nbuy_flg = True\nitem_idx = 0\nfriend_idx=0\nif item_data[-1] < friend_data[-1]:\n  buy_flg=False\nwhile friend_idx < num_friend:\n  if item_data[item_idx] >= friend_data[friend_idx]:\n    cost += item_data[item_idx]\n    friend_idx +=1\n  item_idx +=1\n  if item_idx >= num_item:\n    buy_flg=False\n    break\n\nif buy_flg:\n  print(cost)\nelse:\n  print(-1)",
        "length": 24,
        "loc": 17
    },
    "abc358_g_54886527": {
        "buggy": "from random import randint, shuffle\nfrom math import gcd, log2, log, sqrt, hypot, pi, degrees\nfrom fractions import Fraction\nfrom bisect import bisect_left, bisect_right\nfrom itertools import accumulate, permutations, combinations, product, chain, groupby\nfrom sortedcontainers import SortedList\nfrom collections import Counter, deque, defaultdict as ddict\nfrom heapq import heappush as push, heappop as pop\nfrom functools import reduce, lru_cache\nimport sys\ninput = sys.stdin.readline\ninf = 10**18\n\n\ndef read(dtype=int):\n    return list(map(dtype, input().split()))\n\n\nh, w, K = read()\nsi, sj = read()\nsi -= 1\nsj -= 1\na = [read() for _ in range(h)]\n\n\ndef valid(i, j):\n    return 0 <= i < h and 0 <= j < w\n\n\ndx = [1, -1, 0, 0, 0]\ndy = [0, 0, 1, -1, 0]\nans = 0\n\ndp = [[-inf] * w for _ in range(h)]\n\nc = min(h+w, K)\ndp[si][sj] = 0\n\nans = a[si][sj] * K\n\nfor i in range(1, c+1):\n    ndp = [[-inf] * w for _ in range(h)]\n    for x in range(h):\n        for y in range(w):\n            if dp[x][y] == -inf:\n                continue\n            for k in range(5):\n                u = x + dx[k]\n                v = y + dy[k]\n                if valid(u, v):\n                    ndp[u][v] = max(ndp[u][v], dp[x][y] + a[u][v])\n\n    dp = ndp\n    for x in range(h):\n        for y in range(w):\n            if dp[x][y] != -inf:\n                ans = max(ans, dp[x][y] + (K-i) * a[x][y])\n\nprint(ans)\n",
        "length": 59,
        "loc": 36
    },
    "abc359_b_55035410": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\nn = int(input().rstrip())\narr = list(map(int, input().rstrip().split()))\n\nres = 0\nfor i in range(n-2):\n  if arr[i+2] == arr[i]: res += 1\n\nprint(res)",
        "length": 11,
        "loc": 8
    },
    "abc359_c_55129367": {
        "buggy": "Sx, Sy = map(int, input().split())\nTx, Ty = map(int, input().split())\n\nSx -= (Sy - Sx) % 2\nTx -= (Ty - Tx) % 2\n\n\nTx -= Sx\nTy -= Sy\n\nTx = abs(Tx)\nTy = abs(Ty)\n\nprint(Ty + max(0, Tx - Ty) / 2)\n\n",
        "length": 15,
        "loc": 14
    },
    "abc359_f_54954031": {
        "buggy": "import heapq\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, combinations, permutations\nfrom heapq import heappop, heappush\nfrom math import inf\nsys.setrecursionlimit(10**6)\nMOD = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nn = ni()\nA = na()\n\n# is any distribution of 2*(n-1) degrees a valid tree?\n\nans = A[:]\nq = [(a*4,a,2,i) for i,a in enumerate(A)]\nheapq.heapify(q)\nfor _ in range(n-2):\n    k,a,p,i = heappop(q)\n    # print(k,a,p,i)\n    ans[i] = a*p*p\n    heappush(q,(a*(p+1)**2 - a*p**2,a,p+1,i))\nprint(sum(ans))\n",
        "length": 29,
        "loc": 22
    },
    "abc360_a_55149797": {
        "buggy": "S = input()\nfor i in range(len(S)):\n  if S[i] == 'R':\n    R_index = i\n  elif S[i] == 'S':\n    S_index = i\nif R_index < S_index:\n  print(\"Yes\")\nelse:\n  print(\"No\")",
        "length": 10,
        "loc": 5
    },
    "abc360_b_55142362": {
        "buggy": "import math\n\ns, t = input().split()\ns, t = s.strip(), t.strip()\n\nfor w in range(1,len(s)):\n    ss = [s[w*i:w*i+w] for i in range(math.ceil(len(s)/w))]\n    ss[-1] += \" \" * (len(s) % w)\n    x = [*zip(*ss)]\n    for n in x:\n        if t == \"\".join(n).strip():\n            print(\"Yes\")\n            exit(0)\nprint(\"No\")",
        "length": 14,
        "loc": 8
    },
    "abc360_c_55149622": {
        "buggy": "N = int(input())\nA = list(map(int,input().split()))\nW = list(map(int,input().split()))\nflg = [-1]*(N)\ncost = 0\nfor i in range(N):\n  if flg[A[i]-1] == -1:\n    flg[A[i]-1] = W[i]\n    continue\n  cost += min(flg[A[i]-1],W[i])\n  flg[A[i]-1] = min(flg[A[i]-1],W[i])\nprint(cost)",
        "length": 12,
        "loc": 11
    },
    "abc360_d_55144134": {
        "buggy": "n,t=[int(x) for x in input().split()]\ns=input()\nx=[int(x) for x in input().split()]\n\nx0=[]\nx1=[]\nfor i,s1 in enumerate(s):\n  if(s1==\"0\"):\n    x0.append(x[i])\n  else:\n    x1.append(x[i])\nnx0=len(x0)\nnx1=len(x1)\ni=0\nj=0\nans=0\n#print(x0)\n#print(x1)\nfor y in x1:\n  while(i<(nx0) and x0[i]<y):\n    i+=1\n  while(j<(nx0) and x0[j]<(y+2*t+0.1)):\n    j+=1\n  ans+=(j-i)\n  #print(ans,j,i)\nprint(ans)\n  ",
        "length": 27,
        "loc": 12
    },
    "agc057_a_35335100": {
        "buggy": "T = int(input())\nfor _ in range(T):\n    l,r = input().split()\n    l = int(l)\n    if r==\"1\":\n        print(0)\n    else:\n        if r[0]==\"1\":\n            a = int(r[:-1])\n            b = int(r[1:])\n            r0 = max(a,b)+1\n        else:\n            r0 = int(\"1\"+\"0\"*(len(r)-1))\n        r = int(r)\n        if l<=r0:\n            print(r-r0+1)\n        else:\n            print(r-l+1)",
        "length": 18,
        "loc": 6
    },
    "agc057_b_31499069": {
        "buggy": "from sre_constants import IN_IGNORE\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nINF = 2 ** 63 - 1\nmod = 998244353\nclass segtree():\n    n=1\n    size=1\n    log=2\n    d=[0]\n    op=None\n    e=10**15\n    def __init__(self,V,OP,E):\n        self.n=len(V)\n        self.op=OP\n        self.e=E\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        for i in range(self.n):\n            self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):\n            self.update(i)\n    def set(self,p,x):\n        assert 0<=p and p<self.n\n        p+=self.size\n        self.d[p]=x\n        for i in range(1,self.log+1):\n            self.update(p>>i)\n    def get(self,p):\n        assert 0<=p and p<self.n\n        return self.d[p+self.size]\n\n    def __setitem__(self, p, x):\n        self.set(p, x)\n    \n    def __getitem__(self, p):\n        return self.get(p)\n\n\n    def prod(self,l,r):\n        assert 0<=l and l<=r and r<=self.n\n        sml=self.e\n        smr=self.e\n        l+=self.size\n        r+=self.size\n        while(l<r):\n            if (l&1):\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if (r&1):\n                smr=self.op(self.d[r-1],smr)\n                r-=1\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n    \n    def all_prod(self):\n        return self.d[1]\n    def max_right(self,l,f):\n        assert 0<=l and l<=self.n\n        assert f(self.e)\n        if l==self.n:\n            return self.n\n        l+=self.size\n        sm=self.e\n        while(1):\n            while(l%2==0):\n                l>>=1\n            if not(f(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    l=2*l\n                    if f(self.op(sm,self.d[l])):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:\n                break\n        return self.n\n    def min_left(self,r,f):\n        assert 0<=r and r<self.n\n        assert f(self.e)\n        if r==0:\n            return 0\n        r+=self.size\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 & (r%2)):\n                r>>=1\n            if not(f(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    r=(2*r+1)\n                    if f(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r& -r)==r:\n                break\n        return 0\n    def update(self,k):\n        self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    def __str__(self):\n        return str([self.get(i) for i in range(self.n)])\n\n\n\nn, x = mi()\na = li()\n\na.sort(reverse=True)\nLR = []\n\ndef le(now, to, x):\n    ret = now\n    for i in range(60):\n        if now * (2 ** i) <= to:\n            ret = max(ret, min(to, now * (2 ** i) + x * (2 ** i - 1)))\n    return ret\n\ndef ge(now, to, x):\n    ret = INF\n    for i in range(60):\n        if now * (2 ** i) + x * (2 ** i - 1) >= to:\n            ret = min(ret, max(now * (2 ** i), to))\n    return ret\n\n\nfor i in range(1, n):\n    LR.append((le(a[i], a[0], x), ge(a[i], a[0], x)))\n\nLR.insert(0, (a[0], a[0]))\n\nLR.sort()\nl = [LR[i][1] for i in range(n)]\ns = [LR[i][0] for i in range(n)]\n\ny = min(max(l) - min(l), max(s) - min(s))\nrmax = 0\nfor i in range(n - 1):\n    rmax = max(LR[i][1], rmax)\n    y = min(y, rmax - LR[i + 1][0])\n\n\nif x < y:\n    print(y)\nelse:\n    print(0)\n",
        "length": 154,
        "loc": 151
    },
    "agc058_a_43275130": {
        "buggy": "N=int(input())\n#HA,WA=map(int,input().split())\nA=list(map(int,input().split()))\n#S=[(input(),i) for i in range(N)]\n\n\ndef solve():\n    K=0\n    ans=[]\n\n    for i in range(2*N-1):\n        if i%2==1: #should be A[i]>A[i+1]\n            if A[i]<A[i+1]:\n                if A[i]>A[i+2]:\n\n                    A[i],A[i+1]=A[i+1],A[i]\n                    ans.append(i+1)\n                else:\n                    A[i+1],A[i+2]=A[i+2],A[i+1]\n                    ans.append(i+2)\n                    \n                K+=1\n                \n\n        else:\n            if A[i]>A[i+1]:\n                if i==2*N-2 or A[i]>A[i+2]:\n                    A[i],A[i+1]=A[i+1],A[i]\n                    ans.append(i+1)\n                else:\n                    A[i+1],A[i+2]=A[i+2],A[i+1]\n                    ans.append(i+2)\n                \n                K+=1\n\n\n    print(K)\n    #print(A)\n    print(*ans)\n\nsolve()\n\n",
        "length": 42,
        "loc": 14
    },
    "agc059_a_37116120": {
        "buggy": "def solve(k):\n    if k <= 2:\n        return k\n    if k % 2 == 0:\n        return (k - 2) // 2 + 2\n    return (k - 1) // 2 + 1\n\n\nclass LazySegTree:\n    \"X \u00d7 G --> X\"\n    \"Fill in the brackets.\"\n    X_e = 0\n    G_e = X_e\n\n    @classmethod\n    def X_op(cls, x, y):\n        return x + y\n\n    @classmethod\n    def G_op(cls, a, b):\n        return cls.X_op(a, b)\n\n    @classmethod\n    def action(cls, x, a):\n        return cls.X_op(x, a)\n\n    \"Up to here.\"\n\n    def __init__(self, A):\n        self.N = len(A)\n        self.X = [self.X_e] * (2 * self.N)\n        self.G = [self.G_e] * (2 * self.N)\n        for i, x in enumerate(A, self.N):\n            self.X[i] = x\n        for i in range(self.N - 1, 0, -1):\n            self.X[i] = self.X_op(self.X[i << 1], self.X[i << 1 | 1])\n\n    def _eval_at(self, i):\n        return self.action(self.X[i], self.G[i])\n\n    def _propagate_at(self, i):\n        self.X[i] = self._eval_at(i)\n        self.G[i << 1] = self.G_op(self.G[i << 1], self.G[i])\n        self.G[i << 1 | 1] = self.G_op(self.G[i << 1 | 1], self.G[i])\n        self.G[i] = self.G_e\n\n    def _propagate_above(self, i):\n        H = i.bit_length() - 1\n        for h in range(H, 0, -1):\n            self._propagate_at(i >> h)\n\n    def _recalc_above(self, i):\n        while i > 1:\n            i >>= 1\n            self.X[i] = self.X_op(self._eval_at(i << 1), self._eval_at(i << 1 | 1))\n\n    def __iter__(self):\n        for i in range(self.N):\n            yield self.X[self.N + i]\n\n    def __getitem__(self, i):\n        i %= self.N\n        return self.X[self.N + i]\n\n    def __setitem__(self, i, x):\n        i %= self.N\n        i += self.N\n        self._propagate_above(i)\n        self.X[i] = x\n        self.G[i] = self.G_e\n        self._recalc_above(i)\n\n    def prod(self, L, R):\n        L += self.N\n        R += self.N\n        self._propagate_above(L // (L & -L))\n        self._propagate_above(R // (R & -R) - 1)\n        vL = self.X_e\n        vR = self.X_e\n        while L < R:\n            if L & 1:\n                vL = self.X_op(vL, self._eval_at(L))\n                L += 1\n            if R & 1:\n                R -= 1\n                vR = self.X_op(self._eval_at(R), vR)\n            L >>= 1\n            R >>= 1\n        return self.X_op(vL, vR)\n\n    def ranged_act(self, L, R, a):\n        L += self.N\n        R += self.N\n        L0 = L // (L & -L)\n        R0 = R // (R & -R) - 1\n        self._propagate_above(L0)\n        self._propagate_above(R0)\n        while L < R:\n            if L & 1:\n                self.G[L] = self.G_op(self.G[L], a)\n                L += 1\n            if R & 1:\n                R -= 1\n                self.G[R] = self.G_op(self.G[R], a)\n            L >>= 1\n            R >>= 1\n        self._recalc_above(L0)\n        self._recalc_above(R0)\n\n    def __repr__(self):\n        for i in range(self.N, 2 * self.N):\n            self._propagate_above(i)\n            self.X[i] = self._eval_at(i)\n        return str(self.X[self.N:])\n\n\nN, Q = map(int, input().split())\nS = input()\nseg = LazySegTree([0] * N)\nfor i in range(N - 1):\n    s, t = S[i], S[i + 1]\n    if s != t:\n        seg[i + 1] = 1\nprint(seg)\nfor _ in range(Q):\n    L, R = map(int, input().split())\n    s, t = S[L - 1], S[R - 1]\n    k = seg.prod(L, R - 1 + 1)\n    if s == t:\n        k = max(k - 1, 0)\n    print(solve(k))\n\n",
        "length": 132,
        "loc": 124
    },
    "agc062_a_43035982": {
        "buggy": "t=int(input())\nfor i in range(t):\n  n=int(input())\n  s=list(map(str,input()))\n  cnt=0\n  for i in range(n-1):\n    if s[i]==\"A\" and s[i+1]==\"B\":\n      cnt+=1\n  if cnt==0 and s[0]==\"B\" and s[-1]==\"B\":\n    print(\"B\")\n  elif cnt==1 and s[0]==\"A\":\n    print(\"B\")\n  else:\n    print(\"A\")",
        "length": 14,
        "loc": 11
    },
    "agc063_a_44148214": {
        "buggy": "n=int(input())\nl=list(input())\n\nlacnt=[]\nlbcnt=[]\na=0\nb=0\nfor i in l:\n  if i == \"A\":\n    a += 1\n  if i == \"B\":\n    b += 1\n  lacnt.append(a)\n  lbcnt.append(b)\n\nfor i in range(1,n+1):\n  if lacnt[i] >= lbcnt[i]:\n    print(\"Arice\")\n  else:\n    print(\"Bob\")\n",
        "length": 20,
        "loc": 18
    },
    "arc129_a_38752586": {
        "buggy": "n,l,r = map(int,input().split())\nn_l = [0]*(n.bit_length())\nfor i in range(n.bit_length()):\n    if n >> i & 1:\n        n_l[i] = 1\nl_d = l.bit_length()\nr_d = r.bit_length()\nl_l = [0]*(l_d)\nr_l = [0]*(r_d)\nfor i in range(l_d):\n    if l >> i & 1:\n        l_l[i] = 1\nfor i in range(r_d):\n    if r >> i & 1:\n        r_l[i] = 1\nif n < l:\n    print(0)\n    exit()\nans = 0\npower = [1]\nfor i in range(min(len(n_l),r_d)):\n    power.append(2*power[-1])\nfor i in range(min(len(n_l),r_d)):\n    if n_l[i] == 1:\n        ans += min(power[i+1]-1,r)-max(power[i],l)+1\nprint(ans)",
        "length": 26,
        "loc": 25
    },
    "arc129_b_36921100": {
        "buggy": "n=int(input())\nA=0\nB=10**12\nfor q in range(n):\n    a,b=map(int,input().split())\n    A=max(A,a)\n    B=min(B,b)\n    print(max(B-A+1,0))   ",
        "length": 8,
        "loc": 8
    },
    "arc129_c_39744798": {
        "buggy": "from collections import deque\nli=[i*(i+1)//2 for i in range(1,2000)]\nN=int(input())\nans=[]\nnow=N\nfor j in range(1998,-1,-1):\n  for k in range(now//li[j]):  \n    ans.append(j+1)\n  now%=li[j]\nfin_ans=deque()\nfor ai in ans:\n  for _ in range(ai):\n    fin_ans.appendleft(\"7\")\n  fin_ans.appendleft(str((3*len(fin_ans)-3)%7))\nprint(\"\".join(fin_ans))",
        "length": 15,
        "loc": 14
    },
    "arc130_f_27582246": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nA=list(map(int,input().split()))\n\ndef calc(l,r):\n    x=abs(A[r]-A[l])\n    q=x//(r-l)\n    rr=x%(r-l)\n    \n    if A[l]<A[r]:\n        for i in range(r-l):              \n            if (r-(l+i))<=rr-1:\n                A[l+i]=min(A[l+i],rr-(r-(l+i))+A[l]+q*i)\n            else:\n                A[l+i]=min(A[l+i],A[l]+q*i)\n                \n                \n    else:\n        for i in range(r-l):\n            if ((r-i)-l)<=rr-1:\n                A[r-i]=min(A[r-i],rr-((r-i)-l)+A[r]+q*i)\n            else:\n                A[r-i]=min(A[r-i],A[r]+q*i)\n\nfor tests in range(10):\n\n    X=[(i,A[i]) for i in range(N)]\n\n    Q=[]\n    for i,a in X:\n        if len(Q)<=1:\n            Q.append((i,a))\n        else:\n            while len(Q)>=2:\n                i1,k1=Q[-1]\n                i2,k2=Q[-2]\n\n                if (k1-k2)*(i-i2)>(a-k2)*(i1-i2):\n                    Q.pop()\n                else:\n                    break\n                \n            Q.append((i,a))\n\n    for i in range(len(Q)-1):\n        calc(Q[i][0],Q[i+1][0])\n\nprint(sum(A))",
        "length": 50,
        "loc": 27
    },
    "arc131_a_42235783": {
        "buggy": "A = int(input())\nB = int(input())\nif B%2==1:\n    B *= 10\nC = B//2\n\n# A = list(str(A))\n# print(A)\nD = len(str(C))\nprint(A*(10**D)+C)",
        "length": 10,
        "loc": 9
    },
    "arc131_b_38447849": {
        "buggy": "def main():\n  H, W = map(int, input().split())\n  C = []\n  for i in range(H):\n    C.append(list(input()))\n  for i in range(H):\n    for j in range(W):\n      if C[i][j] != \".\": continue\n      d = set([\"1\",\"2\",\"3\",\"4\",\"5\"])\n      if i > 0: d.discard(C[i-1][j])\n      if j > 0: d.discard(C[i][j-1])\n      if i < H-1: d.discard(C[i+1][j])\n      if j > W-1: d.discard(C[i][j+1])\n      C[i][j] = d.pop()\n  for i in range(H):\n    print(\"\".join(C[i]))\n  \nif __name__ == '__main__':\n  main()",
        "length": 19,
        "loc": 13
    },
    "arc131_c_40380616": {
        "buggy": "import sys\ninput = sys.stdin.readline\ninf = float('inf')\n\n\ndef read(dtype=int):\n    return list(map(dtype, input().split()))\n\n\nn = int(input())\na = read()\nc = 0\nfor i in a:\n    c ^= i\nfor j in range(30):\n    if all(i >> j & 1 for i in a):\n        print(\"Win\")\n        exit()\n\nprint(\"Win\" if n == 1 or n == 3 or c in a else \"Lose\")\n",
        "length": 20,
        "loc": 20
    },
    "arc132_b_40788624": {
        "buggy": "n=int(input())\np=list(map(int,input().split()))\n\nif p[0]==1:\n  ans=0\nelif p[0]<p[1]:\n  ans=min(n-p[0]+1,2+p[0]-1)\nelse:\n  ans=min(p[0]+1,n-p[0]+1)\nprint(ans)",
        "length": 10,
        "loc": 4
    },
    "arc133_a_42236836": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\n\ntmp = A[0]\nfor i in range(1, N):\n    if tmp > A[i]: continue\n    tmp = A[i]\n\nfor i in A:\n    if i != tmp:\n        print(i, end=\" \")\n\nprint()\n",
        "length": 13,
        "loc": 6
    },
    "arc134_d_33208299": {
        "buggy": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nINF = 2 ** 63 - 1\nmod = 998244353\n\nn = ii()\n\na = li()\n\na1 = a[:n]\na2 = a[n:]\n\np = min(a1)\nt =[]\nind = -1\nfor i in range(n):\n    if a1[i] == p:\n        t.append((a1[i], a2[i]))\n        ind = i\nif sorted(t)[0][1] <= p:\n    print(*sorted(t)[0])\nelse:\n    ans1 = []\n    ans2 = []\n    for v1, v2 in t:\n        ans1.append(v1)\n        ans2.append(v2)\n    p = []\n    for i in range(ind + 1, n):\n        if a1[i] < ans2[0]:\n            p.append((a1[i], i))\n    p.sort()\n    nowi = ind\n\n    for v, i in p:\n        if nowi < i:\n            ans1.append(a1[i])\n            ans2.append(a2[i])\n    \n    ans = ans1 + ans2\n    ans1 = []\n    ans2 = []\n    for v1, v2 in t:\n        ans1.append(v1)\n        ans2.append(v2)\n    p = []\n    for i in range(ind + 1, n):\n        if a1[i] <= ans2[0]:\n            p.append((a1[i], i))\n    p.sort()\n    nowi = ind\n\n    for v, i in p:\n        if nowi < i:\n            ans1.append(a1[i])\n            ans2.append(a2[i])\n    \n    ans = min(ans, ans1 + ans2)\n    print(*ans)\n",
        "length": 62,
        "loc": 42
    },
    "arc135_a_43694743": {
        "buggy": "import sys, math, itertools, heapq, copy, collections, bisect, random, time\nfrom collections import deque, defaultdict, Counter\nfrom decimal import Decimal\nfrom functools import lru_cache\n\n\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\ndef MI1(): return map(lambda x:int(x)-1, sys.stdin.buffer.readline().split())\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef SL(): return list(sys.stdin.buffer.readline().rstrip().decode('utf-8'))\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\ndef SLR(n): return [SL() for _ in range(n)]\n\ndef resolve():\n    X = 10**18\n    mod = 998244353\n    @lru_cache(maxsize=None)\n    def dfs(now):\n        if now <= 4:\n            return now\n        return dfs((now//2))*dfs(((now+1)//2))%mod\n    print(dfs(X))\n\n\n\nif __name__ == \"__main__\":\n    resolve()\n\n",
        "length": 33,
        "loc": 20
    },
    "arc135_b_39932705": {
        "buggy": "\ndef main():\n    from math import sqrt,sin,cos,tan,ceil,radians,floor,gcd,exp,log,log10,log2,factorial,fsum\n    from heapq import heapify, heappop, heappush\n    from bisect import bisect_left, bisect_right\n    from copy import deepcopy\n    import copy\n    import random\n    from collections import deque,Counter,defaultdict\n    from itertools import permutations,combinations\n    from decimal import Decimal,ROUND_HALF_UP\n    #tmp = Decimal(mid).quantize(Decimal('0'), rounding=ROUND_HALF_UP)\n    from functools import lru_cache, reduce\n    #@lru_cache(maxsize=None)\n    from operator import add,sub,mul,xor,and_,or_,itemgetter\n    INF = 10**18\n    mod1 = 10**9+7\n    mod2 = 998244353\n    \n    #Decimal\u306a\u3089Python\n    \n    \n    '''\n    \n    \n    \n    '''\n    \n    N = int(input())\n    S = list(map(int, input().split()))\n    \n    X = [0]*(N+2)\n    \n    # X[i+3] = X[i]+S[i+1]-S[i]\n    for i in range(N-1):\n        X[i+3] = X[i]+S[i+1]-S[i]\n    \n    #\u30de\u30a4\u30ca\u30b9\u306b\u306a\u3063\u3066\u308b\u3084\u3064\u3092\u8abf\u3079\u308b\n    a = 0\n    b = 0\n    c = 0\n    for i in range(N+2):\n        if i%3 == 0:\n            a = min(a, X[i])\n        elif i%3 == 1:\n            b = min(b,X[i])\n        else:\n            c = min(c,X[i])\n    \n    for i in range(N+2):\n        if i%3 == 0:\n            X[i] += -a\n        elif i%3 == 1:\n            X[i] += -b\n        else:\n            X[i] += -c\n    \n    if X[0]+X[1]+X[2]<=S[0]:\n        ab = S[0]-X[1]-X[2]\n        for i in range(0,N+2,3):\n            X[i] += ab\n        \n        print('Yes')\n        print(*X)\n    else:\n        print('No')\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == '__main__':\n    main()",
        "length": 104,
        "loc": 59
    },
    "arc135_c_41836593": {
        "buggy": "N=int(input())\nA=list(map(int,input().split()))\nv=[0]*30\nfor i in range(N):\n  x=A[i]\n  for k in range(30):\n    if (x>>k)&1:\n      v[k]+=1\nresult=sum(A)\ny=result\nfor i in range(N):\n  w=0\n  x=A[i]\n  for k in range(k):\n    if (x>>k)&1:\n      w-=v[k]*2**k\n      w+=(N-v[k])*2**k\n  result=max(result,y+w)\nprint(result)",
        "length": 19,
        "loc": 14
    },
    "arc136_a_43450838": {
        "buggy": "N = int(input())\nS = input()\nd = S.split(\"C\")\nd = [\"A\" * p.count(\"A\") + \"B\" * p.count(\"B\") for p in d]\nprint(\"C\".join(d))",
        "length": 5,
        "loc": 4
    },
    "arc136_d_42996075": {
        "buggy": "N = int(input())\nA = list(map(int, input().split()))\n\ncount = [0 for _ in range(10**6)]\nfor i in range(N):\n    count[A[i]] += 1\n\nbinary_list = []\nbinary_sum = []\nfor i in range(64):\n    b = []\n    for j in range(6):\n        b.append((i>>j)&1)\n        binary_list.append((i>>j)&1)\n    binary_sum.append((sum(b)%2)==1)\n\none_to_sixty_four = list(range(1,64))\n\ncount_rect = [0 for _ in [0]*(11**6)]\npowers = [11**k for k in range(6)]\n\nfor i in range(10**6):\n    q = count[i]\n    p = i\n    b = [-1,-1,-1,-1,-1,-1]\n    for j in [0,1,2,3,4,5]:\n        b[j] = p%10+1\n        p //= 10\n    c = 0\n    for k in [0,1,2,3,4,5]:\n        c += b[k] * powers[k]\n    for j in one_to_sixty_four:\n        d = c\n        for k in [0,1,2,3,4,5]:\n            d -= binary_list[j*6+k]*powers[k]\n        if binary_sum[j]:\n            q += count_rect[d]\n            #print(f\"added count_rect[{d}]: {count_rect[d]}\")\n        else:\n            q -= count_rect[d]\n            #print(f\"subtracted count_rect[{d}]: {count_rect[d]}\")\n    count_rect[c] = q\n    #print(i, c, count[i], count_rect[c])\n\n\nans = 0\nfor a in A:\n    p = a\n    b = [-1,-1,-1,-1,-1,-1]\n    check = True\n    for j in [0,1,2,3,4,5]:\n        b[j] = 10-p%10\n        if b[j]<=4:\n            check = False\n        p //= 10\n    \n    c = 0\n    for k in [0,1,2,3,4,5]:\n        c += b[k] * powers[k]   \n\n    #print(b, c, count_rect[c])\n    ans += count_rect[c]\n    if check:\n        ans -= 1\nprint(ans//2)",
        "length": 65,
        "loc": 1
    },
    "arc137_a_45348542": {
        "buggy": "import math\nl,r=map(int,input().split())\nk=0\nwhile True:\n  flag=False\n  for i in range(k):\n    r2=r-i\n    l2=l+k-i\n    if math.gcd(l2,r2)==1:\n      flag=True\n  if flag:\n    print (r-l-k)\n    exit()\n  k+=1\n",
        "length": 14,
        "loc": 6
    },
    "arc137_b_44650081": {
        "buggy": "n=int(input())\na=list(map(int,input().split()))\nt=[]\nfor i in a:\n    if len(t)==0 or t[-1][0]!=i:\n        t.append([i,1])\n    else:\n        t[-1][1]+=1\nmx0=0\nmx1=0\nc0=0\nc1=1\nind0=0\nind1=0\nfor i in range(n):\n    c0=max(c0,0)\n    c1=max(c1,0)\n    if a[i]==0:\n        c0+=1\n        c1-=1\n    else:\n        c1+=1\n        c0-=1\n    mx0=max(mx0,c0)\n    mx1=max(mx1,c1)\nprint(mx0+mx1+1)",
        "length": 26,
        "loc": 12
    },
    "arc137_c_30259633": {
        "buggy": "N = int(input())\nA = list(map(int,input().split()))\nif A[N-1]-A[N-2] >=2:\n    print(\"Alice\")\n    exit()\nif N%2 == A[N-1]%2:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")",
        "length": 9,
        "loc": 6
    },
    "arc138_b_45602873": {
        "buggy": "n=int(input())\na=list(map(int,input().split()))\nl=0\nwhile l<n:\n  if a[l]^(l&1):\n    l+=1\n  else:\n    break\nr=0\na+=[0]\nfor i in range(l,n):\n  r+=a[i]^a[i+1]\nprint (\"Yes\" if l>=r else \"No\")",
        "length": 13,
        "loc": 5
    },
    "arc138_c_31278965": {
        "buggy": "import sys\n\nn=int(input())\na=list(map(int,input().split()))\nsa=sorted(a)\nans=0\nfor i in range(n//2,n):\n\tans+=sa[i]\nmed,s,id,mins,c=sa[n//2-1],0,0,n,0\nfor i,x in enumerate(a):\n\tif x<=med and c*2<n:\n\t\ts+=1\n\t\tc+=1\n\telse:\n\t\ts-=1\n\tif s<mins:\n\t\tid,mins=i,s\nprint(id+1,ans)\n",
        "length": 18,
        "loc": 18
    },
    "arc138_d_30830027": {
        "buggy": "import math\n\ndef map_int(s):\n    try:\n        return list(map(int, s.split()))\n    except ValueError:\n        return s.strip().split()\n\ndef main():\n    (n,k), = [map_int(s) for s in open(0)]\n    s = set()\n    for i in range(2 ** n):\n        j = i\n        t = 0\n        while i:\n            t += i % 2\n            i >>= 1\n        if t == k:\n            s.add(j)\n    ans = [0]\n    for i in range(n):\n        if len(s) == 0:\n            print(-1)\n            return\n        for ss in s:\n            break\n        t = ans[-1] ^ ss\n        for a in ans[:1 << i]:\n            at = a ^ t\n            if at in s:\n                s.remove(at)\n            ans.append(at)\n    print('Yes')\n    print(*ans)\n    \n\nif __name__ == '__main__':\n    main()",
        "length": 38,
        "loc": 23
    },
    "arc139_b_35647235": {
        "buggy": "T=int(input())\nfor i in range(T):\n  N,A,B,X,Y,Z=map(int, input().split())\n  Y,Z=min(Y,A*X),min(Z,B*X)\n  if Y/A>X/B:\n    Y,Z,A,B=Z,Y,B,A\n  ans=10**20\n  if N//A<2*A:\n    for a in range(N//A+1):\n      c=Y*a+Z*((N-A*a)//B)+X*((N-A*a)%B)\n      ans=min(c,ans)\n    print(ans)\n  else:\n    for b in range(A):\n      c=Z*b+Y*((N-B*b)//A)+X*((N-B*b)%A)\n      if N-B*b<0:\n        break\n      ans=min(c,ans)\n    print(ans)",
        "length": 19,
        "loc": 5
    },
    "arc139_c_31249723": {
        "buggy": "n, m = map(int, input().split())\nab = []\nnexts = list(range(8))\nfor a in range(n + 3 * m):\n    br = (3 * a) % 8\n    b = nexts[br]\n    mn = max((a + 2) // 3, 3 * a - 8 * m + 1)\n    mx = min(3 * a, (a + 8 * n - 1) // 3)\n    if mn > mx:\n        continue\n    if b < mn:\n        b += (mn - br + 7) // 8 * 8\n    if b <= mx:\n        ab.append((a, b))\n        nexts[br] = b + 8\nprint(len(ab))\nfor a, b in ab:\n    x, y = (-a + 3 * b) // 8, (3 * a - b) // 8\n    print(x + 1, y + 1)",
        "length": 19,
        "loc": 12
    },
    "arc140_a_45466035": {
        "buggy": "import sys\n\nsys.setrecursionlimit(10**9)\n\n\ndef main():\n    N, K = map(int, input().split())\n    S = input()\n\n    for i in range(1, N + 1):\n        D = [[0 for _ in range(26)] for _ in range(i)]\n        T = [0 for _ in range(i)]\n\n        for j, s in enumerate(S):\n            D[j % i][ord(s) - ord(\"a\")] += 1\n            T[j % i] += 1\n\n        k = 0\n        for l, d in enumerate(D):\n            d.sort(reverse=True)\n            k += T[l] - d[0]\n\n        if k <= K:\n            print(i)\n            return\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "length": 29,
        "loc": 11
    },
    "arc140_b_45660608": {
        "buggy": "from sortedcontainers import SortedList\nn=int(input())\ns=[*input()]\ncnts=[]\ni=0\nwhile i<n:\n    if s[i]==\"R\":\n        for j in range(1,n+5):\n            if i-j<0 or s[i-j]!='A':\n                cnta=j-1\n                break\n        for j in range(1,n+5):\n            if i+j>=n or s[i+j]!='C':\n                cntc=j-1\n                break\n        i+=cnta\n        if min(cnta,cntc)!=0:\n            cnts.append(min(cnta,cntc))\n    i+=1\nstl=SortedList(cnts)\nans=0\nwhile stl:\n    tmp=stl.pop()\n    if tmp-1!=0:stl.add(tmp-1)\n    ans+=1\n    if not stl:break\n    stl.pop(0)\n    ans+=1\nprint(ans)",
        "length": 29,
        "loc": 16
    },
    "arc140_c_38250831": {
        "buggy": "from collections import deque\n\n\nN, X = map(int, input().split())\n\nans = []\nQ = deque()\nfor i in range(N):\n    if i + 1 != X:\n        Q.append(i + 1)\n\nfor i in range(N - 1):\n    if i % 2 != (X - N // 2) % 2:\n        ans.append(Q.pop())\n    else:\n        ans.append(Q.popleft())\nans.append(X)\nprint(*ans[::-1])",
        "length": 18,
        "loc": 13
    },
    "arc141_a_41469868": {
        "buggy": "T = int(input())\n\nfor _ in range(T):\n    case = input()\n    length = len(case)\n    \n    max_val = 0\n    \n    for i in range(1, length):\n        if length % i == 0:\n            \n            tmp = case[:i]\n            tmp = \"\".join(tmp)\n            \n            val1 = int(tmp*(length//i))\n            val2 = int(str(int(tmp)-1)*(length//i))\n            \n            if int(case) >= val1:\n                max_val = max(max_val, val1)\n                          \n            if int(case) >= val2:\n                max_val = max(max_val, val2)\n            \n            \n    print(max_val)",
        "length": 25,
        "loc": 7
    },
    "arc141_b_40574832": {
        "buggy": "n,m=map(int,input().split())\nbinm=bin(m)[2:]\nif n>len(binm):\n    print(0)\n    exit()\nnum=[0]*len(binm)\nnum[-1]=m-(1<<(len(binm)-1))+1\nfor i in range(len(binm)-1):\n    num[i]=1<<i\ndp=[[0]*len(binm) for i in range(n)]\ndp[0]=num\nfor i in range(n-1):\n    for j in range(len(binm)):\n        for k in range(j+1,len(binm)):\n            dp[i+1][k]+=dp[i][j]*num[k]\n            dp[i+1][k]%=998244353\nprint(sum(dp[-1])%988244353)",
        "length": 17,
        "loc": 17
    },
    "arc142_a_44613596": {
        "buggy": "def solve(N, K):\n    def rev(x):\n        return int(''.join(reversed(list(str(x)))))\n    \n    def cnt(x):\n        res = 0\n        while x <= N:\n            res += 1\n            x *= 10\n        \n        return res\n    \n    if K % 10 == 0:\n        return 0\n\n    if K > rev(K):\n        return 0\n\n    return cnt(K) + cnt(rev(K))\n\nN, K = map(int, input().split())\nprint(solve(N, K))",
        "length": 22,
        "loc": 4
    },
    "arc142_b_44212876": {
        "buggy": "N = int(input())\nS,T = [], []\nfor i in range(N):\n    if i % 2 == 1:\n        S.append([i*N+x+1 for x in range(N)])\n    else:\n        T.append([i*N+x+1 for x in range(N)])\n\n\nfor s, t in zip(S,T):\n    print(*s)\n    print(*t)",
        "length": 12,
        "loc": 13
    },
    "arc142_c_43034425": {
        "buggy": "N = int(input())\nG = []\nG1 = [0 for i in range(N+1)]\nfor u in range(3,N+1):\n  print('?',1,u)\n  d = int(input())\n  G1[u] = d\n\nG2 = [0 for i in range(N+1)]\nfor u in range(3,N+1):\n  print('?',2,u)\n  d = int(input())\n  G2[u] = d\n  \n  \n\nd = 10**9\nfor u in range(3,N+1):\n  dd = G1[u] + G2[u]\n  d = min(d,dd)\nif d == 3:\n  X = []\n  for u in range(3,N+1):\n    if G1[u] + G2[u] == 3:\n      X.append(u)\n  if len(X) != 2:\n    d = 1\n  else:\n    u,v = X[0],X[1]\n    print('?',u,v)\n    dd = input()\n    if dd != 1:\n      d = 1\nprint('!',d)\nexit()",
        "length": 35,
        "loc": 31
    },
    "arc143_c_33642213": {
        "buggy": "N,X,Y,*A=map(int,open(0).read().split());f=0;s=[\"Second\",\"First\"]\nfor a in A:\n    if a%(X+Y)>=max(X,Y):f=1\n    elif a%(X+Y)>=min(X,Y):print([X<Y]);exit()\nprint(s[f])",
        "length": 5,
        "loc": 4
    },
    "arc144_a_42090105": {
        "buggy": "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n\ndef main():\n    N = int(readline())\n\n    print(2 * N)\n\n    ans = '4' * (N // 4)\n\n    if N % 4:\n        ans += str(N % 4)\n    \n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n",
        "length": 22,
        "loc": 16
    },
    "arc144_b_37994644": {
        "buggy": "N,a,b=map(int,input().split())\nA=list(map(int,input().split()))\ndef is_ok(mid):\n    lcnt=0\n    hcnt=0\n    for i in A:\n        if mid>i:\n            if (mid-i)%a==0:\n                lcnt+=(mid-i)//a\n            else:\n                lcnt+=(mid-i)//a+1\n        else:\n            hcnt+=(i-mid)//b\n    if lcnt<=hcnt:\n        return True\n    else:\n        return False\n                \ndef binary_search(ok, ng):\n    \"\"\"\u4e8c\u5206\u63a2\u7d22\n\n    Parameters\n    ----------\n    ok : int\n    ng : int\n\n    Returns\n    -------\n    ok : int\n    \"\"\"\n    while abs(ng - ok) > 1:\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return (ok+ng)//2\nprint(binary_search(1,10**9))",
        "length": 38,
        "loc": 38
    },
    "arc145_a_45555747": {
        "buggy": "N = int(input())\nS = input()\n\nif S[0] == \"B\" and S[-1] == \"A\":\n    print(\"No\")\nelif S == \"BA\":\n    print(\"No\")\nelse:\n    print(\"Yes\")\n",
        "length": 9,
        "loc": 4
    },
    "arc145_b_44115404": {
        "buggy": "n, a, b = map(int, input().split())\n\n\ndef f(x):\n    return x // a * min(a, b) + min(n % a, b - 1)\n\n\nprint(max(f(n) - f(a - 1), 0))\n",
        "length": 8,
        "loc": 5
    },
    "arc145_d_34720181": {
        "buggy": "import sys\n#input = sys.stdin.readline\n#input = sys.stdin.buffer.readline #\u6587\u5b57\u5217\u306f\u30c0\u30e1\n#sys.setrecursionlimit(1000000)\nimport math\n#import bisect\n#import itertools\n#import random\n#from heapq import heapify, heappop, heappush\n#from collections import defaultdict \n#from collections import deque\n#import copy #DeepCopy: hoge = [_[:] for _ in hogehoge]\n#from functools import lru_cache\n#@lru_cache(maxsize=None)\n#MOD = pow(10,9) + 7\nMOD = 998244353\n#dx = [1,0,-1,0]\n#dy = [0,1,0,-1]\n#dx8 = [1,1,0,-1,-1,-1,0,1]\n#dy8 = [0,1,1,1,0,-1,-1,-1]\n\ndef two_three(x):\n    L = []\n    while x > 0:\n        L.append(x%3)\n        x //= 3\n    L = set(L)\n    if 2 in L:\n        return False\n    else:\n        return True\n\ndef main():\n    N,M = map(int,input().split()); MAX = pow(10,7)\n    num = 0\n    val = 1\n    total = 0\n    ans = []\n    while num < N:\n        if two_three(val):\n            ans.append(val*3)\n            total += val*3 #\u3053\u3053\u30673\u500d\u3057\u3066\u304a\u304f\u3053\u3068\u30673\u9032\u6570\u3068\u3057\u305f\u3068\u304d\u306e1\u6841\u76ee\u3092\u5e38\u306b0\u3068\u3057\u3066\u5f8c\u3067\u8abf\u6574\u53ef\u80fd\u3068\u3059\u308b\u3002\n            num += 1\n        val += 1\n    # print(ans)\n\n    idx = 0\n    while total%N != 0:\n        ans[idx] += 1\n        idx += 1\n        total += 1\n    \n    # print(ans)\n    dif = (total - M)//N\n    ans = [v - dif for v in ans]\n    print(*ans)\n\n\nif __name__ == '__main__':\n    main()",
        "length": 60,
        "loc": 48
    },
    "arc147_b_45545981": {
        "buggy": "N = int(input())\nP = list(map(int, input().split()))\nA = list(range(1,N+1))\nans = []\nB = [[] for _ in range(2)]\nfor i, p in enumerate(P):\n    if (p - i) % 2 == 0:\n        B[i % 2].append(i)\nfor i in range(len(B[0])):\n    b0, b1 = B[0][i], B[1][i]\n    if b0 > b1:\n        b0, b1 = b1, b0\n    while b0 + 1 < b1:\n        ans.append((\"B\", b1 - 2))\n        P[b1 - 2], P[b1] = P[b1], P[b1 - 2]\n        b1 -= 2\n    ans.append((\"A\", b0 + 1))\n    P[b0], P[b0 + 1] = P[b0 + 1], P[b0]\n\ndef e_sort():\n    flag = False\n    for i in range(0, N - 2, 2):\n        if P[i] > P[i + 2]:\n            P[i], P[i + 2] = P[i + 2], P[i]\n            ans.append((\"B\", i + 1))\n            flag = True\n    return flag\n\ndef o_sort():\n    flag = False\n    for i in range(1, N - 2, 2):\n        if P[i] > P[i + 2]:\n            P[i], P[i + 2] = P[i + 2], P[i]\n            ans.append((\"B\", i + 1))\n            flag = True\n    return flag\n\nos = True\nes = True\nwhile P != A:\n    if es:\n        es = e_sort()\n    if os:\n        os = o_sort()\n\nprint(len(ans))\nfor a in ans:\n    print(*a)\n",
        "length": 48,
        "loc": 14
    },
    "arc148_b_43029081": {
        "buggy": "n = int(input())\nS = input()\n\ndef f(T):\n    U = [c for c in reversed(T)]\n    for i in range(len(U)):\n        U[i] = 'd' if U[i] == 'p' else 'p'\n    return ''.join(U)\n\nl = 0\nwhile l < n and S[l] != 'd':\n    l += 1\n\nans = S\nfor r in range(l+1, n+1):\n    ans = min(ans, S[:l] + f(S[l:r]) + S[r:])\nprint(ans)",
        "length": 17,
        "loc": 11
    },
    "arc148_d_34805310": {
        "buggy": "from collections import Counter\nn, m = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\nfor i in range(n * 2):\n    a[i] = a[i] * 2 % m\na.sort()\nx = 0\nfor i in range(0, n * 2, 2):\n    if a[i] != a[i + 1]:\n        print('Alice')\n        break\n    x += a[i]\nelse:\n    if x == s:\n        print('Bob')\n    else:\n        print('Alice')",
        "length": 18,
        "loc": 15
    },
    "arc150_a_42990587": {
        "buggy": "import sys\nfrom collections import Counter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n\nT = int(readline())\nfor _ in range(T):\n    N, K = map(int, readline().split())\n    S = readline().rstrip()\n    S += '*'\n\n    cnt_one = S.count('1')\n    C = Counter(S[:K])\n    cnt = 0\n\n    for i in range(N - K):\n        if C['1'] == cnt_one and C['0'] == 0:\n            cnt += 1\n\n        C[S[i]] -= 1\n        C[S[i + K]] += 1\n    \n    if cnt == 1:\n        print('Yes')\n    else:\n        print('No')\n",
        "length": 29,
        "loc": 19
    },
    "arc150_b_43756504": {
        "buggy": "import bisect, heapq, sys, math, copy, itertools, decimal\nfrom collections import defaultdict, deque\nsys.setrecursionlimit(10**7)\ndef INT(): return int(input())\ndef MI(): return map(int, input().split())\ndef MS(): return map(str, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LS(): return list(map(str, input().split()))\ndef pr_line(itr): print(*itr, sep='\\n')\ndef pr_mtx(matrix): [print(*row) for row in matrix] \nINF = 1<<62\n\n\nT = INT()\nANS = []\nfor _ in range(T):\n    A, B = MI()\n    Nset = set()\n    for i in range(1, B+1):\n        if i ** 2 > B: break\n        Nset.add(i)\n        Nset.add(math.ceil(B / i))\n    \n    ans = INF\n    for n in Nset:\n        k = math.ceil(B / n)\n        x = max(0, math.ceil(B / k) - A)\n        y = (A + x) * k - B\n        ans = min(ans, x + y)\n        ANS.append(ans)\npr_line(ANS)",
        "length": 31,
        "loc": 30
    },
    "arc151_a_45098095": {
        "buggy": "import sys\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input().rstrip()\ndef mii(): return map(int, input().split())\ndef fii(): return map(float, input().split())\ndef mii1(): return map(lambda x: int(x)-1, input().split())\n\ndef lii(): return list(map(int, input().split()))\ndef lii1(): return list(map(lambda x: int(x)-1, input().split()))\ndef lfi(): return list(map(float, input().split()))\ndef lsi(): return list(input().rstrip())\ndef lmsi(): return list(map(str, input().split()))\n\ndef iir(n): return [int(input()) for _ in range(n)]\ndef fir(n): return [float(input()) for _ in range(n)]\ndef sir(n): return [input().rstrip() for _ in range(n)]\n\ndef liir(n): return [list(map(int, input().split())) for _ in range(n)]\ndef lii1r(n): return [list(map(lambda x: int(x)-1, input().split())) for _ in range(n)]\ndef lfir(n): return [list(map(float, input().split())) for _ in range(n)]\ndef lsir(n): return [list(input().rstrip()) for _ in range(n)]\ndef lmsir(n): return [list(map(str, input().split())) for _ in range(n)]\n\ndef lii_alp(): return list(map(lambda x: ord(x)-97, input().rstrip()))\ndef lii_ALP(): return list(map(lambda x: ord(x)-65, input().rstrip()))\naround = [[-1,0],[0,1],[1,0],[0,-1]]\n# module\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right, insort\nfrom heapq import heapify, heappop, heappush\nfrom math import ceil, floor, gcd, sin, cos, radians, log, sqrt\nfrom itertools import product, combinations, permutations, accumulate, groupby\nfrom decimal import Decimal, ROUND_HALF_UP\nsys.setrecursionlimit(10**7)\n\n# import pypyjit\n# pypyjit.set_param('max_unroll_recursion=-1')\n# [[key,len(list(group))] for key, group in groupby(A)]\n\n# your code\n\nN = ii()\nS = si()\nT = si()\ndiff = set([i for i in range(N) if S[i]!=T[i]])\n\nif len(diff)&1:\n  print(-1)\nelse:\n  U = []\n  balance = 0\n  flag = 0\n  for i in range(N):\n    if i in diff:\n      if balance == len(diff):\n        U.append(T[i])\n        balance -= 1\n      elif -balance == len(diff):\n        U.append(S[i])\n        balance += 1\n      else:\n        U.append(\"0\")\n        balance += (-1)**(S[i]!=\"0\")\n      diff.remove(i)\n    else:\n      U.append(S[i])\n    # print(balance)\n    \n  print(\"\".join(U))",
        "length": 71,
        "loc": 68
    },
    "arc151_c_36785462": {
        "buggy": "n,m = map(int,input().split())\nxy = [list(map(int,input().split())) for i in range(m)]\ng = 0\nif m == 0:\n  if n%2:\n    print(\"Takahashi\")\n  else:\n    print(\"Aoki\")\n  exit()\nfor i in range(m+1):\n  if i == 0:\n    x,y = xy[i]\n    g ^= x-1\n  elif i == m:\n    x,y = xy[i-1]\n    g ^= n-x\n  else:\n    x,y = xy[i]\n    px,py = xy[i-1]\n    if y != py:\n      continue\n    g ^= x-px-2\n\nif g:\n  print(\"Takahashi\")\nelse:\n  print(\"Aoki\")",
        "length": 27,
        "loc": 22
    },
    "arc152_a_42092015": {
        "buggy": "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n\ndef main():\n    N, L, *A = map(int, read().split())\n\n    no_more_two = False\n\n    for a in A:\n        \n\n        if a == 1:\n            L -= 2\n        else:\n            L -= 3\n        \n        if L <= 0:\n            no_more_two = True\n\n\n        if no_more_two and a == 2 and L != -1:\n            print('No')\n            break\n    \n    else:\n        print('Yes')\n\n\nif __name__ == '__main__':\n    main()\n",
        "length": 34,
        "loc": 25
    },
    "arc153_b_44454861": {
        "buggy": "h,w=map(int,input().split())\nc=[input() for _ in range(h)]\n\nq=int(input())\n\nrh=0\nsh=1\nrw=0\nsw=1\n\nfor _ in range(q):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  if rh<=a:\n    rh=a-rh\n  else:\n    rh=h-(rh-a)\n  if sh<=a:\n    sh=a-sh\n  else:\n    sh=w-(sh-a)\n  if rw<=b:\n    rw=b-rw\n  else:\n    rw=w-(rw-b)\n  if sw<=b:\n    sw=b-sw\n  else:\n    sw=w-(sw-b)\n    \nansh=[0]*h\nansw=[0]*w\n\nx=sh-rh\ny=sw-rw\n\nfor i in range(h):\n  ansh[rh]=i\n  rh+=x\n  rh%=h\n  \nfor i in range(w):\n  answ[rw]=i\n  rw+=y\n  rw%=w\n\n  \nans=[[0]*w for _ in range(h)]\n\nfor i in range(h):\n  for j in range(w):\n    ans[i][j]=c[ansh[i]][answ[j]]\n\n  \nfor i in ans:\n  print(''.join(i))",
        "length": 57,
        "loc": 22
    },
    "arc153_c_41497158": {
        "buggy": "n = int(input())\na = list(map(int,input().split()))\nimos = [0]*(n+1)\nfor i in range(n):\n  imos[0] += a[i]\n  imos[i+1] -= a[i]\nfor i in range(n):\n  imos[i+1] += imos[i]\nans = [0]*n\nif imos[0] != 0:\n  r = 0\n  for i in range(1,n):\n    r += imos[i]*abs(imos[0])\n    ans[i] = abs(imos[0])\n  ans[0] = -r//imos[0]\n  for i in range(n-1):\n    ans[i+1] += ans[i]\n  print(\"Yes\")\n  print(*ans,sep=' ')\n  cal = 0\n  for i in range(n):\n    cal += a[i]*ans[i]\nelse:\n  x,y = -1,-1\n  s = 0\n  flag = True\n  for i in range(n):\n    if imos[i] > 0:\n      flag = False\n  if flag:\n    print(\"No\")\n    exit()\n  flag = True\n  for i in range(n):\n    if imos[i] < 0:\n      flag = False\n  if flag:\n    print(\"No\")\n    exit()\n  for i in range(1,n):\n    s += imos[i]\n    if imos[i] == -1 and x == -1:\n      x = i\n    elif imos[i] == 1:\n      y = i\n  ans = [0]*n\n  if s >= 0:\n    for i in range(n):\n      if i == x:\n        ans[i] = 1+s\n      else:\n        ans[i] = 1\n  else:\n    for i in range(n):\n      if i == y:\n        ans[i] = 1-s\n      else:\n        ans[i] = 1\n  for i in range(n-1):\n    ans[i] += ans[i]\n  print(\"Yes\")\n  print(*ans,sep=' ')",
        "length": 62,
        "loc": 60
    },
    "arc154_c_38909905": {
        "buggy": "import sys\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n  N = int(input())\n  a = list(map(int, input().split()))\n  b = list(map(int, input().split()))\n\n  sa = set(a)\n  sb = set(b)\n  if sa | sb != sa:\n    print(\"No\")\n    continue\n\n  la = [a[0]]\n  lb = [b[0]]\n  for i in range(1, N):\n    if la[-1] != a[i]: la.append(a[i])\n    if lb[-1] != b[i]: lb.append(b[i])\n\n\n  if sa == sb and len(sa) == N:\n    if a == b:\n      print(\"Yes\")\n    else:\n      print(\"No\")\n    continue\n\n  if len(la) == N and len(lb) == N and la[0] != la[-1]:\n    if a == b:\n      print(\"Yes\")\n    else:\n      print(\"No\")\n    continue\n\n  for l in range(N):\n    la = [a[l]]\n    for i in range(1, N):\n      if la[-1] != a[(i + l) % N]: la.append(a[(i + l) % N])\n\n    i = 0\n    #print(la, lb)\n    for j in range(len(lb)):\n      if i > len(la): break\n      f = 0\n      while i <= len(la):\n        if la[i % len(la)] == lb[j]:\n          i += 1\n          f = 1\n          break\n        i += 1\n      #print(i, j, f)\n      if f == 0: break\n    else:\n      print(\"Yes\")\n      break\n  else:\n    print(\"No\")",
        "length": 58,
        "loc": 29
    },
    "arc155_a_40182881": {
        "buggy": "def main():\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        S = list(input())\n        if K < N:\n            L1 = S + S[:K][::-1]\n            L2 = S[:K][::-1] + S\n            for i in range(N+K):\n                if L1[i] != L1[-i-1] or L2[i] != L2[-i-1]:\n                    break\n            else:\n                print(\"Yes\")\n                continue\n            print(\"No\")\n            continue\n        l = N\n        for i in range(1, N+1):\n            if not N % i == 0:\n                continue\n            for j in range(N // i):\n                if j % 2 == 1:\n                    for k in range(i):\n                        \n                        if S[i*(j+1)-k-1] != S[k]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    for k in range(i):\n                        \n                        if S[i*j + k] != S[k]:\n                            break\n                    else:\n                        continue\n                    break\n            else:\n                l = min(l, i)\n                break\n        if (N+K) % (2*l) == 0:\n            print(\"Yes\")\n            continue\n        elif (N+k) % l == 0:\n            for i in range(l):\n                if S[i] != S[l-i-1]:\n                    break\n            else:\n                print(\"Yes\")\n                continue\n            print(\"No\")\n            continue\n        else:\n            print(\"No\")\n            continue\n\n\n\nif __name__ == \"__main__\":\n    main()",
        "length": 60,
        "loc": 44
    },
    "arc156_b_45544495": {
        "buggy": "n,k=map(int,input().split())\na=list(map(int,input().split()))\nfrom collections import defaultdict as df\nd=df(int)\nfor i in range(n):\n  d[a[i]]+=1\nmex=[0]*(k+1)\nnow=0\nfor i in range(k+1):\n  while d[now]>0:\n    now+=1\n  mex[i]=now\n  now+=1\nans=0\nfib=[1]*(n+k)\nmod=998244353\nfor i in range(n+k-1):\n  fib[i+1]=fib[i]*(i+2)%mod\ndef comb(a,b):\n  if b<=0:\n    return 1\n  elif a<b:\n    return 0\n  return fib[a-1]*pow(fib[a-b-1],-1,mod)%mod*pow(fib[b-1],-1,mod)%mod\nans=0\nfor i in range(k+1):\n  ans+=comb(mex[i]+k-i-1,k-i)\n  ans%=mod\nprint(ans)",
        "length": 29,
        "loc": 24
    },
    "arc157_a_45521757": {
        "buggy": "N, A, B, C, D = map(int, input().split())\n\nif abs(B - C) > 1:\n    print(\"No\")\n    exit()\nelif B == C:\n    if B == 0:\n        if A > 0 and D == 0:\n            if N == A + 1:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        elif A == 0 and D > 0:\n            if N == D + 1:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        elif A == 0 and D == 0:\n            if N == 0:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        if B * 2 + 1 + A + D == N:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nelse:\n    if max(B, C) * 2 + A + D == N:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n    ",
        "length": 37,
        "loc": 19
    },
    "arc157_b_43416351": {
        "buggy": "N,K = map(int,input().split())\nS = input()\nX = S.count(\"X\")\nif X < K:\n    K = N-K\n    T = []\n    for s in S:\n        if s == \"X\":\n            T.append(\"Y\")\n        else:\n            T.append(\"X\")\n    S = T\n\nif all(s == \"X\" for s in S):\n    print(K-1)\n    exit()\n\nC = [10**6]\n\nstate = 0\ncnt = 0\n\nans = 0\nfor i in range(1,N):\n    if state == 0:\n        if S[i-1] == \"Y\" and S[i] == \"X\":\n            cnt = 1\n            state = 1\n    else:\n        if S[i-1] == \"X\" and S[i] == \"Y\":\n            C.append(cnt)\n            state = 0\n            cnt = 0\n        else:\n            cnt += 1\n\n    if S[i-1] == \"Y\" and S[i] == \"Y\":\n        ans += 1\n\n\nC.sort()\nfor c in C:\n    if K >= c:\n        ans += c+1\n        K -= c\n    else:\n        ans += K\n        break\n\nprint(ans)",
        "length": 50,
        "loc": 15
    },
    "arc158_a_43216127": {
        "buggy": "T = int(input())\n\nfor i in range(T):\n    x1, x2, x3 = map(int, input().split())\n    S = x1+x2+x3\n    if S % 3 == 0:\n        D = abs(S//3-x1) + abs(S//3-x2) + abs(S//3-x3)\n        print(D//4)\n    else:\n        print(-1)\n",
        "length": 10,
        "loc": 6
    },
    "arc158_b_45744284": {
        "buggy": "from itertools import combinations\n\ndef solve():\n    N = int(input())\n    xs = map(int, input().split())\n    a = sorted(v for v in xs if v > 0)\n    b = sorted(v for v in xs if v < 0)\n    c = a[:3] + a[3:][-3:] + b[:3] + b[3:][-3:]\n    \n    mx, mi = -float('inf'), float('inf')\n    for x, y, z in combinations(c, 3):\n        t = (x+y+z)/(x*y*z)\n        mi = min(mi, t)\n        mx = max(mx, t)\n      \n    print(mi)\n    print(mx)\n  \nsolve()",
        "length": 19,
        "loc": 5
    },
    "arc159_a_43796233": {
        "buggy": "from collections import deque\n\nn,k=map(int,input().split())\n\na=[list(map(int,input().split())) for _ in range(n)]\n\nq=int(input())\n\ndef root(s,t):\n  d=deque([(s,0)])\n  check=[0]*n\n  if s==t:\n    cnt=0\n    while d:\n      if cnt%100==0:\n        print(cnt)\n      cnt+=1\n      v,w=d.popleft()\n      for i in range(n):\n        if a[v][i]==1:\n          if i==t:\n            return(w+1)\n          if check[i]==0:\n            check[i]=1\n            d.append((i,w+1))\n    return -1\n  else:\n    while d:\n      v,w=d.popleft()\n      check[v]=1\n      for i in range(n):\n        if a[v][i]==1:\n          if i==t:\n            return(w+1)\n          if check[i]==0:\n            check[i]=1\n            d.append((i,w+1))\n    return -1\n  \n\nfor i in range(q):\n  s,t=map(int,input().split())\n  s-=1\n  t-=1\n  s%=n\n  t%=n\n  print(root(s,t))",
        "length": 47,
        "loc": 0
    },
    "arc159_b_45431609": {
        "buggy": "import math\n\na, b = map(int, input().split())\nif a < b:\n    a, b = b, a\nans = 0\nwhile b > 0:\n    g = math.gcd(a, b)\n    a //= g\n    b //= g\n    diff = a - b\n    if diff == 1:\n        ans += b\n        break\n    else:\n        m = float(\"inf\")\n        for i in range(1, int(diff**0.5) + 1):\n            if diff % i == 0:\n                if i != 1:\n                    m = min(m, b % i)\n                m = min(m, b % (diff // i))\n        a -= m\n        b -= m\n        ans += m\nprint(ans)\n",
        "length": 25,
        "loc": 12
    },
    "arc159_c_40556226": {
        "buggy": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nINF = 2**63-1\nmod = 998244353\nimport random\nn = ii()\n\na = li()\n\ndef solve(n, a, p):\n    ans = []\n    for i in range(random.randint(0, p)):\n        p = list(range(1, n + 1))\n        random.shuffle(p)\n        ans.append(p)\n        for j in range(n):\n            a[j] += p[j]\n    for i in range(10 ** 4):\n        if sum(a) % n == 0:\n            break\n        p = list(range(1, n + 1))\n        random.shuffle(p)\n        ans.append(list(range(1, n + 1)))\n        for j in range(n):\n            a[j] += p[j]\n    else:\n        return []\n\n    def add(i):\n        p = list(range(1, n + 1))\n        p[i], p[i+1] = p[i+1], p[i]\n        ans.append(p)\n        p = list(range(1, n + 1))\n        q = p[::-1]\n        ans.append(q)\n        a[i] += 1\n        a[i + 1] -= 1\n\n    def sub(i):\n        p = list(range(1, n + 1))\n        ans.append(p)\n        q = p[::-1]\n        q[i], q[i + 1] = q[i + 1], q[i]\n        ans.append(q)\n        a[i] -= 1\n        a[i + 1] += 1\n\n    ave = sum(a) // n\n\n    for i in range(n):\n        a[i] -= ave\n    for i in range(n - 1):\n        while a[i] > 0:\n            sub(i)\n        while a[i] < 0:\n            add(i)\n\n    if max(a) == min(a) == 0 and len(ans) <= 10 ** 4:\n        return ans\n    else:\n        return []\n\n\nfor p in range(14):\n    ans = solve(n, a[::], p * 10)\n    if len(ans) > 0:\n        print('Yes')\n        print(len(ans))\n        for v in ans:\n            print(*v)\n        exit()\nprint('No')",
        "length": 75,
        "loc": 26
    },
    "arc160_a_43403535": {
        "buggy": "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nind = [0] * N\nfor i in range(N):\n    ind[A[i] - 1] = i\n\ndef re(l, r):\n    if r < N - 1:\n        return A[:l] + list(reversed(A[l:r + 1])) + A[r + 1:]\n    elif r == N - 1:\n        return A[:l] + list(reversed(A[l:r + 1]))\n    \ncount = 0\nflag = True\nvisit = set()\nfor j in range(N): #j+1\u6841\u76ee\u3092\u307f\u308b\n    for i in range(N): #j+1\u6841\u76ee\u304c i \u306b\u306a\u308b\u500b\u6570\n        if i in visit:\n            continue\n        if ind[i] == j:\n            count += (((N - 2 - j) * (N - j - 1)) // 2)\n            count += N\n        else:\n            count += 1\n            if count == K:\n                print(*re(j, ind[i]))\n                exit()\n        #print(count, j + 1, i + 1)\n        if count > K:\n            count -= (((N - 2 - j) * (N - j - 1)) // 2)\n            count -= N\n            visit.add(i)\n            break",
        "length": 34,
        "loc": 29
    },
    "arc160_b_41448583": {
        "buggy": "import math\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    num = int(math.sqrt(N)+1e-9)\n    ans = num ** 3\n    for y in range(1, num):\n        num_x = y\n        num_z = N // y - num\n        ans += (num_x-1) * num_z * 6 + num_z*3\n        ans %= 998244353        \n    print(ans)",
        "length": 12,
        "loc": 7
    },
    "arc160_c_42877627": {
        "buggy": "from math import log2\nfrom collections import Counter\n\nimport sys\nn, *alists = map(int, sys.stdin.read().split())\n\nMOD = 998244353 \n\nif n == 1:\n    print(1)\n    exit()\n\nmaxlen = max(alists) + int(log2(n))\n\nli = [0] * (maxlen + 1)\n\nco = Counter(list(alists))\n\nfor k,v in co.items():\n    li[k] += v\n\ndp = [1]\n\nfor i in range(1,maxlen):\n    newdp = [0] * ((li[i] + len(dp))//2+2 )\n    \n    for j, dpi in enumerate(dp):\n        newdp[0] += dpi\n        newdp[(li[i]+j)//2+1] -= dpi\n        # print(i,j,newdp)\n    \n    newdp[0] %= MOD\n\n    for k in range(len(newdp)-1):\n        newdp[k+1] += newdp[k]\n        newdp[k+1] %= MOD\n    # print(newdp)\n    dp = newdp\n\nprint(sum(dp))",
        "length": 40,
        "loc": 40
    },
    "arc161_a_45669630": {
        "buggy": "N=int(input())\nA=list(map(int,input().split()))\nA.sort()\nif N==1:\n    print(\"Yes\")\n    exit()\nB=[0]*N\nfor i in range(N):\n    if i<=N//2:\n        B[2*i]=A[i]\n    else:\n        B[2*i-N]=A[i]\nfor i in range(N):\n    if i%2!=0:\n        continue\n    if B[i-1]<B[i] and B[i]>B[i+1]:\n        continue\n    else:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")",
        "length": 22,
        "loc": 14
    },
    "arc161_b_45311674": {
        "buggy": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    if N < 7:\n        print(-1)\n        continue\n    cnt = bin(N).count('1')\n    if cnt == 1:\n        print((N>>1) + (N>>2) + (N>>3))\n    elif cnt == 2:\n        if N & 1 or N & 2:\n            print((N>>1) + (N>>2) + (N>>3))\n        else:\n            s = 0\n            while N & (1<<s) == 0:\n                s += 1\n            print(N - (1<<s) + (1<<(s-1)) + (1<<(s-2)))\n    else:\n        tmp = 0\n        for i in range(60):\n            if cnt - tmp == 3:\n                break\n            if N & (1<<i):\n                N ^= 1<<i\n                tmp += 1\n        print(N)",
        "length": 26,
        "loc": 12
    },
    "arc161_d_44101361": {
        "buggy": "# import sys\n# sys.setrecursionlimit(10**7)\n# input = sys.stdin.readline\n# import pypyjit\n# pypyjit.set_param('max_unroll_recursion=-1')\ndef mp():return map(int,input().split())\ndef lmp():return list(map(int,input().split()))\ndef lm1(LIST): return list(map(lambda x:x-1, LIST))\ndef mps(A):return [tuple(map(int, input().split())) for _ in range(A)]\ndef stoi(LIST):return list(map(int,LIST))\ndef itos(LIST):return list(map(str,LIST))\ndef atoi(LIST): return [ord(i)-ord(\"a\") for i in LIST]\ndef Atoi(LIST): return [ord(i)-ord(\"A\") for i in LIST]\ndef LT(LIST,N): return LIST[bisect.bisect_left(LIST,N)-1]\ndef LE(LIST,N): return LIST[bisect.bisect_right(LIST,N)-1]\ndef GT(LIST,N): return LIST[bisect.bisect_right(LIST,N)]\ndef GE(LIST,N): return LIST[bisect.bisect_left(LIST,N)]\ndef bitA(X,A):return X & 1<<A == 1<<A\nimport math\nimport bisect\nimport heapq\nimport time\nfrom copy import copy as cc\nfrom copy import deepcopy as dc\nfrom itertools import accumulate, product\nfrom collections import Counter, defaultdict, deque\ndef ceil(U,V):return (U+V-1)//V\ndef modf1(N,MOD):return (N-1)%MOD+1\ninf = (1<<63)-1\nmod = 998244353\n\nn,d = mp()\nif n*(n-1)//2 < n*d:\n    print(\"No\")\n    exit()\nprint(\"Yes\")\nfor i in range(1,d+1):\n    for j in range(1,n+1):\n        print(j,modf1(j+d,n))\n\n\n",
        "length": 41,
        "loc": 39
    },
    "arc162_b_44215494": {
        "buggy": "n = int(input())\np = list(map(lambda x:int(x)-1,input().split()))\nans = []\nfor i in range(n-2):\n    if p[i] == i:\n        continue\n    for j in range(i+1,n):\n        if p[j] == i:\n            break\n    if j != n-1:\n        ans.append([j+1,i])\n        p = p[:i]+p[j:j+2]+p[i:j]+p[j+2:]\n    else:\n        ans.append([n-1,n-3])\n        ans.append([n-1,i+1])\n        p = p[:i]+[p[-1],p[-3]]+p[i:-3]+[p[-2]]\nif p[-1] == n-1:\n    print('Yes')\n    print(len(ans))\n    for i in range(len(ans)):\n        print(*ans[i])\nelse:\n    print('No')",
        "length": 23,
        "loc": 15
    },
    "arc162_c_43008956": {
        "buggy": "import sys\nsys.setrecursionlimit(1000000)\n\nt = int(input())\n\ndef dfs(x):\n    for y in edges[x]:\n        dfs(y)\n        sizes[x] += sizes[y]\n        nums[x] += nums[y]\n    sizes[x] += 1\n    nums[x].append(A[x])\n\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    P = [-1]+list(map(lambda x: int(x)-1, input().split()))\n    edges = [[] for _ in range(n)]\n    for i in range(1, n):\n        edges[P[i]].append(i)\n    A = list(map(int, input().split()))\n\n    sizes = [0]*n\n    nums = [[] for _ in range(n)]\n    dfs(0)\n\n    for i in range(n):\n        x = nums[i].count(-1)\n        s = set(nums[i])\n        if k in s:\n            continue\n        y = 0\n        mex = k\n        for j in range(k):\n            if j not in s:\n                y += 1\n                if mex == k:\n                    mex = j\n            \n        if (x==1 and y==1) or (mex==k and x==0):\n            print(\"Alice\")\n            break\n    else:\n        print(\"Bob\")",
        "length": 44,
        "loc": 39
    },
    "arc163_a_45954819": {
        "buggy": "T = int(input())\ndef compare(t1, t2):\n    length = min(len(t1), len(t2))\n    for i in range(length):\n        if t1[i] > t2[i]:\n            return False\n        if t1[i] < t2[i]:\n            return True\n    if len(t1) > len(t2):\n        return False\n    else:\n        return True\n\nfor i in range(T):\n    N = int(input())\n    S = input()\n    flag = False\n    for i in range(1, N):\n        tem1 = S[:i]\n        tem2 = S[i:]\n        if compare(tem1, tem2):\n            flag = True\n            break\n    if not flag:\n        print(\"No\")\n    else:\n        print(\"Yes\")",
        "length": 27,
        "loc": 9
    },
    "arc163_b_44451318": {
        "buggy": "n,m=map(int,input().split())\nA=list(map(int,input().split()))\nli=list(sorted(A[2:]))\nans=10**18\nfor i in range(2,n-m+1): \n  ans=min(ans,max(0,A[0]-A[i])+max(0,A[i+m-1]-A[1]))\nprint(ans)",
        "length": 7,
        "loc": 5
    },
    "arc163_c_45533123": {
        "buggy": "def solve(N):\n    if N == 1:\n        return [1]\n    if N == 2:\n        return None\n\n    ans = [2]\n    used = set([3, 6])\n    for _ in range(N - 3):\n        for v in list(used):\n            if v + 1 not in used and v * (v + 1) not in used:\n                used.discard(v)\n                used.add(v + 1)\n                used.add(v * v + v)\n                break\n\n    return [2] + list(used)\n\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        N = int(input())\n        ans = solve(N)\n        if ans is None:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n            print(*ans)\n\n\nmain()\n",
        "length": 32,
        "loc": 11
    },
    "arc164_a_45705547": {
        "buggy": "def recur(n):\n    x=0\n    for i in range(28,-1,-1):\n        p=pow(3,i)\n        x += n // p\n        n-=p*(n//p)\n\n    return x\n\n\n\n\ndef solve():\n    n,k=map(int,input().split())\n    x=recur(n)\n    if x>k or k%2!=n%2:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n    \n\nfor i in range(int(input())):\n    solve()",
        "length": 23,
        "loc": 3
    },
    "arc164_c_45053848": {
        "buggy": "N = int(input())\na = [list(map(int, input().split())) for _ in range(N)]\na.sort(key=lambda x: abs(x[0]-x[1]))\n\ncnt = 0\nfor i in range(N):\n    if a[i][0] > a[i][1]:\n        cnt += 1\nans = max(a[0]) if cnt & 2 == 0 else min(a[0])\nfor i in range(1, N):\n    ans += max(a[i])\n\nprint(ans)\n",
        "length": 13,
        "loc": 9
    },
    "arc164_e_43438224": {
        "buggy": "N, Q = map(int, input().split())\nX = []\nS = {0, N}\nfor _ in range(Q):\n    l, r = map(int, input().split())\n    l -= 1\n    S.add(l)\n    S.add(r)\n    X.append((l, r))\nSS = sorted(S)\nD = {a: i for i, a in enumerate(SS)}\nM = len(SS)\nX = [(D[l], D[r]) for l, r in X]\nd = 0\ns = 1\nwhile s < M:\n    s *= 2\n    d += 1\nL = [0] * (M + 1)\nR = [0] * (M + 1)\nI = [0] * (M + 1)\nfor l, r in X:\n    if l + 1 == r:\n        I[l] += 1\n    else:\n        L[l] += 1\n        R[r] += 1\n\ninf = 10 ** 6\nY = [0]\nfor i in range(M - 1):\n    ni = i + 1\n    nY = [inf] * (i * 2 + 5)\n    for j in range(len(Y)):\n        for dj in ((1, ) if j % 2 else (1, 2)):\n            nj = j + dj\n            if nj >= len(nY):\n                continue\n            if dj == 2:\n                nY[nj] = min(nY[nj], Y[j])\n            else:\n                if nj % 2:\n                    c = I[i] + R[ni]\n                else:\n                    c = I[i] + L[i]\n                nY[nj] = min(nY[nj], Y[j] + c)\n        \n    Y = nY\nprint(d, Y[s] * 2 if d else Q)",
        "length": 49,
        "loc": 16
    },
    "arc165_a_45736644": {
        "buggy": "import time\nts = time.perf_counter_ns()\n\nimport sys\n\ndsum = 0\ndef search_p(n):\n    global dsum\n    for p in range(3,400000,2):\n        if p*p>n:\n            dsum += p//2 - 1\n            return 0\n        elif n%p<1:\n            dsum += p//2\n            return p\n\nsys.stdin.readline()\nfor s in sys.stdin.readlines():\n    n = int(s)\n    p = search_p(n)\n    if p:\n        while n%p<1:\n            n//=p\n    print('Yes' if p and n>1 else 'No')\nsys.stdout.flush()\nte = ts + dsum * 1000\nwhile time.perf_counter_ns() < te:\n    pass",
        "length": 28,
        "loc": 20
    },
    "arc165_b_45995987": {
        "buggy": "import math\nimport numpy\nN,M = input().split()\nN = int(N)\nK = int(M)\n#print(N+K)\nlist1 = list(map(int, input().split()))\nlist2 = []\ncounter1 = 0\ncounter2 = 0\ncounter3 = 0\ncounter4 = 0\ncounter5 = 0\n#print(list1)\nfor a in range(N-1):\n  if list1[a] <= list1[a+1]:\n    counter1 += 1\n    counter2 = max(counter1, counter2)\n  else:\n    counter1 = 0\nif counter2+1 >= K:\n  for b in range(N):\n    print(list1[b], end = \" \")\nelse:\n  \"\"\"for c in range(1, K+1):\n    #\u6bd4\u8f03\u3059\u308b c\u306e\u6642\u3001N-K-c+2\u304b\u3089N-c\u306e\u6700\u5c0f\u5024\u3068N-K-c+1\u306e\u5024\u3092\u6bd4\u8f03\u3002\u5f8c\u8005\u304c\u6700\u5c0f\u5024\u4ee5\u4e0b\u306a\u30891\u500b\u305a\u3089\u305b\u308b\u3002\u305a\u3089\u305b\u306a\u304f\u306a\u308b\u307e\u3067\u3084\u308b\u3002\n    if c == 1:#\u7279\u5225\u306a\u51e6\u7406\u3001\u6700\u5c0f\u5024\u6bd4\u8f03\n      for d in range(N-K-c+1, N-c):\n        if list1[N-K-c] > list1[d]:#\u305a\u3089\u305b\u306a\u3044\n          counter3 = 1\n      if counter3 == 1:#\uff11\u500b\u305a\u3089\u305b\u306a\u3044\u5834\u5408\n        counter4 = 0#\u305a\u3089\u305b\u308b\u500b\u6570\u30ab\u30a6\u30f3\u30c8\n        break\n      else:#\u4e00\u500b\u305a\u3089\u305b\u308b\n        counter4 += 1\n    #\u5168\u90e8\u901a\u904e\u3057\u3066c=2\u306e\u30eb\u30fc\u30d7\u306b\u5165\u308b\u3084\u3064\u306f\uff11\u500b\u305a\u3089\u305b\u308b\u3084\u3064\n    else:#c>=2\u306e\u51e6\u7406\n      if list1[N-K-c] > list1[N-K-c+1]:#\u305a\u308c\u305b\u306a\u3044\u5834\u5408\n        break\n      else:\n        counter4 += 1\n#\u3053\u306e\u6642\u70b9\u3067counter4\u306b\u3044\u304f\u3089\u305a\u3089\u305b\u308b\u304b\u306e\u60c5\u5831\u304c\u5165\u3063\u3066\u3044\u308b\u306f\u305a\n  #print(counter4)\u2190\u78ba\u8a8d\u7528\"\"\"\n  \n  for c in range(K-1):\n    if list1[N-K-c] >= list1[N-K-c-1]:#\u6607\u9806\u9023\u7d9a\u8a18\u9332\u3092\u8abf\u3079\u308b\n      counter3  += 1\n    else:\n      break\n  #\u3053\u306e\u6642\u70b9\u3067counter3\u306b\u9023\u7d9a\u6607\u9806\u8a18\u9332-1\u306e\u5024\u304c\u5165\u3063\u3066\u308b\u306f\u305a\n  print(counter3)\n  for g in range(N-K, N-counter3):\n    if list1[N-K-1] > list1[g]:#list1[N-K]\u304c\u6700\u5c0f\u5024\u3067\u306a\u3044\u5834\u5408\n      counter5 = 1\n  if counter5 == 1:#\u30ea\u30b9\u30c8\u306e\u4e00\u756a\u6700\u5f8c\u306e\u8eab\u3092\u5165\u308c\u66ff\u3048\u308b\u3002\n    counter4 = 0\n  elif counter5 == 0:\n    counter4 = counter3 \n  else:\n    print(\"\u30a8\u30e9\u30fc\")\n    \n  \n  for d in range(K):\n    list2.append(list1[N-K-counter4+d])\n  #print(list2)\n  sorted_list2 = numpy.sort(list2, axis=-1, kind='quicksort', order=None)\n  #print(sorted_list2)\n  for e in range(K):\n    list1[N-K-counter4+e] = sorted_list2[e]\n  for f in range(N):\n    print(list1[f], end = \" \")\n  \n\n      \n      \n      \n      \n  \n",
        "length": 78,
        "loc": 51
    },
    "arc165_c_45716699": {
        "buggy": "from collections import deque\nN,M = map(int,input().split())\nedge = []\nfor _ in range(M):\n    a,b,w = map(int,input().split())\n    a-=1\n    b-=1\n    edge.append((a,b,w))\n\ndef const_color(G):\n    c = [-1] * N\n    q = deque()\n    for st in range(N):\n        if c[st] == -1:\n            q.append(st)\n            c[st] = 0\n            while q:\n                now = q.popleft()\n                for nx in G[now]:\n                    if c[nx] == -1:\n                        c[nx] = c[now] ^ 1\n                        q.append(nx)\n    return c\ndef is_binary(G,edge):\n    c = const_color(G)\n\n    for a,b in edge:\n        if c[a] != c[b]:\n            pass\n        else:\n            return False\n    return True\n\ndef const_G(x):\n    G = [[] for _ in range(N)]\n    new_edge = []\n    for a,b,w in edge:\n        if w < x:\n            G[a].append(b)\n            G[b].append(a)\n            new_edge.append((a,b))\n\n    return G,new_edge\n\ndef is_ok(x):\n    G,new_edge = const_G(x)\n    return is_binary(G,new_edge)\n\n\n\n\nINF = float('inf')\nG0,edge0 = const_G(INF)\ne0 = [[] for _ in range(N)]\nans = INF\nfor a,b,w in edge:\n    e0[a].append(w)\n    e0[b].append(w)\nfor i in range(N):\n    e0[i].sort()\n    if len(e0[i]) >= 2:\n        path_length = e0[i][0] + e0[i][1]\n        ans = min(ans,path_length)\nif is_binary(G0,edge0):\n    print(ans)\nelse:\n    ok = 0\n    ng = 10 ** 9 + 1\n    while (ng-ok) > 1:\n        x = (ng + ok) // 2\n        if is_ok(x):\n            ok = x\n        else:\n            ng = x\n    ans = min(ok,ans)\n\nprint(ans)\n",
        "length": 77,
        "loc": 77
    },
    "arc166_a_48970771": {
        "buggy": "T=int(input())\n\n\n\nfor i in range(T):\n    N,X,Y=map(str,input().split())\n    flag =  True\n    for j in range(int(N)):\n        if Y[j]==\"C\" and X[j]!=\"C\":\n            flag = False\n\n    sx=\"\"\n    sy=\"\"\n    \n    for j in range(int(N)):    \n        if Y[j]!=\"C\":\n            sx+=X[j]\n            sy+=Y[j]\n        else:\n            ya =0\n            yb =0 \n            xa =0\n            xb =0\n            for t in range(len(sx)):\n                if sx[t] == \"A\":\n                    xa+=1\n                elif sx[t] ==\"B\":\n                    xb+=1\n                if sy[t]==\"A\":\n                    ya+=1\n                elif sy[t]==\"B\":\n                    yb+=1\n            if xa > ya or xb > yb:\n                flag =False\n         \n            nsx=\"\"\n            for t in range(len(sx)):\n                if sx[t]==\"C\" and xa < ya:\n                    xa+=1\n                    nsx+=\"A\"\n                elif sx[t]==\"C\":\n                    nsx+=\"B\"\n                else:\n                    nsx+=sx[t]\n\n            nsx_l=[]\n            sy_l=[]\n            for t in range(len(nsx)):\n                if nsx[t]==\"A\":\n                    nsx_l.append(t) \n                if sx[t]==\"A\":\n                    sy_l.append(t)\n            \n            if len(nsx_l) == len(sy_l):\n                for t in range(len(nsx_l)):\n                    if nsx_l[t]>sy_l[t]:\n                        \n                        flag=False\n            sx=\"\"\n            sy=\"\"\n    ya =0\n    yb =0 \n    xa =0\n    xb =0\n    for t in range(len(sx)):\n        if sx[t] == \"A\":\n            xa+=1\n        elif sx[t] ==\"B\":\n            xb+=1\n        if sy[t]==\"A\":\n            ya+=1\n        elif sy[t]==\"B\":\n            yb+=1\n    if xa > ya or xb > yb:\n        flag =False\n    nsx=\"\"\n    for t in range(len(sx)):\n        if sx[t]==\"C\" and xa < ya:\n            xa+=1\n            nsx+=\"A\"\n        elif sx[t]==\"C\":\n            nsx+=\"B\"\n        else:\n            nsx+=sx[t]\n    nsx_l=[]\n    sy_l=[]\n    \n    for t in range(len(nsx)):\n        if nsx[t]==\"A\":\n            nsx_l.append(t) \n        if sy[t]==\"A\":\n            sy_l.append(t)\n                                \n    if len(nsx_l) == len(sy_l):\n        for t in range(len(nsx_l)):\n            if nsx_l[t]>sy_l[t]:\n                flag=False\n\n\n    if flag == False:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\n\n    \n\n        \n\n\n        \n",
        "length": 111,
        "loc": 51
    },
    "arc166_b_49426497": {
        "buggy": "n,a,b,c = map(int, input().split())\nal = list(map(int, input().split()))\n\ndef gcm(a,b):\n    if b == 0:\n        return a\n    else:\n        return gcm(b,a%b)\n    \ndef calc(x,y):\n    if x%y == 0:\n        return x\n    else:\n        return y * (x//y + 1)\n\nab_gcm = gcm(a,b)\nab = a*b//ab_gcm\nac_gcm = gcm(a,c)\nac = a*c//ac_gcm\nbc_gcm = gcm(b,c)\nbc = b*c//bc_gcm\nabc_gcm = gcm(ab,c)\nabc = ab*c//abc_gcm\n\ndl = [[0] * 8 for i in range(n)]\nfor i,l in enumerate(al):\n    dl[i][int('001',2)] = calc(l,a) -  l\n    dl[i][int('010',2)] = calc(l,b) -  l\n    dl[i][int('100',2)] = calc(l,c) -  l\n    dl[i][int('011',2)] = calc(l,ab) -  l\n    dl[i][int('101',2)] = calc(l,ac) -  l\n    dl[i][int('110',2)] = calc(l,bc) -  l\n    dl[i][int('111',2)] = calc(l,abc) -  l\n\ndp=[[1000000000000000000] * 9 for i in range(n+1)]\n\nfor i,d in enumerate(dl):\n    dp[i+1][int('001',2)] = min(dp[i][int('001',2)],d[int('001',2)])\n    dp[i+1][int('010',2)] = min(dp[i][int('010',2)],d[int('010',2)])\n    dp[i+1][int('100',2)] = min(dp[i][int('100',2)],d[int('100',2)])\n    dp[i+1][int('011',2)] = min(dp[i][int('011',2)],d[int('011',2)],dp[i][int('001',2)]+d[int('010',2)],dp[i][int('010',2)]+d[int('001',2)])\n    dp[i+1][int('101',2)] = min(dp[i][int('101',2)],d[int('101',2)],dp[i][int('001',2)]+d[int('100',2)],dp[i][int('100',2)]+d[int('001',2)])\n    dp[i+1][int('011',2)] = min(dp[i][int('110',2)],d[int('110',2)],dp[i][int('010',2)]+d[int('100',2)],dp[i][int('100',2)]+d[int('010',2)])\n    dp[i+1][int('111',2)] = min(dp[i][int('111',2)], d[int('111',2)]\\\n                                ,dp[i][int('011',2)]+d[int('100',2)],dp[i][int('101',2)]+d[int('010',2)],dp[i][int('110',2)]+d[int('001',2)]\\\n                                ,dp[i][int('001',2)]+d[int('110',2)],dp[i][int('010',2)]+d[int('101',2)],dp[i][int('100',2)]+d[int('011',2)])\n\nprint(dp[n][7])",
        "length": 48,
        "loc": 43
    },
    "arc166_d_46393620": {
        "buggy": "import heapq\nn=int(input())\nx=[-10**18]+list(map(int,input().split()))+[10**18]\ny=[0]+list(map(int,input().split()))+[0]\nl_pool=[]\nr_pool=[]\nmin_diff=10**18\nfor i in range(1,n+2):\n  if y[i]-y[i-1]==0:\n    continue\n  elif y[i]-y[i-1]>0:\n    l_cur=x[i-1]+1\n    l_cnt=y[i]-y[i-1]\n    heapq.heappush(l_pool,(l_cur,l_cnt))\n  elif y[i]-y[i-1]<0:\n    r_cur=x[i]-1\n    r_cnt=y[i-1]-y[i]\n    while r_cnt!=0:\n      l_cur,l_cnt=heapq.heappop(l_pool)\n      diff_cur=r_cur-l_cur\n      min_diff=min(min_diff,diff_cur)\n      if r_cnt>=l_cnt:\n        r_cnt-=l_cnt\n      elif r_cnt<l_cnt:\n        r_cnt=0\n        l_cnt-=r_cnt\n        heapq.heappush(l_pool,(l_cur,l_cnt))\nif min_diff>=10**15:\n  print(-1)\nelse:\n  print(min_diff)",
        "length": 31,
        "loc": 27
    },
    "arc167_a_51403165": {
        "buggy": "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\nsingle_sz = n - (n-m)*2\nprint(single_sz)\n\nans = 0\nfor i in range(single_sz):\n    ans += a[i]**2\n\nfor i in range(n-m):\n    i1 = single_sz+i\n    i2 = n-1-i\n    ans += (a[i1]+a[i2])**2\n\nprint(ans)\n",
        "length": 17,
        "loc": 6
    },
    "arc167_b_51380686": {
        "buggy": "def prime_factorize(N):\n    # \u7b54\u3048\u3092\u8868\u3059\u53ef\u5909\u9577\u914d\u5217\n    res = {}\n\n    # \u221aN \u307e\u3067\u8a66\u3057\u5272\u3063\u3066\u3044\u304f\n    for p in range(2, N):\n        # p * p <= N \u306e\u7bc4\u56f2\u3067\u3088\u3044\n        if p * p > N:\n            break\n\n        # N \u304c p \u3067\u5272\u308a\u5207\u308c\u306a\u3044\u306a\u3089\u3070\u30b9\u30ad\u30c3\u30d7\n        if N % p != 0:\n            continue\n\n        # N \u306e\u7d20\u56e0\u6570 p \u306b\u5bfe\u3059\u308b\u6307\u6570\u3092\u6c42\u3081\u308b\n        e = 0\n        while N % p == 0:\n            # \u6307\u6570\u3092 1 \u5897\u3084\u3059\n            e += 1\n\n            # N \u3092 p \u3067\u5272\u308b\n            N //= p\n\n        # \u7b54\u3048\u306b\u8ffd\u52a0\n        res[p]=e\n\n    # \u7d20\u6570\u304c\u6700\u5f8c\u306b\u6b8b\u308b\u3053\u3068\u304c\u3042\u308a\u3046\u308b\n    if N != 1:\n        res[N]=1\n\n    return res\n\nA,B=map(int,input().split())\nres=prime_factorize(A)\n\n\npro=1\nfor key in res.keys():\n    pro*=B*res[key]+1\n\nans=10**30\nfor key in res.keys():\n    ans=min(ans,(B*res[key]*pro//2)//res[key])\nprint(ans%998244353)\n    \n    ",
        "length": 46,
        "loc": 41
    },
    "arc168_a_49215452": {
        "buggy": "n=int(input())\ns=input()\na=[]\nT=False\nb=1\nfor i in range(n-1):\n  if s[i]=='>':\n    b+=1\n  else:\n    if b!=1:\n      a.append(b)\n      b=1\nif b!=1:\n  a.append(b)\nc=0\nfor i in a:\n  c+=(n*(n-1))//2\nprint(c)",
        "length": 18,
        "loc": 17
    },
    "arc168_b_47858758": {
        "buggy": "from collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\n\nxor_sum = 0\ncnt = defaultdict(lambda: 0)\nfor elem in a:\n  xor_sum = xor_sum ^ elem\n  cnt[elem] += 1\n\nif xor_sum > 0:\n  print(-1)\n  exit(0)\n\nelem_and_cnt = list(cnt.items())\nelem_and_cnt.sort(key=lambda elem: elem[0], reverse=True)\n\nfor elem, cnt in elem_and_cnt:\n  if cnt % 2 == 1:\n    print(cnt - 1)\n    exit(0)\n    \nprint(0)",
        "length": 23,
        "loc": 20
    },
    "arc170_a_54960940": {
        "buggy": "n = int(input())\ns = input()\nt = input()\n\na = []\nfor i in range(n):\n    if s[i] != t[i]:\n        if t[i] == \"A\":\n            a.append(0)\n        else:\n            a.append(1)\n\nans = 0\nleft = 0\nright = 0\nneed = 0\nfor i in a:\n    if i == 0:\n        left += 1\n    else:\n        right += 1\n        if left < right:\n            need += 1\n            right -= 1\n        else:\n            ans += 1\n            left -= 1\n            right -= 1\n\n# print(a)\nbefore_A = False\nlast_B = False\nfor i in range(n):\n    if s[i] == \"A\" and t[i] == \"B\" and before_A is False:\n        print(-1)\n        exit()\n    if s[i] == \"A\":\n        before_A = True\n    if s[i] == \"B\" and t[i] == \"A\":\n        last_B = True\n    if t[i] == \"B\":\n        last_B = False\n\nif last_B:\n    print(-1)\n    exit()\n\nprint(ans + left + right + need)\n",
        "length": 48,
        "loc": 37
    },
    "arc170_c_51377709": {
        "buggy": "import sys\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef si(): return input().rstrip()\ndef mii(): return map(int, input().split())\ndef fii(): return map(float, input().split())\ndef mii1(): return map(lambda x: int(x)-1, input().split())\n\ndef lii(): return list(map(int, input().split()))\ndef lii1(): return list(map(lambda x: int(x)-1, input().split()))\ndef lfi(): return list(map(float, input().split()))\ndef lsi(): return list(input().rstrip())\ndef lmsi(): return list(map(str, input().split()))\n\ndef iir(n): return [int(input()) for _ in range(n)]\ndef fir(n): return [float(input()) for _ in range(n)]\ndef sir(n): return [input().rstrip() for _ in range(n)]\n\ndef liir(n): return [list(map(int, input().split())) for _ in range(n)]\ndef lii1r(n): return [list(map(lambda x: int(x)-1, input().split())) for _ in range(n)]\ndef lfir(n): return [list(map(float, input().split())) for _ in range(n)]\ndef lsir(n): return [list(input().rstrip()) for _ in range(n)]\ndef lmsir(n): return [list(map(str, input().split())) for _ in range(n)]\n\ndef lii_alp(): return list(map(lambda x: ord(x)-97, input().rstrip()))\ndef lii_ALP(): return list(map(lambda x: ord(x)-65, input().rstrip()))\naround = [[-1,0],[0,1],[1,0],[0,-1]]\nfrom copy import deepcopy\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right, insort\nfrom heapq import heapify, heappop, heappush\nfrom math import ceil, floor, gcd, sin, cos, radians, log, sqrt, inf\nfrom itertools import product, combinations, permutations, accumulate, groupby\nfrom decimal import Decimal, ROUND_HALF_UP\nsys.setrecursionlimit(10**7)\nmod = 998244353\nn,m = mii()\ns = lii()\nif n <= m+1:\n  ans = 1\n  for i in range(n):\n    if s[i] == 0:\n      ans *= m\n      ans %= mod\n    else:\n      continue\n  print(ans)\n  exit()\ndp = [[0]*(m+2) for i in range(n)]\nif s[0] == 0:\n  dp[0][1] = m\nelse:\n  dp[0][1] = 1\nfor i in range(n-1):\n  for j in range(1,m+2):\n    if s[i+1] == 0:\n      dp[i+1][j] += dp[i][j]*j\n      dp[i+1][j] %= mod\n      if m-j >= 1 :\n        dp[i+1][j+1] += dp[i][j]*(m-j)\n        dp[i+1][j+1] %= mod\n    else:\n      if j <= m:\n        dp[i+1][j+1] += dp[i][j]\n        dp[i+1][j+1] %= mod\nans = 0\nfor i in range(1,m+2):\n  ans += dp[-1][i]\n#print(dp)\nprint(ans)\n  ",
        "length": 72,
        "loc": 71
    },
    "arc171_a_51436402": {
        "buggy": "T = int(input())\nfor _ in range(T):\n    N, A, B = map(int,input().split())\n    if N < A:\n        print(\"No\")\n        continue\n    if N//2 >= A:\n        tate = (N - 2*A + 1)//2 + A\n        yoko = N - A\n        if tate*yoko >= B:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        yoko = N - A\n        A -= N // 2\n        tate = N // 2 - A\n        if tate*yoko >= B:\n            print(\"Yes\")\n        else:\n            print(\"No\")",
        "length": 21,
        "loc": 17
    },
    "arc172_a_54670313": {
        "buggy": "H, W, N = (int(i) for i in input().split())\nA = [int(i) for i in input().split()]\n\nD = [0] * 26\n\nfor i in range(N):\n    D[A[i]] += 1\n\ns = 0\nfor i in range(25, -1, -1):\n    d = (H // 2 ** i) * (W // 2 ** i)\n    if d - 4 * s < D[i]:\n        print('No')\n        exit()\n    s = D[i]\nprint('Yes')\n",
        "length": 16,
        "loc": 15
    },
    "arc172_c_51141760": {
        "buggy": "n = int(input())\nc = input()\nhead = c[0]\ntail = c[1:]\nif head == \"B\":\n    # tail\u4e2d\u306eA\u3068B\u3092\u53cd\u8ee2\n    tail = tail.replace(\"A\", \"C\").replace(\"B\", \"A\").replace(\"C\", \"B\")\n\n\ndef sign2char(n):\n    if n == 0:\n        return \"C\"\n    elif n > 0:\n        return \"A\"\n    else:\n        return \"B\"\n\n# \u521d\u671f\u5316\ncount = [1]\nfor t in tail:\n    if t == \"A\":\n        count.append(count[-1] + 1)\n    else:  # \"B\"\n        count.append(count[-1] - 1)\n\nans = 1\n# \u5148\u982d\u30921\u3064\u305a\u3064\u5f8c\u308d\u306b\u305a\u3089\u3057\u3066\u3044\u304f\nfor i in range(n-1):\n    before = count[i]\n    if head != tail[i]:\n        after = before - 2\n    else:\n        after = before\n    if sign2char(before) != sign2char(after):\n        ans += 1\n\nprint(ans)",
        "length": 37,
        "loc": 30
    },
    "arc173_a_53255887": {
        "buggy": "from functools import lru_cache\n\n@lru_cache\ndef f(maxi, no):\n    if maxi < 10:\n        return maxi - (0 < no <= maxi)\n    q = maxi // 10\n    r = maxi % 10\n    ans = 0\n    for x in range(10):\n        if x == no:\n            continue\n        if x <= r:\n            ans += f(q, x) + (x != 0)\n        else:\n            ans += f(q - 1, x) + (x != 0)\n    return ans\n\ndef g(maxi):\n    if maxi < 10:\n        return maxi\n    q = maxi // 10\n    r = maxi % 10\n    ans = 0\n    for x in range(10):\n        if x <= r:\n           ans += f(q, x) + (x != 0)\n        else:\n            ans += f(q - 1, x) + (x != 0)\n    return ans\n\nT = int(input())\nfor _ in range(T):\n    k = int(input())\n    lo = 0\n    hi = 10**12\n    # f(lo) < k\n    while lo < hi - 1:\n        m = (lo + hi) // 2\n        s = g(m)\n        if s < k:\n            lo = m\n        else:\n            hi = m\n    print(hi)\n",
        "length": 45,
        "loc": 36
    },
    "arc173_b_51157170": {
        "buggy": "\nn = int(input())\n\nimport sys\ninput = sys.stdin.readline\nmp = map(int, sys.stdin.read().split())\nxy = list(zip(mp,mp)) \n\nstack = []\ncnt = 0\nans = 0\n\nfor i in range(n):\n    if cnt < 2:\n        stack.append(i)\n        cnt += 1\n        continue\n\n    xi,yi = xy[i]\n    flag = False\n\n    for ji in range(cnt):\n        if flag:\n            break\n        j = stack[ji]\n        \n        xj,yj = xy[j]\n\n        dx = xi-xj\n        dy = yi-yj\n        # if dx == 0:\n        #     # dx = 0\n        #     dy = 0\n        # else:\n        #     # if dx < 0:\n        #     #     dx = -dx\n        #     #     dy = -dy\n        #     pass\n\n        for ki in range(ji+1, cnt):\n            if flag:\n                break\n            k = stack[ki]\n\n            xk,yk = xy[k]\n            ex = xi-xk\n            ey = yi-yk\n\n            # if ex == 0:\n            #     # ex = 0\n            #     ey = 0\n            # else:\n            #     # if ex < 0:\n            #     #     ex = -ex\n            #     #     ey = -ey\n            #     pass\n            \n            # if (dx == ex) & (dy == ey):\n            #     print(\"a\", i,j,k)\n            #     continue\n            # elif dx == 0:\n            #     print(\"b\", i,j,k)\n            #     pass\n            # elif ex == 0:\n            #     print(\"c\", i,j,k)\n            #     pass\n            # else:\n            if (dx == 0) | (ex == 0):\n                if dx == ex:\n                    continue\n                else:\n                    pass\n\n            elif (dx * ey) == (dy * ex):\n                # print(\"d\", i,j,k)\n                continue\n            else:\n                # print(\"e\", i,j,k)\n                pass\n            \n            stack.remove(k)\n            stack.remove(j)\n            cnt -= 2\n            ans += 1\n            flag = True\n    \n    if not flag:\n        stack.append(i)\n        cnt += 1\n\nif cnt < 3:\n    print(ans)\n    exit()\n\nj = stack[0]\nk = stack[1]\n\n# xj,yj = xy[j]\n# xk,yk = xy[k]\n\ndef line(p,q):\n    \"\"\"\n    2\u70b9p(px,py),q(qx,qy)\u3092\u901a\u308b\u76f4\u7ddaax+by+c=0\u306ea,b,c\u3092\u8fd4\u3059\n    \"\"\"\n    px,py = p\n    qx,qy = q\n\n    a = py - qy\n    b = qx - px\n    c = px*qy - py-qx\n\n    return a,b,c\n\na,b,c = line(xy[j], xy[k])\n\ncnt = 0\nfor i in range(n):\n    xi,yi = xy[i]\n    if (a*xi + b*yi + c) == 0:\n        cnt += 1\n    else:\n        pass\n\n\nif cnt >= (n-n//3):\n    print(n-cnt)\nelse:\n    print(n//3)\n# print(ans)\n",
        "length": 129,
        "loc": 110
    },
    "arc174_a_53524573": {
        "buggy": "N, C = map(int, input().split())\nA = list(map(int, input().split()))\n\nS = [0]*(N + 1)\nfor i in range(N):\n    S[i + 1] = S[i] + A[i]\nINF = 10**18\n\nif C > 1:\n    m = INF\n    ans = -INF\n    for i in range(N):\n        m = min(m, S[i + 1])\n        ans = max(ans, S[i + 1] - m)\n    print(S[N] + ans*(C - 1))\nelif C <= 1:\n    m = 0\n    ans = INF\n    for i in range(N):\n        m = max(m, S[i + 1])\n        ans = min(ans, S[i + 1] - m)\n    print(S[N] + ans*(C - 1))",
        "length": 22,
        "loc": 10
    },
    "arc174_b_52291293": {
        "buggy": "t = int(input())\nfor _ in range(t):\n    A = list(map(int, input().split()))\n    _, _, _, p4, p5 = map(int, input().split())\n\n    target = 2 * A[0] + A[1] - A[3] - 2 * A[4]\n    if target <= 0:\n        ans = 0\n    else:\n        ans = min(target // 2 * p5, target * p4)\n        if target % 2 != 0:\n            ans += min(p5, p4)\n    print(ans)\n",
        "length": 13,
        "loc": 10
    },
    "arc174_c_54909674": {
        "buggy": "import sys\nsys.setrecursionlimit(10**6)\ndef e(x):\n    if dp[x] != -1:\n        return dp[x]\n    if x == 0:\n        dp[x] = 0\n        return 0\n    if x == 1:\n        dp[x] = n*(n-1)*pow(2*n-1,mod-2,mod)%mod\n        return dp[x]\n    inv = pow(2*n*x-x**2,mod-2,mod)\n    res = inv*(x*(x-1)*e(x-2) + (2*n*x-2*x*x+x)*e(x-1) + (n-x))%mod\n    dp[x] = res\n    return res\n\nn= int(input())\nmod = 998244353\ndp = [-1]*(n+1)\ndp[0] = 0\ne(n)\nprint(dp[n],dp[n-1])",
        "length": 22,
        "loc": 13
    },
    "arc174_d_51974716": {
        "buggy": "t = int(input())\n\nins = [(1,1)]\n\nfor x in range(2,19,2):\n    v = pow(10,x)\n    h = pow(10,x//2)\n    ins.append((v-h*2,v-h*2))\n    ins.append((v-h,v+h-1))\nprint(ins)\nfor _ in range(t):\n    n = int(input())\n    ans = 0\n    for l,r in ins:\n        r = min(r,n)\n        if l <= r:\n            ans += r-l+1\n    print(ans)\n",
        "length": 18,
        "loc": 10
    },
    "arc175_a_52650326": {
        "buggy": "MOD = 998244353\nN = int(input())\nP = list(map(lambda x: int(x)-1, input().split()))\nS = input()\n\ndef pow(a, b):\n    if b==0:\n        return 1\n    ret = pow((a**2)%MOD, b//2)\n    if b%2:\n        ret = ret*a%MOD\n    return ret\n\ndef countL():\n    cnt = 0\n    spoon = [False]*N\n    for p in P:\n        match S[p]:\n            case \"L\":\n                spoon[p] = True\n            case \"R\":\n                if not spoon[(p+1)%N]:\n                    return 0\n                spoon[p] = True\n            case \"?\":\n                if spoon[(p+1)%N]:\n                    cnt += 1\n                spoon[p] = True\n    return pow(2,cnt)\n\ndef countR():\n    cnt = 0\n    spoon = [False]*N\n    for p in P:\n        match S[p]:\n            case \"R\":\n                spoon[(p+1)%N] = True\n            case \"L\":\n                if not spoon[p]:\n                    return 0\n                spoon[(p+1)%N] = True\n            case \"?\":\n                if spoon[p]:\n                    cnt += 1\n                spoon[(p+1)%N] = True\n    return pow(2,cnt)\n\nans = 0\nmatch S[P[0]]:\n    case \"L\":\n        ans = countL()\n    case \"R\":\n        ans = countR()\n    case \"?\":\n        ans = countL() + countR()\nprint(ans)\n",
        "length": 56,
        "loc": 55
    },
    "arc175_b_51933297": {
        "buggy": "DEBUG = False\ntestcase = r\"\"\"\n1\n2 3\ntest\n\"\"\"[1:]\n\n\nfrom typing import *\nfrom collections import Counter, deque, defaultdict\nimport bisect\nimport heapq\nimport copy\nimport itertools\nfrom pprint import pprint\nimport math\nimport sys\n\n\n_input = input\ninput = lambda: sys.stdin.readline().rstrip()\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\ndbp = lambda *args, **kwargs: print(\"[dbp]\", *args, **kwargs)\ndbp = lambda *args, **kwargs: None\ndef asf(): assert False\n\n\ndef main() -> None:\n    N, A, B = mi()\n    S = list(input())\n\n    # imos\u3067\u8db3\u308a\u3066\u308b\u304b\u3092\u628a\u63e1\u3059\u308b\n    # \u6700\u7d42\u7684\u306a\u5024\u304c\u6b63: (\u304c\u304a\u304a\u3044\n    # \u3000\u3000\u3000\u3000\u3000\u3000\u8ca0: )\u304c\u591a\u3044\n    #             0: \u3061\u3087\u3046\u3069\n    # \u9014\u4e2d\u306e\u5024\u304c0\u4ee5\u4e0a: \u554f\u984c\u306a\u3057\n    # \u3000\u3000\u3000\u3000\u3000\u3000   : \u554f\u984c\u3042\u308a\uff0e)\u304c\u591a\u3044\n    imos = [1 if c == '(' else -1 for c in S]\n    for i in range(1, 2*N): imos[i] += imos[i-1]\n    dbp(imos)\n\n    A_cost = min(A, 2*B)  # B\u4e8c\u56de\u3084\u308b\u65b9\u304c\u5b89\u3044\u306a\u3089\u305d\u3046\u3059\u308b\n    if imos[-1] < 0:  # ')'\u304c\u591a\u3059\u304e\u308b\u5834\u5408\n        # \u5de6\u304b\u3089\u591a\u3059\u304e\u308b')'\u3092'('\u306b\u5909\u63db\u3059\u308b\n        assert imos[-1] % 2 == 0, \"\u4e00\u56de\u306e\u64cd\u4f5c\u3067\u6700\u7d42\u30b9\u30b3\u30a2\u30922\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u306f\u305a\uff0e\u305d\u306e\u305f\u3081\uff0c\u5076\u6570\u3067\u306a\u3051\u308c\u30700\u306b\u306a\u3089\u306a\u3044\"\n        shortage = -imos[-1] // 2  # \u56de\u6570\u5206. ) -> (\u306e\u64cd\u4f5c\u3067\u30b9\u30b3\u30a2\u306f2\u6539\u5584\u3055\u308c\u308b\n        worst_point = -min(imos) - shortage  # -worst_point\u304c\uff0c) -> ( \u3092\u3057\u305f\u5f8c\u306e\u4e00\u756a\u60aa\u3044\u90e8\u5206\u306e\u30b9\u30b3\u30a2\n        ans = shortage * B\n        improve = (worst_point+1) // 2  # \u4e00\u756a\u60aa\u3044\u90e8\u5206\u3088\u308a\u5de6\u5074\u306e)\u3092\u305d\u308c\u3088\u308a\u53f3\u5074\u306e(\u3067\u7f6e\u304d\u63db\u3048\u308b\u3068\u3044\u3044\n        ans += improve * A_cost\n        print(ans)\n    else:\n        # \u53f3\u304b\u3089\u591a\u3059\u304e\u308b'('\u3092')'\u306b\u5909\u63db\u3059\u308b\n        assert imos[-1] % 2 == 0\n        shortage = imos[-1] // 2\n        worst_point = -min(imos)\n        ans = shortage * B\n        improve = (worst_point+1) // 2\n        ans += improve*A_cost\n        print(ans)\n\n\n# infinity\nINF = int(1e20)\n\n# recursion setting\nsys.setrecursionlimit(10**8)\n\nT = TypeVar('T')\n# rotate 2dim list\ndef rot_2dim_list(l: list[list[T]]) -> list[list[T]]:\n    return [list(e) for e in zip(*l)][::-1]\n\n# find the minimum subgrid which includes all interests in the grid\n# return the subgrid parameter [ymin, xmin, ymax, xmax] as half-open interval [ymin, ymax), [xmin, xmax)\ndef extract_roi(grid: list[list[T]], interests: set[str]) -> tuple[int, int, int, int]:\n    ymin = xmin = INF\n    ymax = xmax = -1\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] in interests:\n                ymin = min(ymin, i)\n                xmin = min(xmin, j)\n                ymax = max(ymax, i+1)\n                xmax = max(xmax, j+1)\n    return ymin, xmin, ymax, xmax\n\n# enumerate all 26 alphabets\ndef get_all_alphabets(lower=False) -> list[str]:\n    offset = 32 if lower else 0\n    return [chr(ord(\"A\")+i+offset) for i in range(26)]\n\n# express fraction using modulo\ndef modulo_expr(numer: int, denom: int, mod=998244353) -> int:\n    \"\"\"returns (numer / denom) using modulo\"\"\"\n    modulo_inv = pow(denom, -1, mod)\n    return numer * modulo_inv % mod\n\n# make primes\ndef make_primes(n: int) -> list[int]:\n    \"\"\" make primes lesser equal than n \"\"\"\n    is_prime = [True] * (n + 1)\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            for j in range(2 * i, n + 1, i):\n                is_prime[j] = False\n\n    prime_list = [i for i in range(n + 1) if is_prime[i]]\n\n    return prime_list\n\n# calc number of digits for given integer\ndef get_digit(n: int) -> int:\n    assert n >= 1, \"n must be greater than or equal to 1\"\n    return int(math.log10(n)) + 1\n\n# binary search\n# This is Memorandum-like function. So it supports ascending order only. Write by yourself.\ndef ref_binary_search(ok: int, ng: int, is_ok: Callable) -> int:\n    while ok + 1 != ng:\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return mid\n\n# convert given number into list of bits\n# when num_bit is 3, number: 1 -> [0, 0, 1], number: 2 -> [0, 1, 0], number: 3 -> [0, 1, 1]\ndef num_to_bits(number: int, num_bit: int) -> list[int]:\n    return list(map(int, format(number, f\"0{num_bit}b\")))  # num_bit is shortest length of bits. the length of bits may be longer than num_bit.\n\n# convert given bits to number\n# [0, 1] -> 1, [1, 0, 1] -> 5, [1, 0, 1, 0] -> 6\ndef bits_to_num(bits: list[int]) -> int:\n    num = bits[0]\n    for i in range(1, len(bits)):\n        num *= 2\n        num += bits[i]\n    return num\n\n# for bit exhaustive search\n# if \"num_bit\" == 2, returns [[0, 0], [0, 1], [1, 0], [1, 1]]\ndef bit_exhaustive_enumerate(num_bit: int) -> Iterable[list[int]]:\n    for i in range(2 ** num_bit):\n        yield list(map(int, format(i, f\"0{num_bit}b\")))\n\n# for exhaustive permutation\n# if \"num_elem\" == 3, returns [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]\ndef exhaustive_permutation(num_elem: int) -> Iterable[tuple[int, ...]]:\n    numbers = list(range(num_elem))\n    for p in itertools.permutations(numbers):\n        yield p\n\n\n#######################################################\n# debug configuration\n#######################################################\ndef debug_warn():\n    if DEBUG:\n        print(\"DEBUGGING!!! Please rewite variable DEBUG before submission!!!\")\n\n# by this operation, input() returns testcase\nif DEBUG:\n    import sys, io\n    sys.stdin = io.StringIO(testcase)\n    debug_warn()\n#######################################################\n\n\nif __name__ == \"__main__\":\n    main()\n    debug_warn()\n",
        "length": 176,
        "loc": 49
    },
    "arc175_d_51701679": {
        "buggy": "#ARC175D LIS on Tree 2\n\n#\u5165\u529b\u53d7\u53d6\nN, K = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    u, v = map(lambda x: int(x) - 1, input().split())\n    G[u].append(v)\n    G[v].append(u)\n\n#\u6df1\u3055\u3092\u5272\u308a\u5f53\u3066\nD = [1] * N\nQ = [(0, -1, 1)]\nfor now, back, d in Q:\n    D[now] = d\n    for nxt in G[now]:\n        if nxt != back:\n            Q.append((nxt, now, d + 1))\n\n#\u6301\u3061\u70b9\u3092\u8a08\u7b97  \u3053\u306e\u6642\u70b9\u3067\u69cb\u7bc9\u53ef\u5426\u3092\u5224\u5b9a\ncost = sum(D)\nif K not in range(N, cost + 1):\n    exit( print('No') )\nelse:\n    print('Yes')\n\n#A[d]: \u6df1\u3055\u304cd\u3067\u3042\u308b\u9802\u70b9\u306e\u4e00\u89a7\n#B[d]: \u6df1\u3055\u304cd\u3067\u3042\u308b\u9802\u70b9\u306e\u500b\u6570 \u306e\u7d2f\u7a4d\u548c\nM = max(D)\nA = [[] for _ in range(M + 1)]\nfor i, d in enumerate(D):\n    A[d].append(i)\nB = [0] * (M + 2)\nfor d in range(1, M + 1):\n    B[d + 1] = B[d] + len(A[d])\n\n#\u524d\u304b\u3089\u52a0\u7b97(1)  P\u306b\u5024\u3092\u5272\u308a\u5f53\u3066\nP = [0] * N\ndiff = K\nfor d in range(1, M + 1):\n    cnt = B[-1] - B[d]  #\u5024\u304cd\u4ee5\u4e0a\u306e\u9802\u70b9\u6570\n    if cnt <= diff:\n        diff -= cnt\n        for i in A[d]:\n            P[i] = d\n        continue\n    elif 0 <= diff < cnt:\n        #\u5f8c\u308d\u304b\u3089diff\u500b\u3092d\u306b\u3001\u305d\u308c\u4ee5\u5916\u3092\u5024d - 1\u306b\u5272\u308a\u632f\u308b\n        Q = []\n        for e in range(M, d - 1, -1):\n            Q.extend(A[e])\n        while Q:\n            i = Q.pop()\n            if diff:\n                P[i] = d\n                diff -= 1\n            else:\n                P[i] = d - 1\n        break\nassert all(P[i] <= D[i] for i in range(N))\nassert sum(P) == K\n\n#\u5272\u308a\u5f53\u3066\nQ = sorted((P[i], - D[i], i) for i in range(N))\nans = [0] * N\nfor c, (_, _, i) in enumerate(Q, start = 1):\n    ans[i] = c\nprint(*ans)\n",
        "length": 68,
        "loc": 50
    },
    "arc176_a_55031190": {
        "buggy": "def solve(n, m, a, b):\n    # 0-index\u3078\u5909\u63db\n    a = [_-1 for _ in a]\n    b = [_-1 for _ in b]\n\n    # \u5bfe\u89d2\u8981\u7d20\u3068\u306e\u30ba\u30ec\u304c\u3069\u308c\u3050\u3089\u3044\u306e\u30d1\u30bf\u30fc\u30f3\u3092\u4f7f\u3063\u3066\u3044\u308b\u304b\n    S = set() # m\u500b\u306e\u30d1\u30bf\u30fc\u30f3\u304c\u5fc5\u8981\n    for i, j in zip(a, b):\n        S.add((i+j) % n)\n    i = 0\n    while len(S) < m:\n        S.add(i)\n        i += 1\n\n    # \u30d1\u30bf\u30fc\u30f3\u3054\u3068\u306bn\u500b\u306e\u30de\u30b9\u3092\u57cb\u3081\u3089\u308c\u308b(i+j = d mod n\u3068\u306a\u308b(i,j)\u306e\u30da\u30a2) \n    ans = []\n    for d in S:\n        for i in range(n):\n            # \u30ba\u30ec\u304c\u7570\u306a\u308b\u30d1\u30bf\u30fc\u30f3\u540c\u58eb\u306f\u91cd\u306a\u308a\u5408\u3046\u3053\u3068\u306f\u306a\u3044\u306e\u3067\u3001\u89e3\u3068\u3057\u3066\u8ffd\u8a18\u3057\u3066\u3044\u304f\n            j = (n - 1 - i + d) % n\n            ans.append((i+1, j+1))\n    return ans\n\nn, m = map(int, input().split())\na, b = zip(*[map(int, input().split()) for i in range(m)])\nans = solve(n, m, a, b)\nprint(len(ans))\nfor i, j in ans:\n    print(i, j)\n",
        "length": 29,
        "loc": 20
    },
    "arc176_b_53761488": {
        "buggy": "n=int(input())\nfor _ in range(n):\n  n, m,k = map(int, input().split())\n  if n==m-1==k:\n    print(0)\n    continue\n  if n >= m:\n    sa=n-m\n    num=sa//(m-k)+1\n    n=n-num*(m-k)\n \n  print(pow(2,n,10))",
        "length": 12,
        "loc": 4
    },
    "arc177_a_53706270": {
        "buggy": "A, B, C, D, E, F = map(int, input().split())\nN = int(input())\nX = list(map(int, input().split()))\n\nout = \"Yes\"\n\nfor i in range(N):\n  while(X[i] >= 500 and F > 0):\n    X[i] = X[i] - 500\n    F = F - 1\n  while(X[i] >= 100 and E > 0):\n    X[i] = X[i] - 100\n    E = E - 1\n  while(X[i] >= 50 and D > 0):\n    X[i] = X[i] - 50\n    D = D - 1\n  while(X[i] >= 10 and C > 0):\n    X[i] = X[i] - 10\n    C = C - 1\n  while(X[i] >= 5 and B > 0):\n    X[i] = X[i] - 5\n    B =  - 1\n  while(X[i] >= 1 and A > 0):\n    X[i] = X[i] - 1\n    A = A - 1\n  if(X[i] != 0):\n    out = \"No\"\n    break\n  \nprint(out)",
        "length": 30,
        "loc": 22
    },
    "arc177_b_53566689": {
        "buggy": "N = int(input())\nS = input()\n\nans = []\npre = '0'\nbottom = ['A', 'B']\nfor i in range(N-1, -1, -1):\n  if pre == S[i]:\n    continue\n  for j in range(i+1):\n    ans.append(bottom[int(pre)])\n  pre = S[i]\n\nprint(len(ans))\nprint(*ans)",
        "length": 15,
        "loc": 15
    },
    "arc178_b_54290534": {
        "buggy": "#!/usr/bin/env python3\n\nMOD = 998244353\n\ndef tri(n):\n    n %= MOD\n    return ((n + 1) * n // 2) % MOD\n\n\ndef solve():\n    a1, a2, a3 = map(int, input().split())\n    if a1 < a2:\n        a1, a2 = a2, a1\n\n    if not a1 <= a3 <= a1 + 1:\n        return 0\n\n    p1 = pow(10, a1 - 1, MOD)\n    p2 = pow(10, a2 - 1, MOD)\n\n    if a1 == a2:\n        ans = tri(8 * p1)\n    else:\n        ans = (9 * p1 - 10 * p2) * (9 * p2) + tri(9 * p2)\n\n    if a3 == a1:\n        return ans\n    else:\n        return (9 * p1) * (9 * p2) - ans\n\n\nt = int(input())\nfor _ in range(t):\n    print(solve())\n",
        "length": 34,
        "loc": 34
    },
    "arc179_a_55011877": {
        "buggy": "#!/usr/bin/env python3\n\n# \u518d\u8d77\u95a2\u6570,Decimal\u4ee5\u5916\u306f\u3001pypy\u3092\u63a8\u5968(\u30e1\u30e2\u30ea\u3092\u591a\u304f\u4f7f\u7528\u3059\u308b\u5834\u5408\u9045\u304f\u306a\u308b)\n# pypy\u306f,numpy\u4f7f\u7528\u4e0d\u53ef\n# python\u306e\u5b9f\u884c\u6642\u9593\u306e\u30aa\u30fc\u30c0\u30fc\u306f\u300110^8\u307e\u3067\n# \u6700\u5c0f\u5024\u306e\u6700\u5927\u5316(\u6700\u5927\u5024\u306e\u6700\u5c0f\u5316)\u306f\u4e8c\u5206\u63a2\u7d22\n# O(2^n)\u306fdp\u304c\u591a\u3081\n# \u3079\u304d\u4e57\u306fpow\u3092\u4f7f\u3046(mod\u3067\u5272\u308b\u7cfb\u306f\u5e73\u8861\u4e8c\u5206\u6728\u304c\u7d44\u307e\u308c\u3066\u3044\u308b\u305f\u3081)\n\nfrom collections import Counter, deque, defaultdict, OrderedDict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement, permutations\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import lru_cache\n# Set\u306e\u3088\u3046\u306b\u5024\u3092O(\u221an)\u3067\u898b\u3064\u3051\u308b\u3001\u914d\u5217\u306e\u3088\u3046\u306b[0]\u3068[-1]\u3067\u6700\u5c0f\u3001\u6700\u5927\u53d6\u5f97\u306fO(1)\nfrom sortedcontainers import SortedSet, SortedList, SortedDict\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN, getcontext\n# \u591a\u500d\u9577\u7cbe\u5ea6\u3092100\u6841\u306b\u3059\u308b\ngetcontext().prec = 100\nimport math\nimport sys\nfrom copy import deepcopy, copy\n# \u5206\u6570\u30e2\u30b8\u30e5\u30fc\u30eb\nfrom fractions import Fraction\nsys.setrecursionlimit(10 ** 7)\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef S(): return input()\ndef SI(): return map(str, input().split())\ndef LS(): return list(map(str, input().split()))\nINF = 10**18\nMOD = 998244353 # \u7d20\u6570\u3001\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u3001\u5e73\u8861\u4e8c\u5206\u6728\ndict = defaultdict(lambda:defaultdict())\n\nn, k = MI()\na = LI()\n\nif k <= 0:\n    if sum(a) >= 0:\n        print(\"Yes\")\n        print(*sorted(a, reverse=True))\n    else:\n        print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*sorted(a))\n\n\n",
        "length": 49,
        "loc": 40
    },
    "arc180_a_55032207": {
        "buggy": "MOD=10**9+7\nn = int(input())\ns = input()\nans=1\ncnt=0\nfor i in range(n):\n    cnt+=1\n    if i==n-1 or s[i]==s[i+1]:\n        ans*=cnt//2\n        ans%=MOD\n        cnt=0\nprint(ans%MOD)\n",
        "length": 12,
        "loc": 9
    },
    "arc180_b_55029920": {
        "buggy": "n,k=map(int,input().split())\np=list(map(int,input().split()))\nq=[0]*n\nfor i in range(n):\n  p[i]-=1\n  q[p[i]]=i\ne=[]\nfor i in range(n):\n  r=[j for j in range(i) if q[j]-q[i]>=k]\n  s=i\n  for t in r[::-1]:\n    q[s],q[t]=q[s],q[t]\n    e+=[(q[s],q[t])]\n    s=t\nprint(len(e))\nfor i,j in e:\n  print(i+1,j+1)",
        "length": 17,
        "loc": 14
    }
}